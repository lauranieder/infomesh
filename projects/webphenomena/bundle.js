! function a(o, s, l) {
    function c(t, e) { if (!s[t]) { if (!o[t]) { var i = "function" == typeof require && require; if (!e && i) return i(t, !0); if (h) return h(t, !0); var n = new Error("Cannot find module '" + t + "'"); throw n.code = "MODULE_NOT_FOUND", n } var r = s[t] = { exports: {} };
            o[t][0].call(r.exports, function(e) { return c(o[t][1][e] || e) }, r, r.exports, a, o, s, l) } return s[t].exports } for (var h = "function" == typeof require && require, e = 0; e < l.length; e++) c(l[e]); return c }({ 1: [function(e, t, i) { "use strict";

        function r(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } }
        Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var a = e("three"),
            n = function() {
                function i(e, t) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, i), this.width = e, this.height = t, this.camera = null, this.scene = null, this.plane = null } var e, t, n; return e = i, (t = [{ key: "init", value: function(t) { var i = this;
                        this.scene = new a.Scene, this.camera = new a.OrthographicCamera(this.width / -2, this.width / 2, this.height / 2, this.height / -2, 0, 1e4), this.camera.position.z = 1430.5; var n = new a.PlaneGeometry(this.width, this.height),
                            e = new a.CubeTextureLoader;
                        e.setPath("assets/texture/opera/"), e.load(["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"], function(e) { i.material = new a.MeshBasicMaterial({ map: t.texture }), i.plane = new a.Mesh(n, i.material), i.scene.add(i.plane) }); var r = new a.DirectionalLight(16777215, 3.3);
                        r.position.set(0, 100, 50), this.scene.add(r), this.scene.add(this.camera) } }, { key: "animate", value: function(e) {} }, { key: "loadAssets", value: function() {} }, { key: "onWindowResize", value: function(e, t) { this.width = e, this.height = t, this.camera.updateProjectionMatrix() } }]) && r(e.prototype, t), n && r(e, n), i }();
        i.default = n }, { three: 15 }], 2: [function(e, t, i) { "use strict";
        Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var r = n(e("gsap/umd/TweenMax")),
            a = n(e("three"));

        function n(e) { if (e && e.__esModule) return e; var t = {}; if (null != e)
                for (var i in e)
                    if (Object.prototype.hasOwnProperty.call(e, i)) { var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, i) : {};
                        n.get || n.set ? Object.defineProperty(t, i, n) : t[i] = e[i] }
            return t.default = e, t }

        function o(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } var s = e("glslify"),
            l = function() {
                function i(e, t) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, i), this.width = e, this.height = t, this.camera = null, this.scene = null, this.plane = null, this.animTrans = null, this.renderBuffer = new a.WebGLRenderTarget(this.width, this.height, { minFilter: a.LinearFilter, magFilter: a.NearestFilter }), this.renderBufferSwap = new a.WebGLRenderTarget(this.width, this.height, { minFilter: a.LinearFilter, magFilter: a.NearestFilter }) } var e, t, n; return e = i, (t = [{ key: "init", value: function(e, t) { this.slide = t, this.scene = new a.Scene, this.camera = new a.OrthographicCamera(this.width / -2, this.width / 2, this.height / 2, this.height / -2, -1e4, 1e4), this.camera.position.z = 2.5; var i = new a.PlaneGeometry(this.width, this.height);
                        this.params = { FeedbackMix: 1, NoiseSize: 8, NoiseMix: .001, NoiseSpeed: .001, Contrast: 0, feedBackHolder: .3, contrastHolder: 0 }, this.material = new a.ShaderMaterial({ vertexShader: s(["precision highp float;\n#define GLSLIFY 1\n// varying vec3 vNorm;\nvarying vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\n\nvoid main() {\n  vUv = uv;\n  // vNorm = position.xyz;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"]), fragmentShader: s(["// #extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\n// varying vec3 vNorm;\nvarying vec2 vUv;\nuniform sampler2D bufferTexture;\n\nuniform float iGlobalTime;\nuniform float Contrast;\nuniform float FeedbackMix;\nuniform float NoiseSize;\nuniform float NoiseMix;\nuniform float NoiseSpeed;\nuniform float scaleDirection;\nuniform sampler2D inputTexture;\nuniform sampler2D dispTexture;\nuniform vec2 resolution;\n\n// #define TEXEL_SIZE 1.0/512.0 \n\n// vec3 sample(vec2 uv);\n// #pragma glslify: blur = require('glsl-hash-blur', sample=sample, iterations=10)\n// #pragma glslify: halftone = require('glsl-halftone')\n// #pragma glslify: checker = require('glsl-checker')\n\nvec3 sample(vec2 uv) {\n  return texture2D(inputTexture, uv).rgb;\n}\n\nvec3 sample2(vec2 uv) {\n  return texture2D(dispTexture, uv).rgb;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 saturation(vec3 rgb, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return mix(intensity, rgb, adjustment);\n}\n\nfloat PI = 3.14;\n\nvoid main() {\n  vec2 pos = vUv.xy;\n  // vec2 pos = gl_FragCoord.xy / resolution.xy;\n\n  vec2 cUv = vUv;\n  vec2 disp = vUv.xy;\n\n  vec2 disp2 = cUv.xy;\n  // disp += snoise( pos * 5.0 ) * iGlobalTime * 0.03; \n  disp += snoise( vec3(pos.x * 5.0, pos.y * 5.0, iGlobalTime) ) * 0.03; \n\n  // // vec3 vNorm2 = vNorm;\n\n  // Perpetual movement\n  disp *= gl_FragCoord.xy * iGlobalTime * NoiseSpeed;\n  cUv *= sin(iGlobalTime * 0.02 + disp.xy) * 0.002 * iGlobalTime * 0.02  + 1.0;\n\n  // disp2 += snoise( disp2 * NoiseSize + iGlobalTime * NoiseSpeed ) * NoiseMix; \n\n  disp2 += snoise( vec3(disp2.x * NoiseSize, disp2.y * NoiseSize, iGlobalTime * NoiseSpeed) ) * NoiseMix; \n    // disp2.x+=.0005;\n    // disp2.y+=.0005;\n    // disp2*=.9995;\n\n  \n  // pos += vec2(0.0, -0.001);\n\n \n vec2 posScale=pos;\n\nif(scaleDirection>0.){\n  posScale*=1.01;\n  posScale-=.005;\n  disp2*=1.01;\n  disp2-=.005;\n}else{\n  posScale*=.99;\n  posScale+=.005;\n  disp2*=.99;\n  disp2+=.005;\n}\n\n  vec3 bufferColor = texture2D(bufferTexture, disp2 ).rgb;\n  // vec3 bufferColor = texture2D(bufferTexture, posScale ).rgb;\n  // vec3 bufferColor = texture2D(bufferTexture, vUv ).rgb;\n  // vec3 inputColor = texture2D(inputTexture, pos ).rgb;\n  vec3 inputColor = texture2D(inputTexture, pos ).rgb;\n\n    vec3 newCurrent = inputColor;\n    newCurrent *= newCurrent;\n    newCurrent *= newCurrent;\n    newCurrent *= newCurrent;\n    newCurrent *= newCurrent;\n    newCurrent = saturation(newCurrent, 30.0);\n\n    inputColor = mix(inputColor, newCurrent, Contrast);\n\n  vec3 current = mix(bufferColor, inputColor, FeedbackMix);\n\n    vec3 fb = current.rgb;\n    // fb = bufferColor - fb;\n    // bufferColor = fb + bufferColor;\n    // fb = bufferColor + fb * 0.1;\n    // bufferColor = fb + bufferColor;\n    // fb.rb = fract(current.gb);\n\n    // gl_FragColor = vec4( fb, 1 );\n    gl_FragColor = vec4( current, 1 );\n  // gl_FragColor = vec4( color.rgb, 1. );\n\n  // gl_FragColor.r += 0.1;\n  // gl_FragColor.rgb += color * 0.01;\n}\n\n"]), uniforms: { inputTexture: { type: "t", value: e.texture }, dispTexture: { type: "t", value: e.texture }, iGlobalTime: { type: "f", value: 0 }, bufferTexture: { type: "t", value: this.renderBufferSwap.texture }, resolution: { type: "v2", value: new a.Vector2 }, FeedbackMix: { type: "f", value: this.params.FeedbackMix }, NoiseSize: { type: "f", value: this.params.NoiseSize }, NoiseMix: { type: "f", value: this.params.NoiseMix }, NoiseSpeed: { type: "f", value: this.params.NoiseSpeed }, Contrast: { type: "f", value: this.params.Contrast }, scaleDirection: { type: "f", value: 1 } }, defines: { USE_MAP: "" } }), this.plane = new a.Mesh(i, this.material), this.scene.add(this.plane), this.scene.add(this.camera) } }, { key: "animate", value: function(e) { this.material.uniforms.iGlobalTime.value = e; var t = this.renderBufferSwap;
                        this.renderBufferSwap = this.renderBuffer, this.renderBuffer = t, this.material.uniforms.bufferTexture.value = this.renderBufferSwap.texture } }, { key: "loadAssets", value: function() {} }, { key: "onWindowResize", value: function(e, t) { this.width = e, this.height = t, this.camera.left = this.width / -2, this.camera.right = this.width / 2, this.camera.top = this.height / 2, this.camera.bottom = this.height / -2, this.plane.geometry = new a.PlaneGeometry(this.width, this.height), this.renderBuffer.width = this.width, this.renderBuffer.height = this.height, this.renderBufferSwap.width = this.width, this.renderBufferSwap.height = this.height, this.camera.updateProjectionMatrix() } }, { key: "transition", value: function(e) { var t = this,
                            i = e,
                            n = 1;
                        n = i > this.slide ? -1 : 1, this.slide = i, this.material.uniforms.scaleDirection.value = n, this.animTrans && this.animTrans.kill(), this.animTrans = r.fromTo(this.params, 1, { FeedbackMix: this.params.feedBackHolder, Contrast: this.params.contrastHolder }, { FeedbackMix: .1, Contrast: .4 }).eventCallback("onUpdate", function() { t.params.feedBackHolder = t.params.FeedbackMix, t.params.contrastHolder = t.params.Contrast, t.material.uniforms.FeedbackMix.value = t.params.feedBackHolder, t.material.uniforms.Contrast.value = t.params.contrastHolder }).eventCallback("onComplete", function() { t.animTrans = r.fromTo(t.params, 1, { FeedbackMix: t.params.feedBackHolder, Contrast: t.params.contrastHolder }, { FeedbackMix: 1, Contrast: 0 }).eventCallback("onUpdate", function() { t.params.feedBackHolder = t.params.FeedbackMix, t.params.contrastHolder = t.params.Contrast, t.material.uniforms.FeedbackMix.value = t.params.feedBackHolder, t.material.uniforms.Contrast.value = t.params.contrastHolder }) }) } }]) && o(e.prototype, t), n && o(e, n), i }();
        i.default = l }, { glslify: 11, "gsap/umd/TweenMax": 12, three: 15 }], 3: [function(e, t, i) { "use strict";
        Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var n, r = function(e) {
                { if (e && e.__esModule) return e; var t = {}; if (null != e)
                        for (var i in e)
                            if (Object.prototype.hasOwnProperty.call(e, i)) { var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, i) : {};
                                n.get || n.set ? Object.defineProperty(t, i, n) : t[i] = e[i] }
                    return t.default = e, t } }(e("three")),
            a = (n = e("./VideoPlane")) && n.__esModule ? n : { default: n };

        function o(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } }
        e("glslify"), e("three-orbit-controls")(r); var s = function() {
            function i(e, t) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, i), this.width = e, this.height = t, this.camera = null, this.scene = new r.Scene, this.plane = null, this.renderBuffer = new r.WebGLRenderTarget(this.width, this.height, { minFilter: r.LinearFilter, magFilter: r.NearestFilter }) } var e, t, n; return e = i, (t = [{ key: "initImages", value: function(e, t, i) { this.md = i, this.mediaPlanes = [], this.images = e, this.slide = t, this.mediaPlanes = []; for (var n = 0; n < this.images.length; n++) this.mediaPlanes.push(new a.default(this.width, this.height, this.scene, this.md)), this.mediaPlanes[n].initImage(this.images[n], n);
                    this.mediaPlanes[this.slide].transitionIn(), this.mediaPlanes[this.slide].transitionIn() } }, { key: "initVideos", value: function(e, t, i) { this.md = i, this.mediaPlanes = [], this.videos = e, this.slide = t; for (var n = 0; n < this.videos.length; n++) this.mediaPlanes.push(new a.default(this.width, this.height, this.scene, this.md)), this.mediaPlanes[n].initVideo(this.videos[n], n);
                    this.mediaPlanes[this.slide].transitionIn(), this.mediaPlanes[this.slide].transitionIn() } }, { key: "init", value: function() { this.camera = new r.OrthographicCamera(this.width / -2, this.width / 2, this.height / 2, this.height / -2, -1e4, 1e4), this.camera.position.z = 2.5; var e = new r.TorusKnotGeometry(10, 3, 100, 16),
                        t = new r.MeshStandardMaterial({ color: 16777215, roughness: .5, metalness: .8, transparent: !0, opacity: 1 });
                    this.TorusKnot = new r.Mesh(e, t), this.TorusKnot.position.z = 200, this.TorusKnot.scale.multiplyScalar(20); var i = new r.DirectionalLight(16777215, 10),
                        n = new r.AmbientLight(16777215, 0);
                    i.position.set(50, 50, 50), this.scene.add(i), this.scene.add(n), this.scene.add(this.camera) } }, { key: "animate", value: function(e) { var t = e;
                    this.TorusKnot.rotation.y += .004, this.TorusKnot.rotation.z += .004, this.TorusKnot.rotation.x += .004; for (var i = 0; i < this.mediaPlanes.length; i++) this.mediaPlanes[i].animate(t) } }, { key: "loadAssets", value: function() {} }, { key: "onWindowResize", value: function(e, t) { this.width = e, this.height = t, this.camera.left = this.width / -2, this.camera.right = this.width / 2, this.camera.top = this.height / 2, this.camera.bottom = this.height / -2; for (var i = 0; i < this.mediaPlanes.length; i++) this.mediaPlanes[i].onWindowResize(this.width, this.height);
                    this.renderBuffer.width = this.width, this.renderBuffer.height = this.height, this.camera.updateProjectionMatrix() } }, { key: "updateSlide", value: function(e) { this.slide = e; for (var t = 0; t < this.mediaPlanes.length; t++) this.mediaPlanes[t].isActive && this.mediaPlanes[t].transitionOut();
                    this.mediaPlanes[this.slide] && this.mediaPlanes[this.slide].transitionIn() } }]) && o(e.prototype, t), n && o(e, n), i }();
        i.default = s }, { "./VideoPlane": 8, glslify: 11, three: 15, "three-orbit-controls": 14 }], 4: [function(e, t, i) { "use strict";

        function r(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } }
        Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var n = function() {
            function t(e) { switch (function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t), this.devtools = { open: !1, orientation: null }, this.role = e, this.role) {
                    case "Design":
                        this.padding = 82; break;
                    case "Design & Code":
                        this.padding = 56; break;
                    case "Code":
                        this.padding = 87; break;
                    default:
                        throw "Please select an appropriate role in the project" }
                this.h = ["              _-o#&&*''''?d:>b|_             \n          _o/\"'''  '',, dMF9MMMMMHo_          \n       .o&#'        '\"MbHMMMMMMMMMMMHo.       \n     .o\"\" '         vodM*$&&HMMMMMMMMMM?.     \n    ,'              $M&ood,~''(&##MMMMMMH|    \n   /               ,MMMMMMM#b?#bobMMMMHMMML   \n  &              ?MMMMMMMMMMMMMMMMM7MMM$R*Hk  \n ?$.            :MMMMMMMMMMMMMMMMMMM/HMMM|'*L \n|               |MMMMMMMMMMMMMMMMMMMMbMH'   T,\n$H#:            '*MMMMMMMMMMMMMMMMMMMMb#}'  '?\n]MMH#             \"\"*\"\"\"\"*#MMMMMMMMMMMMM'    -\nMMMMMb_                   |MMMMMMMMMMMP'     :\nHMMMMMMMHo                 'MMMMMMMMMT       .\n?MMMMMMMMP                  9MMMMMMMM}       -\n-?MMMMMMM                  |MMMMMMMMM?,d-    '\n :|MMMMMM-                 'MMMMMMMT .M|.   : \n  .9MMM[                    &MMMMM*' ''    .  \n   :9MMk                    'MMM#\"        -   \n     &M}                     '          .-    \n      '&.                             .       \n        '~,   .                     ./        \n            . _                  .-           \n              ''--._,dd###pp=\"\"'              \n", "              v->#H#P? \"':o<>|_              \n          .,dP' '''  \"'-o.+H6&MMMHo_          \n        oHMH9'         '?&bHMHMMMMMMHo.       \n      oMP\"' '           ooMP*#&HMMMMMMM?.     \n    ,M*          -     '*MSdob//'^&##MMMH|    \n   d*'                .,MMMMMMH#o>#ooMMMMMb   \n  HM-                :HMMMMMMMMMMMMMMM&HM[R|  \n d\"Z|.               9MMMMMMMMMMMMMMMMM[HMM|: \n-H    -              MMMMMMMMMMMMMMMMMMMbMP' :\n:??Mb#               '9MMMMMMMMMMMMMMMMMMH#! .\n: MMMMH#,              \"*\"\"\"\"'#HMMMMMMMMMMH  -\n||MMMMMM6|.                    {MMMMMMMMMH'  :\n:|MMMMMMMMMMHo                 '9MMMMMMMM'   .\n. HMMMMMMMMMMP'                 !MMMMMMMM    '\n- '#MMMMMMMMM                   HMMMMMMM*,/  :\n :  ?MMMMMMMF                   HMMMMMM',P' : \n  .  HMMMMR'                    {MMMMP' ^' -  \n   : 'HMMMT                     iMMH'     .'  \n    -.'HMH                               .    \n      -:*H                            . '     \n        -'|,,    .                  .-        \n          ' .  _                 .-'          \n              ''~|.__,obb#q==~'''             \n", "              .ovr:HMM#?:'' >b|_             \n          .,:&Hi' ''   \"' ||&bSMHo_           \n        oHMMM#*}          '?&dMMMMMMHo.       \n     .dMMMH\"''''           ,oHH*&&9MMMM?.     \n    ,MMM*'                 '*M|bd<|\"*&#MH|    \n   dHH?'                   :MMMMMM#bd#odMML   \n  H' ||                  'dMMMMMMMMMMMMMM9Mk  \n JL/\"7+,.                'MMMMMMMMMMMMMMMH9ML \n-'Hp     '               |MMMMMMMMMMMMMMMMHH|:\n:  |#M#d?                'HMMMMMMMMMMMMMMMMH. \n.   JMMMMM##,              '*\"\"'\"*#MMMMMMMMH  \n-. ,MMMMMMMM6o_                    |MMMMMMMM':\n:  |MMMMMMMMMMMMMb|                 TMMMMMMT :\n.   ?MMMMMMMMMMMMM'                 :MMMMMM|.'\n-    ?HMMMMMMMMMM:                  HMMMMMM||:\n :     9MMMMMMMMH'                 'MMMMMP.P. \n  .    'MMMMMMT''                   HMMM*''-  \n   -    TMMMMM'                     MM*'  -   \n    '.   HMM#                            -    \n      -. '9M:                          .'     \n        -. 'b,,    .                . '       \n          '-|   .,               .-'          \n              '-:b~|_,oddq==--\"               \n", "              _oo##'9MMHb':'-,o_             \n          .oH\":HH$' \"\"'  \"' -7*R&o_           \n       .oHMMMHMH#9:          \"|bMMMMHo.       \n      dMMMMMM*\"\"'''           .oHM\"H9MM?.     \n    ,MMMMMM'                   \"HLbd<|?&H|    \n   JMMH#H'                     |MMMMM#b>bHb   \n  :MH  .\"|                   '|MMMMMMMMMMMM&  \n .:M:d-\"|:b..                 9MMMMMMMMMMMMM+ \n:  \"*H|      -                &MMMMMMMMMMMMMH:\n.    'LvdHH#d?                '?MMMMMMMMMMMMMb\n:      iMMMMMMH#b               '\"*\"'\"#HMMMMMM\n.   . ,MMMMMMMMMMb|.                   {MMMMMH\n-     |MMMMMMMMMMMMMMHb,               'MMMMM|\n:      |MMMMMMMMMMMMMMH'                &MMMM,\n-       '#MMMMMMMMMMMM                 |MMMM6-\n :        'MMMMMMMMMM+                 ]MMMT/ \n  .       'MMMMMMMP\"                   HMM*'  \n   -       |MMMMMH'                   ,M#'-   \n    '.     :MMMH|                       .-    \n      .     |MM                        -      \n       ' .   '#?..    .             ..'       \n           -.     _.             .-           \n              '-|.#qo__,,ob=~~-''             \n", "              _ooppH['MMMD::--|_             \n          .oHMMMR:\"&MZ| '\"'  \"  |$-_          \n       ..dMMMMMMMMdMMM#9|        ''HHo.       \n     . ,dMMMMMMMMMMM\"'' '           ?MP?.     \n    . |MMMMMMMMMMM'                 '\"$b&|    \n   -  |MMMMHH##M'                     HMMH?   \n  -   TTMM|    >..                   |MMMMMH  \n :     |MM|,#-\"\"$~b|.                'MMMMMM+ \n.       '\"H&#        -               &MMMMMM| \n:            *|v,#MHddc.              '9MMMMMb\n.               MMMMMMMM##|             '\"\":HM\n-          .  .HMMMMMMMMMMRo_.              |M\n:             |MMMMMMMMMMMMMMMM#|           :M\n-              'HMMMMMMMMMMMMMMM'           |T\n:               '*HMMMMMMMMMMMM'            H'\n :                 MMMMMMMMMMM|            |T \n  .                MMMMMMMM?'             ./  \n  '.               MMMMMMH'              ./   \n    -.            |MMMH#'                .    \n      .           'MM*                . '     \n        -.         #M: .    .       .-        \n          ' .         .,         .-           \n              '-.-~ooHH__,,v~--'              \n", "            _ood>H&H&Z?#M#b-|.               \n          .|HMMMMMR?'|M6b.\"'' '''v.           \n       .. .MMMMMMMMMMHMMM#&.      '~o.        \n     .   ,HMMMMMMMMMMMM*\"'-'          &b.     \n    .   .MMMMMMMMMMMMH'               '\"&|    \n   -     RMMMMM#H##R'                   4Mb   \n  -      |7MMM'    ?::                 '|MMb  \n /         HMM__#|'\"|>?v..              'MMML \n.           '\"'#Hd|       '              9MMM:\n-                ||,|?HH#bbL             '9MMb\n:                   !MMMMMMMH#b,          '\"\"T\n.              .   ,MMMMMMMMMMMbo.           |\n:                  4MMMMMMMMMMMMMMMHo        |\n:                   ?MMMMMMMMMMMMMMM?        :\n-.                   '#MMMMMMMMMMMM:        .-\n :                     |MMMMMMMMMM?         . \n  -                    JMMMMMMMT'          :  \n  '.                   MMMMMMH'           -   \n    -.                |MMM#*'            -    \n      .               HMH'            . '     \n        -.            #H:.          .-        \n          ' .           .|       .-           \n              '-..-+oodHL_,--/-'              \n", "             _,|?dZkMHF&$*q#b..              \n          .//9MMMMMMM?:'HM|\"'-'''..           \n       ..'  :MMMMMMMMMMHMMMMH?_    '-|        \n     .     .dMMMMMMMMMMMMMM'\"'\"       '|.     \n    .      |MMMMMMMMMMMMMR              |     \n   -        T9MMMMMHH##M\"                '?   \n  :          (9MMM'    !':.               &k  \n .:            HMM|_?p \"\":-b|.            'ML \n-                \"'\"H&#,       :           |M|\n:                     ?|,|dMH#b#.           9b\n:                        |MMMMMMM##,        '*\n:                   .   +MMMMMMMMMMMo_       -\n:                       HMMMMMMMMMMMMMM#,    :\n:                        9MMMMMMMMMMMMMH'    .\n: .                       *HMMMMMMMMMMP     .'\n :                          MMMMMMMMMH'     . \n  -                        :MMMMMMM''      .  \n  '.                       9MMMMM*'       -   \n    -.                    {MMM#'         :    \n      -                  |MM\"          .'     \n       '.                &M'..  .   ..'       \n          ' .             ._     .-           \n              '-. -voboo#&:,-.-'              \n", "             _oo:|bk99M[<$$+b|.              \n           .$*\"MMMMMMMM[:\"|Mb|?^\" .           \n       . ''    HMMMMMMMMMMHMMMM+?.  '.        \n     .        .HMMMMMMMMMMMMMMP\"''     .      \n    .         'MMMMMMMMMMMMMM|         -'.    \n   -           '&MMMMMMHH##H:             :   \n  :             '(*MMM}    '||             |  \n : '-              ?MMb__#|\"\"'|+v..         | \n.                    '''*H#b       -        :|\n:                         '*|v,#M#b#,        |\n.                             9MMMMMMHb.     :\n:                        .   #MMMMMMMMMb|    -\n-                           .HMMMMMMMMMMMMb  :\n:                            'MMMMMMMMMMMMH  .\n-:  .                         '#MMMMMMMMMP   '\n :                              ]MMMMMMMH'  : \n  -                            ,MMMMMM?'   .  \n  ':                           HMMMMH\"    -   \n    -.                       .HMM#*     .-    \n     '.                     .HH*'     .       \n       '-.                  &R\".    .-        \n           -.               ._   .-           \n              '-. .voodoodc?..-'              \n", "              _|oo|?ddk9MRbS>v|_             \n          ..:>*\"\"MMMMMMMMM:?|H?$?-.           \n       ..- -     \"HMMMMMMMMMMHMMMH|_-.        \n     .            dMMMMMMMMMMMMMMT\"    .      \n    .             TMMMMMMMMMMMMMM       '.    \n   -               '&HMMMMMM#H#H:         .   \n  -                 '|7HMMH     ||.        .  \n :    '                 HMM|_?c'\"\"+?|..     : \n-                         \"'#&#|      .     - \n:                              '?,|#MHdb.    .\n:                                 |MMMMMH#.  :\n:                            .   ,HMMMMMMMb, -\n: '                              4MMMMMMMMMMH'\n:   .                             9MMMMMMMMMT-\n:.'                               '#MMMMMMMH '\n :      '                           HMMMMMH': \n  -                                |MMMMH\" -  \n  ':                              |MMMH*' .'  \n    '?                           dMM#'   .    \n      |.                       .dH\"    .'     \n        -.                    ,M'-  ..'       \n          ' .                .. ..-'          \n              '-. .|ooooboo<^.-'              \n", "              _o,:o?|?dM&MHcc~,.             \n          ..^':&#\"\"HMMMMMMMM$:?&&?.           \n        .'  -'      'HMMMMMMMMMHMMMp|.        \n     . '             |MMMMMMMMMMMMMM\"' .      \n    .                '9MMMMMMMMMMMMM    -.    \n   -                   '*9MMMMMHH##[      .   \n  -                     '|Z9MMM    '~|     .  \n :       '|                 ?MMb_?p\"\"-?v..  : \n-                             '\"'*&#,    -   .\n:                                  '?,oHH#?  .\n--                                    |MMMMH,:\n:                                 .  |MMMMMM6,\n:   -                                |MMMMMMMM\n?                                     HMMMMMMP\n-- . '                                |HMMMMM'\n :.'     .  '                          JMMMM+ \n  |                                   ,MMMP:  \n   :                                 |MMH?:   \n    -:|.                            dM#\" .    \n       |                          ,H*' .'     \n        -.                       d':..'       \n          ' .                  .,.-           \n              '-.. .|oooodov~^-'              \n", "              _o|:,??|??MR9#cb|_             \n          .v/''':&#\"\"#HMMMMMMM$?*d|.          \n       ..~' - -'      '\"#MMMMMMMMMMMHv.       \n     .-'                 HMMMMMMMMMMMR!.      \n    :                    '9MMMMMMMMMMM| -.    \n   .                       '*9MMMMMH##|   .   \n  -                          '(#MMH   ':,  .  \n :           '|                 'HMb_>/\"||,.: \n.'                                '\"'#&b   - .\n:                                      ?|oHH?.\n:                                        !MMM&\n:  .                                  .  HMMMM\n/.      -                               -MMMMM\n|'.                                      9MMMP\n:. .  . -                                |MMM'\n |... '                                  .MMT \n  &.                                    .dMP  \n   |,                                  .HM*   \n    |. '|.                            ,H&'    \n     '- '| -                        ,&':      \n       '.                         ,/| '       \n          '-..                  _.-           \n              \"---.._|o,oov+--'\"              \n", "              _,d?,:?o?:?HM>#b|_             \n          ..H*\"''''H#*\"**MMMMMM6$$v_          \n        v//\"   - '      ''#MMMMMMMMHo.        \n      /\"'                   |MMMMMMMMMM:.     \n    ,>                       'HMMMMMMMMH:.    \n   :                           '#HMMMMHH| -   \n  '                              'Z#MM,  ',:  \n :               '|                 ?HH_>:'|, \n:                                     \"'*&| ':\n.                                         <|Hb\n:                                           MM\n:                                        . iMM\nMb|.                                       {MM\n::.'-       -                              !MP\n'&.   .  .  -                              :M'\n 9H,  |  '                                 |T \n  HM?                                     ,P  \n   *ML                                   ??   \n    :&.   'o                           .d'    \n      ':  |T                          /\"      \n        -.                         .<''       \n          '...                  ..-           \n              \"'-=.,_,,,oov-~.-'              \n", "            _,oc>?_:b?o?HH#b|_               \n          .v/99*\"\"\" '*H#\"\"*HMMMMMZ,_          \n        oH* /\"   -   '      \"'#MMMMM#o.       \n     ./*>-                     'MMMMMMMb      \n    ,b/'                        '#MMMMMMM|    \n   :'                             'HMMMMb:    \n  /-                                '|&MH '|  \n /                   '-.               |Hb??| \n,-  '                                    \"'&,.\n1                                           |}\n!.                                           T\n$,.                                        . 1\n?'M??.                                       M\n?.::| '|        -                            ?\n M?&.    .   .  -                           ,'\n 9MMH|   ..  '           '                  . \n  HMMM#.                                   :' \n   9#MMb                                 ..   \n    -:\"#     'b.                        .-    \n      . '    {!                        /      \n        -                           ,-'       \n          ' .                    .-           \n             '^==|_.,,,ov--|-'                \n", "              _|o##??,:io??$#b|_             \n          .oH#\"H9*\"\"\" \"'#H*\"*#MMMHo_          \n        oHMM- -'    -  ''     '*HMMHo.        \n      dM#S>-'                     ?MMMM?.     \n    ,&&,/'                         \"#MMMH|    \n   d?-\"                              '*HMMb   \n  H?                                   \"ZHb:  \n /:                        |              H?L \n|:|   .                                    '*:\n:?:                                          |\n>\"                                           :\nM||,_                                        |\n!|\":HH?-'.                                   :\n:^'_:?\"| '--         -                       .\n- |ML?b      .   ..  -                       -\n :HMMMMH|    |               '              : \n  >MMMMMM#.                                .  \n   ^M*HMMM|                               -   \n    '. '\"#+     '?v                     .'    \n      .   '-    +?'                    -      \n       ' .                          ..'       \n           - .                   .-           \n              \"'|b=p?.._|vv---'               \n", "              _,o#bH|??::?o?cbo_             \n          .o#MH#**SH\"\"' \"'*H#\"*#MHo_          \n        oHMMMH^  ^\"    -  '      '*HHo.       \n     .dMMM#\">>-                     'HM?.     \n    ,MH:R_o/                         '*MH|    \n   dMM' '                               \"ML   \n  HMR! '                                 '#k  \n d&'.                          -.          'L \n:M ::     '                                 '-\n/| !|                                        -\nk.$-\"                                        :\n}9R:!,,_.                                    .\n|::|':'*M#|-'.                               -\n: \"''..:\"!'|  '-          -                  '\n-   ,HMb.H|      .    _   -                 .'\n : ,MMMMMMMb.    ..                         . \n  .'HMMMMMMMM?                             .  \n  '.'9M#*HMMMM                            :   \n    -.'   \"##*      'b,                  .    \n      .      '     ,/'                 .'     \n       ' .                          ..'       \n           - .                  ..-           \n              \"'*#d##c.._|v----'              \n", "              _,o#&oHb?|o::d?>|_             \n          .oHHMMM#**$M\"\"' \"'*HH\"#&o_          \n        oHMMMMMMD' .''    -  '    'bo.        \n     .dMMMMMH*'/|-                   '|b.     \n    ,MMMM?T|_o/                        '|     \n   dMMMMP  ''                            '|   \n  HMMMH& -                                '|  \n /MH7' :                          --        : \n-:MM  {.      .                              .\n:i?' .!&                                     .\n:{, o| '                                     :\n-T?9M|:-'o,_                                 .\n: |?::'\"'?9MHo./..                           -\n.  '\"''^ _.'\"!\"^.  '-         -              '\n-      ,bMM?.M|       .    .  -      .      .'\n :   .oMMMMMMMMb.    ..   '                 . \n  .  'HMMMMMMMMMMb                         -  \n   -   9MH*#HMMMMH                        .'  \n    '.  '   '\"*##'      'b.              :    \n      .         '     .d''             .'     \n        -.                          . '       \n           -.                    .-'          \n              \"'*##H###:._|--.-'              \n", "              _oo#H&d#b?|b:_>>|_             \n          .oHMMMMMMH*\"*9R\"'-'*#P|-_           \n        oHMMMMMMMMM$  .\"       '   '^-        \n     .dMMMMMMMMH*\",?-                 '|.     \n    ,MMMMMMM:?}.,d'                     '.    \n   dMMMMMMMH  /''                         :   \n  HMMMMMMM&' -                             -  \n dPTMMP>' :                           -.    : \n|? -MM}  .|                                  .\nJ' ::*'  -$L                                 .\n:  ?b .,H- '                                 :\n-  |6.&MP:: !.,_.                            -\n:   '|:: \"' \"':\"MM#,-^,            -         :\n-     ':' _.:\"?'|   '-                   .    \n:         .?bMML.]#        -   _  '      .  .'\n -      .o#MMMMMMMMH|     |.          .     . \n  -     'HMMMMMMMMMMMH                     :  \n  '.     'HMM#*#MMMMMH'                   -   \n    -.     '    '##*'      i+           :     \n      -            ''     v/'          .'     \n       '-                           ..'       \n          ' .                    .-           \n              \"'*##HMH##:__,-.-'              \n", "              _oo##Mbb&bo??o_>|_             \n          .oHMMMMMMMMM**#?M*' \"?*&..          \n        oHMMMMMMMMMMMM4  '\"      -  '.        \n     .dMMMMMMMMMMMM#\"|?.-              .      \n    ,MMMMMMMMMM}\"9:_,d'                 -.    \n   dMMMMMMMMMMM|  ^''                     .   \n  &MMMMMMMMMMH|  -                         .  \n :{M*\"MMMPT\"' :                         '-. : \n.'M'  'MMM.  -T,       .                     .\n- k   i:?''  -|&                             .\n: '  -o&  .,H- \"                             :\n-     'M:'HMP|:'!.o._.                       .\n:      \"<:::'<^ '\"'9MH#,-^ .                - \n-         ''''''._.'\"?'^|   ^        -      : \n:              ?#dMM_.M?       .   .  -    ..'\n :          ,ddMMMMMMMMMb.    ..   '        . \n  .         TMMMMMMMMMMMMM,                :  \n   -         ?MMH**#MMMMMH'               :   \n    '.        '     \"'##*'      &.       :    \n      -.               ''    ,~\"       .'     \n        -.                          ..'       \n          ' .                    .-           \n             '*##HMMMH#<:,..-'                \n", "              _,dd#HMb&dHo?|?:|_             \n          .oHMMMMMMMMMMMH***9P''\"|v.          \n        oHMMMMMMMMMMMMMMM>  ''      -.        \n     .dMMMMMMMMMMMMMMMH*'|~-'          .      \n    ,MMMMMMMMMMMMM6>'H._,&              -.    \n   dMMMMMMMMMMMMMMM|  '\"                  .   \n  H*MMMMMMMMMMMMMH&. -                     .  \n d' HMM\"\"&MMMPT'' :.                      '.- \n,'  MP   'TMMM,   |:        .                -\n|   #:    ? *\"   : &L                        :\n!   ''   /?H   ,#r ''                        :\n.         ?M: HMM^<~->,o._                   :\n:          '9:::''*-'':'9MHb,|-,         '  : \n.             '\"''':' :_ \"\"!\"^.  '|          :\n'.                 _dbHM6_|H.      .   . '  .'\n |              _odHMMMMMMMMH,    ..  '     : \n '-             |MMMMMMMMMMMMM|            :  \n  '.             9MMH**#MMMMMH'           :   \n    -.            '     \"?##\"      d     :    \n      .                    '    ,/\"    .'     \n       '..                          ..'       \n          '  .                   .-           \n              ''\"#HHMMMMM#<>..-'              \n", "              _oo##bHMb&d#bd,>|_             \n          .oHMMMMMMMMMMMMMM***9R\"-..          \n        oHMMMMMMMMMMMMMMMMMH|  ?   '-.        \n     .dMMMMMMMMMMMMMMMMMMM#\".}-'       .      \n    ,MMMMMMMMMMMMMMMMM6/'H _o}          -.    \n   dMMMMMMMMMMMMMMMMMMML  '''             .   \n  HbP*HMMMMMMMMMMMMMMM*: -                 ,  \n dMH' 'MMMP'\"HMMMR'T\"  :                    : \n|H'   -MR'   '?MMMb    P,       .            .\n1&     *|     |.'*\"  .-'&|                   .\nM'      \"    ||&|  .,#~ \"'                   :\nT             :HL.|HMH|c~'|v,|_              :\n|              '\"|:::':'-' '\"MM#|-'.       -: \n%                 '''''' :_ '?''| '.      :   \n||,                     ,#dMM?.M?      .  .' -\n ?|                 .,odMMMMMMMMM?    |  '  : \n  /                 |MMMMMMMMMMMMM:        .' \n  '.                 TMMH#*9MMMMM*        :   \n    -.               '      \"*#*'    ,:  .    \n      .                       '   .v'' .'     \n       '.                           ..'       \n          '- .                   .-           \n              \"'|+HHMMMMMMHr~.-'              \n", "              _,,>#b&HMHd&&bb>|_             \n          _oHMMMMMMMMMMMMMMMMH**H:.           \n        oHMMMMMMMMMMMMMMMMMMMM#v'?  '.        \n     .dMMMMMMMMMMMMMMMMMMMMMMH*'+|     .      \n    ,MMMMMMMMMMMMMMMMMMMMMb|?+.,H       -.    \n   ddHMMMMMMMMMMMMMMMMMMMMMb  ''          .   \n  HMMkZ**HMMMMMMMMMMMMMMMMH|  -   .        :  \n dTMMM*  '9MMMP'\"*MMMMPT\"' ..               : \n|M6H''    4MP'   '\"HMMM|   !|.      .        .\n1MHp'      #L      $ *\"'  .-:&.              .\nMMM'        \"     q:H.  .o#-''              : \nMM'                ?H?.|MMH::::-o,_.         -\nM[                  '*?:::'|' '\"':9MH|~-.    '\n&M.                     \"\"'''^'.:.'?''. '|  -:\n'M|d,                       .dbHM[.1?     .. :\n 9||| .                  _obMMMMMMMMH,   .  : \n  H.^                    MMMMMMMMMMMM}     -  \n   |                     |MMH#*HMMMMH'    .'  \n    .                    '      '#*'   ,:-    \n     '                           '' .-'.      \n       '.                           .-        \n          '- .                   .-'          \n              ''|bqHMMMMMMHHb--'              \n", "              .,:,#&6dHHHb&##o|_             \n          .oHHMMMMMMMMMMMMMMMMMH*|,.          \n        oHMMMMMMMMMMMMMMMMMMMMMMHb:'-.        \n     .dMMMMMMMMMMMMMMMMMMMMMMMMMH||/'  .      \n    ,&HMMMMMMMMMMMMMMMMMMMMMMM/\"&.,d.   -.    \n   dboMMHMMMMMMMMMMMMMMMMMMMMMML ''       .   \n  HMHMMM$Z***MMMMMMMMMMMMMMMMMM|.-         .  \n dMM}MMMM#'  '9MMMH?\"'MMMMR'T'  _           : \n|MMMbM#''     |MM\"    'MMMH.   <_           . \ndMMMM#&        *&.     .?'*\"   .'&:          .\nMMMMMH-         ''    -v/H   .dD \"'  '       :\nMMMM*                  '*M: 4MM*::-!v,_      :\nMMMM                     '*?::\" \"''\"?9Mb::. : \n&MMM,                       '\"'\"'|\"._ \"?'| - :\n'MMM}.H                          ,#dM[_H   ..:\n 9MMi'M: .                   .ooHMMMMMMM,  .. \n  9Mb '-                     1MMMMMMMMMM|  :  \n   ?M                        |MM#*#MMMM*  .   \n    -.                       '     |#\"' ,'    \n      .                            -\" v'      \n        -.                          .-        \n           - .                   . '          \n              '-*#d#HHMMMMHH#\"-'              \n", "              _,<_:&S6dHHHb&bb|_             \n          .odHMMMMMMMMMMMMMMMMMMM}-_          \n       .oHMMMMMMMMMMMMMMMMMMMMMMMM#d:.        \n      ?9MMMMMMMMMMMMMMMMMMMMMMMMMMMH-$ .      \n    ,::dHMMMMMMMMMMMMMMMMMMMMMMMMH:|.?? -.    \n   dMdboHMMHMMMMMMMMMMMMMMMMMMMMMMH, '    .   \n  HMMMM7MMMb$R***MMMMMMMMMMMMMMMMMH| -     .  \n dMMMMM/MMMMM*   '$MMMM*'\"*MMMM?&'  .       : \n|MMMMMMb1H*'       HMP'    '9MMM|   &.    .  .\ndMMMMMMM##~'       '#|      |.'*\"  .-9.      :\n9MMMMMMMM*           '     |v7?  .,H '' '    :\nSMMMMMMH'                   '9M_-MMH::-|v_   :\n:HMMMMM                       '|_:\"'|''':9Mv|.\n-|MMMMM,                         \"\"'''':.'?| |\n':MMMMM}.d}                         .?bM6,|  |\n :?MMM6  M|  .                   .,oHMMMMM| / \n  .?MMM- ''                      &MMMMMMMM|.  \n   -'HM-                         HMH#*MMM?:   \n    '.                           '   '#*:'    \n      -                              -'/      \n       ' .                          . '       \n          ' .                    . '          \n              '--##HH#HMMMHH#\"\"'              \n", "              _o,d_?dZdoHHHb#b|_             \n          .vdMMMMMMMMMMMMMMMMMMMMH|.          \n       .,HHMMMMMMMMMMMMMMMMMMMMMMMMH&,.       \n      /?RMMMMMMMMMMMMMMMMMMMMMMMMMMMMH|..     \n    ,|?>'T#RMMMMMMMMMMMMMMMMMMMMMMMM6'||/     \n   dMMbd#ooHMMMHMMMMMMMMMMMMMMMMMMMMMH,'' '   \n  HMMMMMMMTMMMMb$ZP**HMMMMMMMMMMMMMMMM|.   :  \n dMMMMMMMM}$MMMMMH'   'HMMMH?\"'MMMM?T' .    : \n|MMMMMMMMMMoMH*''      'MM?    'MMM|  +|    . \n1MMMMMMMMMMMb#/         ?#?      |'#\"  -T:   :\n*'HMMMMMMMMMM*'           \"     ~?&  .?} ' ' .\n- 4MMMMMMMMP\"                    'M? HMTc:|.: \n: 'MMMMMMM[                       \"#:::'>'\"?M{\n.  |MMMMMMH.                        ''''_':-  \n-  |MMMMMMM|.dD                         ,#Mb|'\n :  *MMMMM: iM|  .                   _oHMMMM: \n  .  ?MMMM'  \"'                     ,MMMMMMP  \n   :  'HMH                          JM#*MMT   \n    -.  '                           '   #'    \n      .                                /      \n        -.            -              .'       \n           -.                    . '          \n              '--=&&MH##HMHH#\"\"\"              \n", "              .-:?,Z?:&$dHH##b|_             \n           ,:bqRMMMMMMMMMMMMMMMMMHo.          \n        .?HHHMMMMMMMMMMMMMMMMMMMMMMMHo.       \n      -o/*M9MMMMMMMMMMMMMMMMMMMMMMMMMMMv      \n    .:H|b|'|?#HHMMMMMMMMMMMMMMMMMMMMMM6?Z|    \n   .?MMMHbdbbodMMMMHMMMMMMMMMMMMMMMMMMMM|':   \n  :MMMMMMMMMMM7MMMMb?6P**#MMMMMMMMMMMMMMM_ :  \n |MMMMMMMMMMMMb^MMMMMM?   '*MMMM*\"'MMMR<' . - \n.1MMMMMMMMMMMMMb]M#\"\"       9MR'   '?MMb  |. :\n-MMMMMMMMMMMMMMMH##|'        *&.     |'*' .| .\n-?\"\"*MMMMMMMMMMMMM'            '    |?b  ,}\" :\n:    MMMMMMMMMMH'                    'M_|M}r|?\n.    'MMMMMMMMM'                      '$_:''\"H\n-     TMMMMMMMM,                        '\"':: \n:     {MMMMMMMM| oH|                      .#M-\n :    '9MMMMMM' .MP   .                 ,oMMT \n  .     HMMMMP'  ''                    ,MMMP  \n   -     'MMH'                         HH9*   \n    '.    '                           ' .'    \n      -                               . '     \n       ' .               -          .-        \n          ' .                    .-           \n              ' -==pHMMH##HH#\"\"\"              \n"] } var e, i, n; return e = t, (i = [{ key: "init", value: function() { var n = this,
                        r = 0,
                        a = this.h.length;
                    console.clear(), console.log("%c" + this.role + " : http://alfatih.world", "border-bottom: 1px solid black; padding-right: " + this.padding + 'px;color: #000 !important; font-family: "Times New Roman", "Times", serif, serif; font-size: 15px; font-style: normal; text-decoration: none;'), console.log("%c " + this.h[r], "background: #8c8c8c; color: #ccc !important; font-family:monospace; font-size: 12px; font-style: normal;"); var o = function(e, t) { window.dispatchEvent(new CustomEvent("devtoolschange", { detail: { open: e, orientation: t } })) };
                    setInterval(function() { var e = 160 < window.outerWidth - window.innerWidth,
                            t = 160 < window.outerHeight - window.innerHeight,
                            i = e ? "vertical" : "horizontal";
                        t && e || !(window.Firebug && window.Firebug.chrome && window.Firebug.chrome.isInitialized || e || t) ? (n.devtools.open && o(!1, null), n.devtools.open = !1, n.devtools.orientation = null) : (n.devtools.open && n.devtools.orientation === i || o(!0, i), n.devtools.open = !0, n.devtools.orientation = i, r = a - 1 < r ? 0 : r, console.clear(), console.log("%c" + n.role + " : http://alfatih.world", "border-bottom: 1px solid black; padding-right: " + n.padding + 'px;color: #000 !important; font-family: "Times New Roman", "Times", serif, serif; font-size: 15px; font-style: normal; text-decoration: none;'), console.log("%c " + n.h[r], "background: #8c8c8c; color: #ccc !important; font-family:monospace; font-size: 12px; font-style: normal;"), r++) }, 500) } }]) && r(e.prototype, i), n && r(e, n), t }();
        i.default = n }, {}], 5: [function(e, t, i) { "use strict";
        Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var r = function(e) {
                { if (e && e.__esModule) return e; var t = {}; if (null != e)
                        for (var i in e)
                            if (Object.prototype.hasOwnProperty.call(e, i)) { var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, i) : {};
                                n.get || n.set ? Object.defineProperty(t, i, n) : t[i] = e[i] }
                    return t.default = e, t } }(e("three")),
            a = (n(e("./Utils.js")), n(e("./InteractiveScene"))),
            o = n(e("./DisplayScene")),
            s = n(e("./FeedbackScene"));

        function n(e) { return e && e.__esModule ? e : { default: e } }

        function l(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } var c = function() {
            function n(e, t, i) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, n), this.width = e, this.height = t, this.md = i, this.md ? this.pixelRatio = 1 : this.pixelRatio = window.devicePixelRatio ? window.devicePixelRatio : 1, this.displayScene = new o.default(this.width, this.height), this.feedbackScene = new s.default(this.width, this.height, this.slide), this.interactiveScene = new a.default(this.width, this.height) } var e, t, i; return e = n, (t = [{ key: "initImages", value: function(e, t, i) { this.images = e, this.slide = t, this.md = i, this.interactiveScene.initImages(this.images, this.slide, this.md), this.interactiveScene.init() } }, { key: "initVideos", value: function(e, t, i) { this.video = e, this.slide = t, this.md = i, this.interactiveScene.initVideos(this.video, this.slide, this.md), this.interactiveScene.init() } }, { key: "init", value: function() { this.clock = new r.Clock, this.renderer = new r.WebGLRenderer({}), this.renderer.setSize(this.width, this.height, !1), document.getElementById("canvas-container").appendChild(this.renderer.domElement), this.renderTarget = this.renderer.getRenderTarget(), this.displayScene.init(this.feedbackScene.renderBuffer), this.feedbackScene.init(this.interactiveScene.renderBuffer) } }, { key: "loadAssets", value: function() {} }, { key: "animate", value: function() { this.render() } }, { key: "render", value: function() { this.clock.getDelta(); var e = this.clock.getElapsedTime();
                    this.renderer.setRenderTarget(this.interactiveScene.renderBuffer), this.renderer.render(this.interactiveScene.scene, this.interactiveScene.camera), this.interactiveScene.animate(e), this.renderer.setRenderTarget(this.feedbackScene.renderBuffer), this.renderer.render(this.feedbackScene.scene, this.feedbackScene.camera), this.feedbackScene.animate(e), this.renderer.setRenderTarget(this.renderTarget), this.renderer.render(this.displayScene.scene, this.displayScene.camera) } }, { key: "onWindowResize", value: function(e, t) { this.width = e, this.height = t, this.interactiveScene.onWindowResize(this.width, this.height), this.displayScene.onWindowResize(this.width, this.height), this.feedbackScene.onWindowResize(this.width, this.height), this.renderer.setSize(this.width, this.height, !1) } }, { key: "updateSlide", value: function(e) { this.slide != e && (this.slide = e, this.interactiveScene.updateSlide(this.slide), this.feedbackScene.transition(this.slide)) } }]) && l(e.prototype, t), i && l(e, i), n }();
        i.default = c }, { "./DisplayScene": 1, "./FeedbackScene": 2, "./InteractiveScene": 3, "./Utils.js": 7, three: 15 }], 6: [function(e, t, i) { "use strict";

        function r(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } }
        Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var n = function() {
            function t(e) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t), this.ee = e } var e, i, n; return e = t, (i = [{ key: "init", value: function() { this.database = [], this.lastPopupIndex, this.initwithJson(), this.isFirstTime = !0 } }, { key: "onScroll", value: function(r, a) { var o = this;
                    document.addEventListener("timeline-scroll", function(e) { o.timelintEvent = e; var t = o.findClosestDate(o.timelintEvent.detail.date),
                            i = r,
                            n = a;
                        t ? o.scrollCalback(i, n) : o.timeoutScroll(i, n) }) } }, { key: "timeoutScroll", value: function(e, t) { var i = this,
                        n = e,
                        r = t;
                    setTimeout(function(e, t) { i.findClosestDate(i.timelintEvent.detail.date) ? i.scrollCalback(n, r) : i.timeoutScroll(n, r) }, 300) } }, { key: "scrollCalback", value: function(e, t) { var r = this,
                        i = (moment(this.timelintEvent.detail.normal), moment(this.timelintEvent.detail.date), this.findClosestDate(this.timelintEvent.detail.date)),
                        a = -1; if ($.each(this.database, function(e, t) { var i = moment(parseDate(t.start), "DD/MM/YYYY"),
                                n = "";
                            n = t.end ? moment(t.end, "DD/MM/YYYY") : moment(i).add(noDurationEventSize, "d"), i.subtract(eventPadding, "days"), n = n.add(eventPadding, "days"), r.timelintEvent.detail.date.unix() >= i.unix() && r.timelintEvent.detail.date.unix() <= n.unix() && (a = e) }), this.lastPopupIndex != a)
                        if (this.lastPopupIndex = a, this.isFirstTime) e(i.id);
                        else if (-1 != a) return void t(i.id);
                    this.isFirstTime = !1 } }, { key: "initwithJson", value: function() { var c = this;
                    $.ajax({ url: "events.json", type: "GET", dataType: "JSON" }).done(function(e) { for (var t = 0; t < e.length; t++) { var i = e[t].title,
                                n = e[t].start,
                                r = e[t].end,
                                a = e[t].content,
                                o = e[t].url,
                                s = t,
                                l = (moment(n, "DD/MM/YYYY").utc(), { title: i, start: n, end: r, content: a, url: o, id: s });
                            c.database.push(l), c.database.sort(), c.database.sort(function(e, t) { return moment(e.date, "DD/MM/YYYY").diff(moment(t.date, "DD/MM/YYYY")) }) } }) } }, { key: "findClosestDate", value: function(l) { var c, h = 1 / 0; return this.database.forEach(function(e) { var t, i = e.start,
                            n = i.match(/[0-9]{1,2}\/[0-9]{1,2}\/[0-9]{2,4}/g),
                            r = i.match(/[0-9]{1,2}\/[0-9]{2,4}/g),
                            a = i.match(/[0-9]{2,4}/g);
                        n ? t = moment(e.start, "DD/MM/YYYY") : r ? t = moment("01/" + e.start, "DD/MM/YYYY") : a && (t = moment("01/01/" + e.start, "DD/MM/YYYY")); var o = moment(l, "DD/MM/YYYY"),
                            s = Math.abs(t.diff(o));
                        s < h && (h = s, c = e) }), c } }]) && r(e.prototype, i), n && r(e, n), t }();
        i.default = n }, {}], 7: [function(e, t, i) { "use strict";
        Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var n = { toRadians: function(e) { return e * Math.PI / 180 }, toDegrees: function(e) { return 180 * e / Math.PI }, mapRange: function(e, t, i, n, r) { return n + (r - n) * (e - t) / (i - t) } };
        i.default = n }, {}], 8: [function(e, t, i) { "use strict";
        Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var n = function(e) {
            { if (e && e.__esModule) return e; var t = {}; if (null != e)
                    for (var i in e)
                        if (Object.prototype.hasOwnProperty.call(e, i)) { var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, i) : {};
                            n.get || n.set ? Object.defineProperty(t, i, n) : t[i] = e[i] }
                return t.default = e, t } }(e("three"));

        function a(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } var o = e("glslify"),
            r = function() {
                function r(e, t, i, n) {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, r), this.width = e, this.height = t, this.scene = i, this.md = n, this.isPlaying = !1, this.params = { threshold: -1, alphaHolder: -1 }, this.isActive = !1, this.animIn, this.animOut } var e, t, i; return e = r, (t = [{ key: "initVideo", value: function(e, t) { this.video = e, this.videoTexture = new n.VideoTexture(this.video), this.videoTexture.wrapS = n.RepeatWrapping, this.videoTexture.wrapT = n.RepeatWrapping, this.videoTexture.repeat.set(2, 2); var i = new n.PlaneGeometry(this.width, this.height);
                        this.PlaneMaterial = new n.ShaderMaterial({ vertexShader: o(["precision highp float;\n#define GLSLIFY 1\n// varying vec3 vNorm;\nvarying vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\n\nvoid main() {\n  vUv = uv;\n  // vNorm = position.xyz;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"]), fragmentShader: o(["// #extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float iGlobalTime;\nuniform float threshold;\nuniform sampler2D inputTexture;\nuniform vec2 resolution;\n\nfloat PI=3.14;\n\n/**\n * Computes the luminance of a color. \n *\n * @name czm_luminance\n * @glslFunction\n *\n * @param {vec3} rgb The color.\n * \n * @returns {float} The luminance.\n *\n * @example\n * float light = czm_luminance(vec3(0.0)); // 0.0\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \n */\nfloat czm_luminance(vec3 rgb)\n{\n  // Algorithm from Chapter 10 of Graphics Shaders.\n  const vec3 W=vec3(.2125,.7154,.0721);\n  return dot(rgb,W);\n}\n\nvec2 backgroundUV(vec2 uv,vec2 resolution,vec2 texResolution){\n  float tAspect=texResolution.x/texResolution.y;\n  float pAspect=resolution.x/resolution.y;\n  float pwidth=resolution.x;\n  float pheight=resolution.y;\n  \n  float width=0.;\n  float height=0.;\n  if(tAspect<pAspect){\n    height=pheight;\n    width=height*tAspect;\n  }else{\n    width=pwidth;\n    height=width/tAspect;\n  }\n  float x=(pwidth-width)/2.;\n  float y=(pheight-height)/2.;\n  if(tAspect<pAspect){\n    x += (iGlobalTime*20.);\n    \n  }else{\n    y-=(iGlobalTime*20.);\n  }\n  vec2 nUv=uv;\n  nUv-=vec2(x,y)/resolution;\n  nUv/=vec2(width,height)/resolution;\n  return nUv;\n}\n\nvoid main(){\n  \n  vec2 pos = vUv;\n  vec2 uvContain = backgroundUV(pos,resolution,vec2(1024));\n  \n  vec3 inputColor=texture2D(inputTexture,uvContain).rgb;\n  \n  float luminance=czm_luminance(inputColor);\n  luminance=min(max(luminance,0.),1.);\n  float seuil=step(-threshold,luminance);\n  \n  gl_FragColor=vec4(inputColor,seuil);\n}"]), uniforms: { inputTexture: { type: "t", value: this.videoTexture }, iGlobalTime: { type: "f", value: 0 }, resolution: { type: "v2", value: new n.Vector2(this.width, this.height) }, threshold: { type: "f", value: this.params.threshold } }, defines: { USE_MAP: "" }, transparent: !0 }), this.mediaPlane = new n.Mesh(i, this.PlaneMaterial), this.mediaPlane.position.z = t, this.scene.add(this.mediaPlane) } }, { key: "initImage", value: function(e, t) { this.image = e, this.imageTexture = (new n.TextureLoader).load("assets/" + this.image + ".jpg"), this.imageTexture.wrapS = n.RepeatWrapping, this.imageTexture.wrapT = n.RepeatWrapping, this.imageTexture.repeat.set(2, 2); var i = new n.PlaneGeometry(this.width, this.height);
                        this.PlaneMaterial = new n.ShaderMaterial({ vertexShader: o(["precision highp float;\n#define GLSLIFY 1\n// varying vec3 vNorm;\nvarying vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform vec2 resolution;\n\nvoid main() {\n  vUv = uv;\n  // vNorm = position.xyz;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n"]), fragmentShader: o(["// #extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\n#define GLSLIFY 1\nvarying vec2 vUv;\nuniform float iGlobalTime;\nuniform float threshold;\nuniform sampler2D inputTexture;\nuniform vec2 resolution;\n\nfloat PI=3.14;\n\n/**\n * Computes the luminance of a color. \n *\n * @name czm_luminance\n * @glslFunction\n *\n * @param {vec3} rgb The color.\n * \n * @returns {float} The luminance.\n *\n * @example\n * float light = czm_luminance(vec3(0.0)); // 0.0\n * float dark = czm_luminance(vec3(1.0));  // ~1.0 \n */\nfloat czm_luminance(vec3 rgb)\n{\n  // Algorithm from Chapter 10 of Graphics Shaders.\n  const vec3 W=vec3(.2125,.7154,.0721);\n  return dot(rgb,W);\n}\n\nvec2 backgroundUV(vec2 uv,vec2 resolution,vec2 texResolution){\n  float tAspect=texResolution.x/texResolution.y;\n  float pAspect=resolution.x/resolution.y;\n  float pwidth=resolution.x;\n  float pheight=resolution.y;\n  \n  float width=0.;\n  float height=0.;\n  if(tAspect<pAspect){\n    height=pheight;\n    width=height*tAspect;\n  }else{\n    width=pwidth;\n    height=width/tAspect;\n  }\n  float x=(pwidth-width)/2.;\n  float y=(pheight-height)/2.;\n  if(tAspect<pAspect){\n    x += (iGlobalTime*20.);\n    \n  }else{\n    y-=(iGlobalTime*20.);\n  }\n  vec2 nUv=uv;\n  nUv-=vec2(x,y)/resolution;\n  nUv/=vec2(width,height)/resolution;\n  return nUv;\n}\n\nvoid main(){\n  \n  vec2 pos = vUv;\n  vec2 uvContain = backgroundUV(pos,resolution,vec2(1024));\n  \n  vec3 inputColor=texture2D(inputTexture,uvContain).rgb;\n  \n  float luminance=czm_luminance(inputColor);\n  luminance=min(max(luminance,0.),1.);\n  float seuil=step(-threshold,luminance);\n  \n  gl_FragColor=vec4(inputColor,seuil);\n}"]), uniforms: { inputTexture: { type: "t", value: this.imageTexture }, iGlobalTime: { type: "f", value: 0 }, resolution: { type: "v2", value: new n.Vector2(this.width, this.height) }, threshold: { type: "f", value: this.params.threshold } }, defines: { USE_MAP: "" }, transparent: !0 }), this.mediaPlane = new n.Mesh(i, this.PlaneMaterial), this.mediaPlane.position.z = t, this.scene.add(this.mediaPlane) } }, { key: "animate", value: function(e) { var t = e;
                        this.PlaneMaterial.uniforms.iGlobalTime.value = t } }, { key: "onWindowResize", value: function(e, t) { this.width = e, this.height = t, this.mediaPlane.geometry = new n.PlaneGeometry(this.width, this.height), this.PlaneMaterial.uniforms.resolution.value = new n.Vector2(this.width, this.height) } }, { key: "transitionIn", value: function() { var e = this;
                        this.isActive = !0, this.animIn && this.animIn.kill(), this.animIn = TweenMax.fromTo(this.params, 2, { threshold: this.params.alphaHolder }, { threshold: 1 }).eventCallback("onUpdate", function() { e.md || e.video.play(), e.isPlaying = !0, e.params.alphaHolder = e.params.threshold, e.PlaneMaterial.uniforms.threshold.value = e.params.alphaHolder }).eventCallback("onComplete", function() {}) } }, { key: "transitionOut", value: function() { var e = this;
                        this.isActive = !1, this.animOut && this.animOut.kill(), this.md || this.video.pause(), this.animOut = TweenMax.fromTo(this.params, 2, { threshold: this.params.alphaHolder }, { threshold: -1 }).eventCallback("onUpdate", function() { e.params.alphaHolder = e.params.threshold, e.PlaneMaterial.uniforms.threshold.value = e.params.alphaHolder }).eventCallback("onComplete", function() { e.isPlaying = !1 }) } }]) && a(e.prototype, t), i && a(e, i), r }();
        i.default = r }, { glslify: 11, three: 15 }], 9: [function(e, t, i) { "use strict";
        Object.defineProperty(i, "__esModule", { value: !0 }), i.default = void 0; var r = n(e("events")),
            a = function(e) {
                { if (e && e.__esModule) return e; var t = {}; if (null != e)
                        for (var i in e)
                            if (Object.prototype.hasOwnProperty.call(e, i)) { var n = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(e, i) : {};
                                n.get || n.set ? Object.defineProperty(t, i, n) : t[i] = e[i] }
                    return t.default = e, t } }(e("gsap/umd/TweenMax")),
            o = n(e("./ThreeSetup")),
            s = n(e("./Timeline")),
            l = n(e("mobile-detect"));
        n(e("./Signature"));

        function n(e) { return e && e.__esModule ? e : { default: e } }

        function c(e, t) { for (var i = 0; i < t.length; i++) { var n = t[i];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n) } } var h = function() {
            function t() {! function(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, t), this.md = new l.default(window.navigator.userAgent), this.container = document.getElementById("container-project"), this.containerTimeline = document.getElementById("container-timeline"), this.width = this.container.offsetWidth, this.height = this.container.offsetHeight, this.isMobile = this.md.mobile(); var e = navigator.userAgent.toLowerCase(); - 1 != e.indexOf("safari") && (-1 < e.indexOf("chrome") || (this.isMobile = !0)), this.ee = new r.default } var e, i, n; return e = t, (i = [{ key: "run", value: function() { var t = this;
                    this.videos = [].slice.call(document.querySelectorAll("video")), this.images = []; for (var e = 0; e < this.videos.length; e++) this.images.push(this.videos[e].src.replace(/^.*[\\\/]/, "").replace(".mp4", ""));
                    this.threeSetup = new o.default(this.width, this.height, this.isMobile), this.timeline = new s.default(this.ee), this.timeline.init(), this.timeline.onScroll(function(e) { t.isMobile ? t.threeSetup.initImages(t.images, e, t.isMobile) : t.threeSetup.initVideos(t.videos, e, t.isMobile), t.threeSetup.init(), t.threeSetup.animate(), a.ticker.addEventListener("tick", t.animate.bind(t)), window.addEventListener("resize", t.onWindowResize.bind(t), !1), window.addEventListener("load", t.onWindowLoad.bind(t), !1) }, function(e) { t.threeSetup.updateSlide(e) }), this.renderID = 0, this.ee.on("animate", function(e) { "0" === e ? t.renderID = 0 : "1" === e ? t.renderID = 1 : "2" === e ? t.renderID = 2 : "3" === e && (t.renderID = 3) }) } }, { key: "animate", value: function() { this.threeSetup.animate() } }, { key: "onWindowResize", value: function() { this.width = this.container.offsetWidth, this.height = this.container.offsetHeight, this.threeSetup.onWindowResize(this.width, this.height) } }, { key: "onWindowLoad", value: function() { this.isMobile } }]) && c(e.prototype, i), n && c(e, n), t }();
        (new(i.default = h)).run() }, { "./Signature": 4, "./ThreeSetup": 5, "./Timeline": 6, events: 10, "gsap/umd/TweenMax": 12, "mobile-detect": 13 }], 10: [function(e, t, i) { var l = Object.create || function(e) { var t = function() {}; return t.prototype = e, new t },
            o = Object.keys || function(e) { var t = []; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.push(i); return i },
            a = Function.prototype.bind || function(e) { var t = this; return function() { return t.apply(e, arguments) } };

        function n() { this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = l(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }((t.exports = n).EventEmitter = n).prototype._events = void 0, n.prototype._maxListeners = void 0; var r, s = 10; try { var c = {};
            Object.defineProperty && Object.defineProperty(c, "x", { value: 0 }), r = 0 === c.x } catch (e) { r = !1 }

        function h(e) { return void 0 === e._maxListeners ? n.defaultMaxListeners : e._maxListeners }

        function u(e, t, i, n) { var r, a, o; if ("function" != typeof i) throw new TypeError('"listener" argument must be a function'); if ((a = e._events) ? (a.newListener && (e.emit("newListener", t, i.listener ? i.listener : i), a = e._events), o = a[t]) : (a = e._events = l(null), e._eventsCount = 0), o) { if ("function" == typeof o ? o = a[t] = n ? [i, o] : [o, i] : n ? o.unshift(i) : o.push(i), !o.warned && (r = h(e)) && 0 < r && o.length > r) { o.warned = !0; var s = new Error("Possible EventEmitter memory leak detected. " + o.length + ' "' + String(t) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
                    s.name = "MaxListenersExceededWarning", s.emitter = e, s.type = t, s.count = o.length, "object" == typeof console && console.warn && console.warn("%s: %s", s.name, s.message) } } else o = a[t] = i, ++e._eventsCount; return e }

        function d() { if (!this.fired) switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) {
                case 0:
                    return this.listener.call(this.target);
                case 1:
                    return this.listener.call(this.target, arguments[0]);
                case 2:
                    return this.listener.call(this.target, arguments[0], arguments[1]);
                case 3:
                    return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
                default:
                    for (var e = new Array(arguments.length), t = 0; t < e.length; ++t) e[t] = arguments[t];
                    this.listener.apply(this.target, e) } }

        function p(e, t, i) { var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: i },
                r = a.call(d, n); return r.listener = i, n.wrapFn = r }

        function f(e, t, i) { var n = e._events; if (!n) return []; var r = n[t]; return r ? "function" == typeof r ? i ? [r.listener || r] : [r] : i ? function(e) { for (var t = new Array(e.length), i = 0; i < t.length; ++i) t[i] = e[i].listener || e[i]; return t }(r) : g(r, r.length) : [] }

        function m(e) { var t = this._events; if (t) { var i = t[e]; if ("function" == typeof i) return 1; if (i) return i.length } return 0 }

        function g(e, t) { for (var i = new Array(t), n = 0; n < t; ++n) i[n] = e[n]; return i }
        r ? Object.defineProperty(n, "defaultMaxListeners", { enumerable: !0, get: function() { return s }, set: function(e) { if ("number" != typeof e || e < 0 || e != e) throw new TypeError('"defaultMaxListeners" must be a positive number');
                s = e } }) : n.defaultMaxListeners = s, n.prototype.setMaxListeners = function(e) { if ("number" != typeof e || e < 0 || isNaN(e)) throw new TypeError('"n" argument must be a positive number'); return this._maxListeners = e, this }, n.prototype.getMaxListeners = function() { return h(this) }, n.prototype.emit = function(e) { var t, i, n, r, a, o, s = "error" === e; if (o = this._events) s = s && null == o.error;
            else if (!s) return !1; if (s) { if (1 < arguments.length && (t = arguments[1]), t instanceof Error) throw t; var l = new Error('Unhandled "error" event. (' + t + ")"); throw l.context = t, l } if (!(i = o[e])) return !1; var c = "function" == typeof i; switch (n = arguments.length) {
                case 1:
                    ! function(e, t, i) { if (t) e.call(i);
                        else
                            for (var n = e.length, r = g(e, n), a = 0; a < n; ++a) r[a].call(i) }(i, c, this); break;
                case 2:
                    ! function(e, t, i, n) { if (t) e.call(i, n);
                        else
                            for (var r = e.length, a = g(e, r), o = 0; o < r; ++o) a[o].call(i, n) }(i, c, this, arguments[1]); break;
                case 3:
                    ! function(e, t, i, n, r) { if (t) e.call(i, n, r);
                        else
                            for (var a = e.length, o = g(e, a), s = 0; s < a; ++s) o[s].call(i, n, r) }(i, c, this, arguments[1], arguments[2]); break;
                case 4:
                    ! function(e, t, i, n, r, a) { if (t) e.call(i, n, r, a);
                        else
                            for (var o = e.length, s = g(e, o), l = 0; l < o; ++l) s[l].call(i, n, r, a) }(i, c, this, arguments[1], arguments[2], arguments[3]); break;
                default:
                    for (r = new Array(n - 1), a = 1; a < n; a++) r[a - 1] = arguments[a];! function(e, t, i, n) { if (t) e.apply(i, n);
                        else
                            for (var r = e.length, a = g(e, r), o = 0; o < r; ++o) a[o].apply(i, n) }(i, c, this, r) } return !0 }, n.prototype.on = n.prototype.addListener = function(e, t) { return u(this, e, t, !1) }, n.prototype.prependListener = function(e, t) { return u(this, e, t, !0) }, n.prototype.once = function(e, t) { if ("function" != typeof t) throw new TypeError('"listener" argument must be a function'); return this.on(e, p(this, e, t)), this }, n.prototype.prependOnceListener = function(e, t) { if ("function" != typeof t) throw new TypeError('"listener" argument must be a function'); return this.prependListener(e, p(this, e, t)), this }, n.prototype.removeListener = function(e, t) { var i, n, r, a, o; if ("function" != typeof t) throw new TypeError('"listener" argument must be a function'); if (!(n = this._events)) return this; if (!(i = n[e])) return this; if (i === t || i.listener === t) 0 == --this._eventsCount ? this._events = l(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, i.listener || t));
            else if ("function" != typeof i) { for (r = -1, a = i.length - 1; 0 <= a; a--)
                    if (i[a] === t || i[a].listener === t) { o = i[a].listener, r = a; break }
                if (r < 0) return this;
                0 === r ? i.shift() : function(e, t) { for (var i = t, n = i + 1, r = e.length; n < r; i += 1, n += 1) e[i] = e[n];
                    e.pop() }(i, r), 1 === i.length && (n[e] = i[0]), n.removeListener && this.emit("removeListener", e, o || t) } return this }, n.prototype.removeAllListeners = function(e) { var t, i, n; if (!(i = this._events)) return this; if (!i.removeListener) return 0 === arguments.length ? (this._events = l(null), this._eventsCount = 0) : i[e] && (0 == --this._eventsCount ? this._events = l(null) : delete i[e]), this; if (0 === arguments.length) { var r, a = o(i); for (n = 0; n < a.length; ++n) "removeListener" !== (r = a[n]) && this.removeAllListeners(r); return this.removeAllListeners("removeListener"), this._events = l(null), this._eventsCount = 0, this } if ("function" == typeof(t = i[e])) this.removeListener(e, t);
            else if (t)
                for (n = t.length - 1; 0 <= n; n--) this.removeListener(e, t[n]); return this }, n.prototype.listeners = function(e) { return f(this, e, !0) }, n.prototype.rawListeners = function(e) { return f(this, e, !1) }, n.listenerCount = function(e, t) { return "function" == typeof e.listenerCount ? e.listenerCount(t) : m.call(e, t) }, n.prototype.listenerCount = m, n.prototype.eventNames = function() { return 0 < this._eventsCount ? Reflect.ownKeys(this._events) : [] } }, {}], 11: [function(e, t, i) { t.exports = function(e) { "string" == typeof e && (e = [e]); for (var t = [].slice.call(arguments, 1), i = [], n = 0; n < e.length - 1; n++) i.push(e[n], t[n] || ""); return i.push(e[n]), i.join("") } }, {}], 12: [function(e, ae, t) {
        (function(e) { "use strict";

            function rt(e) { return (rt = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) { return typeof e } : function(e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } var at = void 0 !== ae && ae.exports && void 0 !== e ? e : window;
            (at._gsQueue || (at._gsQueue = [])).push(function() { var T, _, x, w, v, i, M, S, y, b, p, f, g, e, t, l, c, n;
                    at._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(n, h, y) { var m = function(e) { var t, i = [],
                                    n = e.length; for (t = 0; t !== n; i.push(e[t++])); return i },
                            g = function(e, t, i) { var n, r, a = e.cycle; for (n in a) r = a[n], e[n] = "function" == typeof r ? r(i, t[i], t) : r[i % r.length];
                                delete e.cycle },
                            v = function(e) { if ("function" == typeof e) return e; var f = "object" === rt(e) ? e : { each: e },
                                    m = f.ease,
                                    g = f.from || 0,
                                    v = f.base || 0,
                                    M = {},
                                    y = isNaN(g),
                                    b = f.axis,
                                    _ = { center: .5, end: 1 }[g] || 0; return function(e, t, i) { var n, r, a, o, s, l, c, h, u, d = (i || f).length,
                                        p = M[d]; if (!p) { if (!(u = "auto" === f.grid ? 0 : (f.grid || [1 / 0])[0])) { for (c = -1 / 0; c < (c = i[u++].getBoundingClientRect().left) && u < d;);
                                            u-- } for (p = M[d] = [], n = y ? Math.min(u, d) * _ - .5 : g % u, r = y ? d * _ / u - .5 : g / u | 0, h = 1 / (c = 0), l = 0; l < d; l++) a = l % u - n, o = r - (l / u | 0), p[l] = s = b ? Math.abs("y" === b ? o : a) : Math.sqrt(a * a + o * o), c < s && (c = s), s < h && (h = s);
                                        p.max = c - h, p.min = h, p.v = d = f.amount || f.each * (d < u ? d : b ? "y" === b ? d / u : u : Math.max(u, d / u)) || 0, p.b = d < 0 ? v - d : v } return d = (p[e] - p.min) / p.max, p.b + (m ? m.getRatio(d) : d) * p.v } },
                            M = function e(t, i, n) { y.call(this, t, i, n), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = e.prototype.render },
                            b = 1e-8,
                            _ = y._internals,
                            x = _.isSelector,
                            T = _.isArray,
                            e = M.prototype = y.to({}, .1, {}),
                            w = [];
                        M.version = "2.1.2", e.constructor = M, e.kill()._gc = !1, M.killTweensOf = M.killDelayedCallsTo = y.killTweensOf, M.getTweensOf = y.getTweensOf, M.lagSmoothing = y.lagSmoothing, M.ticker = y.ticker, M.render = y.render, M.distribute = v, e.invalidate = function() { return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), y.prototype.invalidate.call(this) }, e.updateTo = function(e, t) { var i, n = this,
                                r = n.ratio,
                                a = n.vars.immediateRender || e.immediateRender; for (i in t && n._startTime < n._timeline._time && (n._startTime = n._timeline._time, n._uncache(!1), n._gc ? n._enabled(!0, !1) : n._timeline.insert(n, n._startTime - n._delay)), e) n.vars[i] = e[i]; if (n._initted || a)
                                if (t) n._initted = !1, a && n.render(0, !0, !0);
                                else if (n._gc && n._enabled(!0, !1), n._notifyPluginsOfEnabled && n._firstPT && y._onPluginEvent("_onDisable", n), .998 < n._time / n._duration) { var o = n._totalTime;
                                n.render(0, !0, !1), n._initted = !1, n.render(o, !0, !1) } else if (n._initted = !1, n._init(), 0 < n._time || a)
                                for (var s, l = 1 / (1 - r), c = n._firstPT; c;) s = c.s + c.c, c.c *= l, c.s = s - c.c, c = c._next; return n }, e.render = function(e, t, i) { this._initted || 0 === this._duration && this.vars.repeat && this.invalidate(); var n, r, a, o, s, l, c, h, u, d = this,
                                p = d._dirty ? d.totalDuration() : d._totalDuration,
                                f = d._time,
                                m = d._totalTime,
                                g = d._cycle,
                                v = d._duration,
                                M = d._rawPrevTime; if (p - b <= e && 0 <= e ? (d._totalTime = p, d._cycle = d._repeat, d._yoyo && 0 != (1 & d._cycle) ? (d._time = 0, d.ratio = d._ease._calcEnd ? d._ease.getRatio(0) : 0) : (d._time = v, d.ratio = d._ease._calcEnd ? d._ease.getRatio(1) : 1), d._reversed || (n = !0, r = "onComplete", i = i || d._timeline.autoRemoveChildren), 0 === v && (d._initted || !d.vars.lazy || i) && (d._startTime === d._timeline._duration && (e = 0), (M < 0 || e <= 0 && -b <= e || M === b && "isPause" !== d.data) && M !== e && (i = !0, b < M && (r = "onReverseComplete")), d._rawPrevTime = h = !t || e || M === e ? e : b)) : e < b ? (d._totalTime = d._time = d._cycle = 0, d.ratio = d._ease._calcEnd ? d._ease.getRatio(0) : 0, (0 !== m || 0 === v && 0 < M) && (r = "onReverseComplete", n = d._reversed), -b < e ? e = 0 : e < 0 && (d._active = !1, 0 === v && (d._initted || !d.vars.lazy || i) && (0 <= M && (i = !0), d._rawPrevTime = h = !t || e || M === e ? e : b)), d._initted || (i = !0)) : (d._totalTime = d._time = e, 0 !== d._repeat && (o = v + d._repeatDelay, d._cycle = d._totalTime / o >> 0, 0 !== d._cycle && d._cycle === d._totalTime / o && m <= e && d._cycle--, d._time = d._totalTime - d._cycle * o, d._yoyo && 0 != (1 & d._cycle) && (d._time = v - d._time, (u = d._yoyoEase || d.vars.yoyoEase) && (d._yoyoEase || (!0 !== u || d._initted ? d._yoyoEase = u = !0 === u ? d._ease : u instanceof Ease ? u : Ease.map[u] : (u = d.vars.ease, d._yoyoEase = u = u ? u instanceof Ease ? u : "function" == typeof u ? new Ease(u, d.vars.easeParams) : Ease.map[u] || y.defaultEase : y.defaultEase)), d.ratio = u ? 1 - u.getRatio((v - d._time) / v) : 0)), d._time > v ? d._time = v : d._time < 0 && (d._time = 0)), d._easeType && !u ? (s = d._time / v, (1 === (l = d._easeType) || 3 === l && .5 <= s) && (s = 1 - s), 3 === l && (s *= 2), 1 === (c = d._easePower) ? s *= s : 2 === c ? s *= s * s : 3 === c ? s *= s * s * s : 4 === c && (s *= s * s * s * s), d.ratio = 1 === l ? 1 - s : 2 === l ? s : d._time / v < .5 ? s / 2 : 1 - s / 2) : u || (d.ratio = d._ease.getRatio(d._time / v))), f !== d._time || i || g !== d._cycle) { if (!d._initted) { if (d._init(), !d._initted || d._gc) return; if (!i && d._firstPT && (!1 !== d.vars.lazy && d._duration || d.vars.lazy && !d._duration)) return d._time = f, d._totalTime = m, d._rawPrevTime = M, d._cycle = g, _.lazyTweens.push(d), void(d._lazy = [e, t]);!d._time || n || u ? n && this._ease._calcEnd && !u && (d.ratio = d._ease.getRatio(0 === d._time ? 0 : 1)) : d.ratio = d._ease.getRatio(d._time / v) } for (!1 !== d._lazy && (d._lazy = !1), d._active || !d._paused && d._time !== f && 0 <= e && (d._active = !0), 0 === m && (2 === d._initted && 0 < e && d._init(), d._startAt && (0 <= e ? d._startAt.render(e, !0, i) : r || (r = "_dummyGS")), d.vars.onStart && (0 === d._totalTime && 0 !== v || t || d._callback("onStart"))), a = d._firstPT; a;) a.f ? a.t[a.p](a.c * d.ratio + a.s) : a.t[a.p] = a.c * d.ratio + a.s, a = a._next;
                                d._onUpdate && (e < 0 && d._startAt && d._startTime && d._startAt.render(e, !0, i), t || (d._totalTime !== m || r) && d._callback("onUpdate")), d._cycle !== g && (t || d._gc || d.vars.onRepeat && d._callback("onRepeat")), r && (d._gc && !i || (e < 0 && d._startAt && !d._onUpdate && d._startTime && d._startAt.render(e, !0, i), n && (d._timeline.autoRemoveChildren && d._enabled(!1, !1), d._active = !1), !t && d.vars[r] && d._callback(r), 0 === v && d._rawPrevTime === b && h !== b && (d._rawPrevTime = 0))) } else m !== d._totalTime && d._onUpdate && (t || d._callback("onUpdate")) }, M.to = function(e, t, i) { return new M(e, t, i) }, M.from = function(e, t, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new M(e, t, i) }, M.fromTo = function(e, t, i, n) { return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new M(e, t, n) }, M.staggerTo = M.allTo = function(e, t, i, n, r, a, o) { var s, l, c, h, u = [],
                                d = v(i.stagger || n),
                                p = i.cycle,
                                f = (i.startAt || w).cycle; for (T(e) || ("string" == typeof e && (e = y.selector(e) || e), x(e) && (e = m(e))), s = (e = e || []).length - 1, c = 0; c <= s; c++) { for (h in l = {}, i) l[h] = i[h]; if (p && (g(l, e, c), null != l.duration && (t = l.duration, delete l.duration)), f) { for (h in f = l.startAt = {}, i.startAt) f[h] = i.startAt[h];
                                    g(l.startAt, e, c) }
                                l.delay = d(c, e[c], e) + (l.delay || 0), c === s && r && (l.onComplete = function() { i.onComplete && i.onComplete.apply(i.onCompleteScope || this, arguments), r.apply(o || i.callbackScope || this, a || w) }), u[c] = new M(e[c], t, l) } return u }, M.staggerFrom = M.allFrom = function(e, t, i, n, r, a, o) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, M.staggerTo(e, t, i, n, r, a, o) }, M.staggerFromTo = M.allFromTo = function(e, t, i, n, r, a, o, s) { return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, M.staggerTo(e, t, n, r, a, o, s) }, M.delayedCall = function(e, t, i, n, r) { return new M(t, 0, { delay: e, onComplete: t, onCompleteParams: i, callbackScope: n, onReverseComplete: t, onReverseCompleteParams: i, immediateRender: !1, useFrames: r, overwrite: 0 }) }, M.set = function(e, t) { return new M(e, 0, t) }, M.isTweening = function(e) { return 0 < y.getTweensOf(e, !0).length }; var t = function e(t, i) { for (var n = [], r = 0, a = t._first; a;) a instanceof y ? n[r++] = a : (i && (n[r++] = a), r = (n = n.concat(e(a, i))).length), a = a._next; return n },
                            u = M.getAllTweens = function(e) { return t(n._rootTimeline, e).concat(t(n._rootFramesTimeline, e)) };
                        M.killAll = function(e, t, i, n) { null == t && (t = !0), null == i && (i = !0); var r, a, o, s = u(0 != n),
                                l = s.length,
                                c = t && i && n; for (o = 0; o < l; o++) a = s[o], (c || a instanceof h || (r = a.target === a.vars.onComplete) && i || t && !r) && (e ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1)) }, M.killChildTweensOf = function(e, t) { if (null != e) { var i, n, r, a, o, s = _.tweenLookup; if ("string" == typeof e && (e = y.selector(e) || e), x(e) && (e = m(e)), T(e))
                                    for (a = e.length; - 1 < --a;) M.killChildTweensOf(e[a], t);
                                else { for (r in i = [], s)
                                        for (n = s[r].target.parentNode; n;) n === e && (i = i.concat(s[r].tweens)), n = n.parentNode; for (o = i.length, a = 0; a < o; a++) t && i[a].totalTime(i[a].totalDuration()), i[a]._enabled(!1, !1) } } }; var r = function(e, t, i, n) { t = !1 !== t, i = !1 !== i; for (var r, a, o = u(n = !1 !== n), s = t && i && n, l = o.length; - 1 < --l;) a = o[l], (s || a instanceof h || (r = a.target === a.vars.onComplete) && i || t && !r) && a.paused(e) }; return M.pauseAll = function(e, t, i) { r(!0, e, t, i) }, M.resumeAll = function(e, t, i) { r(!1, e, t, i) }, M.globalTimeScale = function(e) { var t = n._rootTimeline,
                                i = y.ticker.time; return arguments.length ? (e = e || b, t._startTime = i - (i - t._startTime) * t._timeScale / e, t = n._rootFramesTimeline, i = y.ticker.frame, t._startTime = i - (i - t._startTime) * t._timeScale / e, t._timeScale = n._rootTimeline._timeScale = e, e) : t._timeScale }, e.progress = function(e, t) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this._time / this.duration() }, e.totalProgress = function(e, t) { return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration() }, e.time = function(e, t) { if (!arguments.length) return this._time;
                            this._dirty && this.totalDuration(); var i = this._duration,
                                n = this._cycle,
                                r = n * (i + this._repeatDelay); return i < e && (e = i), this.totalTime(this._yoyo && 1 & n ? i - e + r : this._repeat ? e + r : e, t) }, e.duration = function(e) { return arguments.length ? n.prototype.duration.call(this, e) : this._duration }, e.totalDuration = function(e) { return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration) }, e.repeat = function(e) { return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat }, e.repeatDelay = function(e) { return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay }, e.yoyo = function(e) { return arguments.length ? (this._yoyo = e, this) : this._yoyo }, M }, !0), at._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(u, d, f) { var m = function(e) { d.call(this, e); var t, i, n = this,
                                    r = n.vars; for (i in n._labels = {}, n.autoRemoveChildren = !!r.autoRemoveChildren, n.smoothChildTiming = !!r.smoothChildTiming, n._sortChildren = !0, n._onUpdate = r.onUpdate, r) t = r[i], p(t) && -1 !== t.join("").indexOf("{self}") && (r[i] = n._swapSelfInParams(t));
                                p(r.tweens) && n.add(r.tweens, 0, r.align, r.stagger) },
                            v = 1e-8,
                            e = f._internals,
                            t = m._internals = {},
                            g = e.isSelector,
                            p = e.isArray,
                            M = e.lazyTweens,
                            y = e.lazyRender,
                            o = at._gsDefine.globals,
                            b = function(e) { var t, i = {}; for (t in e) i[t] = e[t]; return i },
                            _ = function(e, t, i) { var n, r, a = e.cycle; for (n in a) r = a[n], e[n] = "function" == typeof r ? r(i, t[i], t) : r[i % r.length];
                                delete e.cycle },
                            a = t.pauseCallback = function() {},
                            c = function(e, t, i, n) { var r = "immediateRender"; return r in t || (t[r] = !(i && !1 === i[r] || n)), t },
                            x = function(e) { if ("function" == typeof e) return e; var f = "object" === rt(e) ? e : { each: e },
                                    m = f.ease,
                                    g = f.from || 0,
                                    v = f.base || 0,
                                    M = {},
                                    y = isNaN(g),
                                    b = f.axis,
                                    _ = { center: .5, end: 1 }[g] || 0; return function(e, t, i) { var n, r, a, o, s, l, c, h, u, d = (i || f).length,
                                        p = M[d]; if (!p) { if (!(u = "auto" === f.grid ? 0 : (f.grid || [1 / 0])[0])) { for (c = -1 / 0; c < (c = i[u++].getBoundingClientRect().left) && u < d;);
                                            u-- } for (p = M[d] = [], n = y ? Math.min(u, d) * _ - .5 : g % u, r = y ? d * _ / u - .5 : g / u | 0, h = 1 / (c = 0), l = 0; l < d; l++) a = l % u - n, o = r - (l / u | 0), p[l] = s = b ? Math.abs("y" === b ? o : a) : Math.sqrt(a * a + o * o), c < s && (c = s), s < h && (h = s);
                                        p.max = c - h, p.min = h, p.v = d = f.amount || f.each * (d < u ? d : b ? "y" === b ? d / u : u : Math.max(u, d / u)) || 0, p.b = d < 0 ? v - d : v } return d = (p[e] - p.min) / p.max, p.b + (m ? m.getRatio(d) : d) * p.v } },
                            i = m.prototype = new d; return m.version = "2.1.2", m.distribute = x, i.constructor = m, i.kill()._gc = i._forcingPlayhead = i._hasPause = !1, i.to = function(e, t, i, n) { var r = i.repeat && o.TweenMax || f; return t ? this.add(new r(e, t, i), n) : this.set(e, i, n) }, i.from = function(e, t, i, n) { return this.add((i.repeat && o.TweenMax || f).from(e, t, c(0, i)), n) }, i.fromTo = function(e, t, i, n, r) { var a = n.repeat && o.TweenMax || f; return n = c(0, n, i), t ? this.add(a.fromTo(e, t, i, n), r) : this.set(e, n, r) }, i.staggerTo = function(e, t, i, n, r, a, o, s) { var l, c, h = new m({ onComplete: a, onCompleteParams: o, callbackScope: s, smoothChildTiming: this.smoothChildTiming }),
                                u = x(i.stagger || n),
                                d = i.startAt,
                                p = i.cycle; for ("string" == typeof e && (e = f.selector(e) || e), g(e = e || []) && (e = function(e) { var t, i = [],
                                        n = e.length; for (t = 0; t !== n; i.push(e[t++])); return i }(e)), c = 0; c < e.length; c++) l = b(i), d && (l.startAt = b(d), d.cycle && _(l.startAt, e, c)), p && (_(l, e, c), null != l.duration && (t = l.duration, delete l.duration)), h.to(e[c], t, l, u(c, e[c], e)); return this.add(h, r) }, i.staggerFrom = function(e, t, i, n, r, a, o, s) { return i.runBackwards = !0, this.staggerTo(e, t, c(0, i), n, r, a, o, s) }, i.staggerFromTo = function(e, t, i, n, r, a, o, s, l) { return n.startAt = i, this.staggerTo(e, t, c(0, n, i), r, a, o, s, l) }, i.call = function(e, t, i, n) { return this.add(f.delayedCall(0, e, t, i), n) }, i.set = function(e, t, i) { return this.add(new f(e, 0, c(0, t, null, !0)), i) }, m.exportRoot = function(e, t) { null == (e = e || {}).smoothChildTiming && (e.smoothChildTiming = !0); var i, n, r, a, o = new m(e),
                                s = o._timeline; for (null == t && (t = !0), s._remove(o, !0), o._startTime = 0, o._rawPrevTime = o._time = o._totalTime = s._time, r = s._first; r;) a = r._next, t && r instanceof f && r.target === r.vars.onComplete || ((n = r._startTime - r._delay) < 0 && (i = 1), o.add(r, n)), r = a; return s.add(o, 0), i && o.totalDuration(), o }, i.add = function(e, t, i, n) { var r, a, o, s, l, c, h = this; if ("number" != typeof t && (t = h._parseTimeOrLabel(t, 0, !0, e)), !(e instanceof u)) { if (e instanceof Array || e && e.push && p(e)) { for (i = i || "normal", n = n || 0, r = t, a = e.length, o = 0; o < a; o++) p(s = e[o]) && (s = new m({ tweens: s })), h.add(s, r), "string" != typeof s && "function" != typeof s && ("sequence" === i ? r = s._startTime + s.totalDuration() / s._timeScale : "start" === i && (s._startTime -= s.delay())), r += n; return h._uncache(!0) } if ("string" == typeof e) return h.addLabel(e, t); if ("function" != typeof e) throw "Cannot add " + e + " into the timeline; it is not a tween, timeline, function, or string.";
                                e = f.delayedCall(0, e) } if (d.prototype.add.call(h, e, t), (e._time || !e._duration && e._initted) && (r = (h.rawTime() - e._startTime) * e._timeScale, (!e._duration || 1e-5 < Math.abs(Math.max(0, Math.min(e.totalDuration(), r))) - e._totalTime) && e.render(r, !1, !1)), (h._gc || h._time === h._duration) && !h._paused && h._duration < h.duration())
                                for (c = (l = h).rawTime() > e._startTime; l._timeline;) c && l._timeline.smoothChildTiming ? l.totalTime(l._totalTime, !0) : l._gc && l._enabled(!0, !1), l = l._timeline; return h }, i.remove = function(e) { if (e instanceof u) { this._remove(e, !1); var t = e._timeline = e.vars.useFrames ? u._rootFramesTimeline : u._rootTimeline; return e._startTime = (e._paused ? e._pauseTime : t._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this } if (e instanceof Array || e && e.push && p(e)) { for (var i = e.length; - 1 < --i;) this.remove(e[i]); return this } return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e) }, i._remove = function(e, t) { return d.prototype._remove.call(this, e, t), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this }, i.append = function(e, t) { return this.add(e, this._parseTimeOrLabel(null, t, !0, e)) }, i.insert = i.insertMultiple = function(e, t, i, n) { return this.add(e, t || 0, i, n) }, i.appendMultiple = function(e, t, i, n) { return this.add(e, this._parseTimeOrLabel(null, t, !0, e), i, n) }, i.addLabel = function(e, t) { return this._labels[e] = this._parseTimeOrLabel(t), this }, i.addPause = function(e, t, i, n) { var r = f.delayedCall(0, a, i, n || this); return r.vars.onComplete = r.vars.onReverseComplete = t, r.data = "isPause", this._hasPause = !0, this.add(r, e) }, i.removeLabel = function(e) { return delete this._labels[e], this }, i.getLabelTime = function(e) { return null != this._labels[e] ? this._labels[e] : -1 }, i._parseTimeOrLabel = function(e, t, i, n) { var r, a; if (n instanceof u && n.timeline === this) this.remove(n);
                            else if (n && (n instanceof Array || n.push && p(n)))
                                for (a = n.length; - 1 < --a;) n[a] instanceof u && n[a].timeline === this && this.remove(n[a]); if (r = "number" != typeof e || t ? 99999999999 < this.duration() ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof t) return this._parseTimeOrLabel(t, i && "number" == typeof e && null == this._labels[t] ? e - r : 0, i); if (t = t || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = r);
                            else { if (-1 === (a = e.indexOf("="))) return null == this._labels[e] ? i ? this._labels[e] = r + t : t : this._labels[e] + t;
                                t = parseInt(e.charAt(a - 1) + "1", 10) * Number(e.substr(a + 1)), e = 1 < a ? this._parseTimeOrLabel(e.substr(0, a - 1), 0, i) : r } return Number(e) + t }, i.seek = function(e, t) { return this.totalTime("number" == typeof e ? e : this._parseTimeOrLabel(e), !1 !== t) }, i.stop = function() { return this.paused(!0) }, i.gotoAndPlay = function(e, t) { return this.play(e, t) }, i.gotoAndStop = function(e, t) { return this.pause(e, t) }, i.render = function(e, t, i) { this._gc && this._enabled(!0, !1); var n, r, a, o, s, l, c, h, u = this,
                                d = u._time,
                                p = u._dirty ? u.totalDuration() : u._totalDuration,
                                f = u._startTime,
                                m = u._timeScale,
                                g = u._paused; if (d !== u._time && (e += u._time - d), p - v <= e && 0 <= e) u._totalTime = u._time = p, u._reversed || u._hasPausedChild() || (r = !0, o = "onComplete", s = !!u._timeline.autoRemoveChildren, 0 === u._duration && (e <= 0 && -v <= e || u._rawPrevTime < 0 || u._rawPrevTime === v) && u._rawPrevTime !== e && u._first && (s = !0, u._rawPrevTime > v && (o = "onReverseComplete"))), u._rawPrevTime = u._duration || !t || e || u._rawPrevTime === e ? e : v, e = p + 1e-4;
                            else if (e < v)
                                if (u._totalTime = u._time = 0, -v < e && (e = 0), (0 !== d || 0 === u._duration && u._rawPrevTime !== v && (0 < u._rawPrevTime || e < 0 && 0 <= u._rawPrevTime)) && (o = "onReverseComplete", r = u._reversed), e < 0) u._active = !1, u._timeline.autoRemoveChildren && u._reversed ? (s = r = !0, o = "onReverseComplete") : 0 <= u._rawPrevTime && u._first && (s = !0), u._rawPrevTime = e;
                                else { if (u._rawPrevTime = u._duration || !t || e || u._rawPrevTime === e ? e : v, 0 === e && r)
                                        for (n = u._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                                    e = 0, u._initted || (s = !0) }
                            else { if (u._hasPause && !u._forcingPlayhead && !t) { if (d <= e)
                                        for (n = u._first; n && n._startTime <= e && !l;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === u._rawPrevTime || (l = n), n = n._next;
                                    else
                                        for (n = u._last; n && n._startTime >= e && !l;) n._duration || "isPause" === n.data && 0 < n._rawPrevTime && (l = n), n = n._prev;
                                    l && (u._time = u._totalTime = e = l._startTime, h = u._startTime + e / u._timeScale) }
                                u._totalTime = u._time = u._rawPrevTime = e } if (u._time !== d && u._first || i || s || l) { if (u._initted || (u._initted = !0), u._active || !u._paused && u._time !== d && 0 < e && (u._active = !0), 0 === d && u.vars.onStart && (0 === u._time && u._duration || t || u._callback("onStart")), d <= (c = u._time))
                                    for (n = u._first; n && (a = n._next, c === u._time && (!u._paused || g));)(n._active || n._startTime <= c && !n._paused && !n._gc) && (l === n && (u.pause(), u._pauseTime = h), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i)), n = a;
                                else
                                    for (n = u._last; n && (a = n._prev, c === u._time && (!u._paused || g));) { if (n._active || n._startTime <= d && !n._paused && !n._gc) { if (l === n) { for (l = n._prev; l && l.endTime() > u._time;) l.render(l._reversed ? l.totalDuration() - (e - l._startTime) * l._timeScale : (e - l._startTime) * l._timeScale, t, i), l = l._prev;
                                                l = null, u.pause(), u._pauseTime = h }
                                            n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i) }
                                        n = a }
                                u._onUpdate && (t || (M.length && y(), u._callback("onUpdate"))), o && (u._gc || f !== u._startTime && m === u._timeScale || (0 === u._time || p >= u.totalDuration()) && (r && (M.length && y(), u._timeline.autoRemoveChildren && u._enabled(!1, !1), u._active = !1), !t && u.vars[o] && u._callback(o))) } }, i._hasPausedChild = function() { for (var e = this._first; e;) { if (e._paused || e instanceof m && e._hasPausedChild()) return !0;
                                e = e._next } return !1 }, i.getChildren = function(e, t, i, n) { n = n || -9999999999; for (var r = [], a = this._first, o = 0; a;) a._startTime < n || (a instanceof f ? !1 !== t && (r[o++] = a) : (!1 !== i && (r[o++] = a), !1 !== e && (o = (r = r.concat(a.getChildren(!0, t, i))).length))), a = a._next; return r }, i.getTweensOf = function(e, t) { var i, n, r = this._gc,
                                a = [],
                                o = 0; for (r && this._enabled(!0, !0), n = (i = f.getTweensOf(e)).length; - 1 < --n;)(i[n].timeline === this || t && this._contains(i[n])) && (a[o++] = i[n]); return r && this._enabled(!1, !0), a }, i.recent = function() { return this._recent }, i._contains = function(e) { for (var t = e.timeline; t;) { if (t === this) return !0;
                                t = t.timeline } return !1 }, i.shiftChildren = function(e, t, i) { i = i || 0; for (var n, r = this._first, a = this._labels; r;) r._startTime >= i && (r._startTime += e), r = r._next; if (t)
                                for (n in a) a[n] >= i && (a[n] += e); return this._uncache(!0) }, i._kill = function(e, t) { if (!e && !t) return this._enabled(!1, !1); for (var i = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), n = i.length, r = !1; - 1 < --n;) i[n]._kill(e, t) && (r = !0); return r }, i.clear = function(e) { var t = this.getChildren(!1, !0, !0),
                                i = t.length; for (this._time = this._totalTime = 0; - 1 < --i;) t[i]._enabled(!1, !1); return !1 !== e && (this._labels = {}), this._uncache(!0) }, i.invalidate = function() { for (var e = this._first; e;) e.invalidate(), e = e._next; return u.prototype.invalidate.call(this) }, i._enabled = function(e, t) { if (e === this._gc)
                                for (var i = this._first; i;) i._enabled(e, !0), i = i._next; return d.prototype._enabled.call(this, e, t) }, i.totalTime = function(e, t, i) { this._forcingPlayhead = !0; var n = u.prototype.totalTime.apply(this, arguments); return this._forcingPlayhead = !1, n }, i.duration = function(e) { return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration) }, i.totalDuration = function(e) { if (arguments.length) return e && this.totalDuration() ? this.timeScale(this._totalDuration / e) : this; if (this._dirty) { for (var t, i, n = 0, r = this, a = r._last, o = 999999999999; a;) t = a._prev, a._dirty && a.totalDuration(), a._startTime > o && r._sortChildren && !a._paused && !r._calculatingDuration ? (r._calculatingDuration = 1, r.add(a, a._startTime - a._delay), r._calculatingDuration = 0) : o = a._startTime, a._startTime < 0 && !a._paused && (n -= a._startTime, r._timeline.smoothChildTiming && (r._startTime += a._startTime / r._timeScale, r._time -= a._startTime, r._totalTime -= a._startTime, r._rawPrevTime -= a._startTime), r.shiftChildren(-a._startTime, !1, -9999999999), o = 0), n < (i = a._startTime + a._totalDuration / a._timeScale) && (n = i), a = t;
                                r._duration = r._totalDuration = n, r._dirty = !1 } return this._totalDuration }, i.paused = function(e) { if (!1 === e && this._paused)
                                for (var t = this._first; t;) t._startTime === this._time && "isPause" === t.data && (t._rawPrevTime = 0), t = t._next; return u.prototype.paused.apply(this, arguments) }, i.usesFrames = function() { for (var e = this._timeline; e._timeline;) e = e._timeline; return e === u._rootFramesTimeline }, i.rawTime = function(e) { return e && (this._paused || this._repeat && 0 < this.time() && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(e) - this._startTime) * this._timeScale }, m }, !0), at._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, s, e) { var i = function(e) { t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !!this.vars.yoyo, this._dirty = !0 },
                            A = 1e-8,
                            n = s._internals,
                            C = n.lazyTweens,
                            L = n.lazyRender,
                            l = at._gsDefine.globals,
                            c = new e(null, null, 1, 0),
                            r = i.prototype = new t; return r.constructor = i, r.kill()._gc = !1, i.version = "2.1.2", r.invalidate = function() { return this._yoyo = !!this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this) }, r.addCallback = function(e, t, i, n) { return this.add(s.delayedCall(0, e, i, n), t) }, r.removeCallback = function(e, t) { if (e)
                                if (null == t) this._kill(null, e);
                                else
                                    for (var i = this.getTweensOf(e, !1), n = i.length, r = this._parseTimeOrLabel(t); - 1 < --n;) i[n]._startTime === r && i[n]._enabled(!1, !1);
                            return this }, r.removePause = function(e) { return this.removeCallback(t._internals.pauseCallback, e) }, r.tweenTo = function(e, t) { t = t || {}; var i, n, r, a = { ease: c, useFrames: this.usesFrames(), immediateRender: !1, lazy: !1 },
                                o = t.repeat && l.TweenMax || s; for (n in t) a[n] = t[n]; return a.time = this._parseTimeOrLabel(e), i = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, r = new o(this, i, a), a.onStart = function() { r.target.paused(!0), r.vars.time === r.target.time() || i !== r.duration() || r.isFromTo || r.duration(Math.abs(r.vars.time - r.target.time()) / r.target._timeScale).render(r.time(), !0, !0), t.onStart && t.onStart.apply(t.onStartScope || t.callbackScope || r, t.onStartParams || []) }, r }, r.tweenFromTo = function(e, t, i) { i = i || {}, e = this._parseTimeOrLabel(e), i.startAt = { onComplete: this.seek, onCompleteParams: [e], callbackScope: this }, i.immediateRender = !1 !== i.immediateRender; var n = this.tweenTo(t, i); return n.isFromTo = 1, n.duration(Math.abs(n.vars.time - e) / this._timeScale || .001) }, r.render = function(e, t, i) { this._gc && this._enabled(!0, !1); var n, r, a, o, s, l, c, h, u, d = this,
                                p = d._time,
                                f = d._dirty ? d.totalDuration() : d._totalDuration,
                                m = d._duration,
                                g = d._totalTime,
                                v = d._startTime,
                                M = d._timeScale,
                                y = d._rawPrevTime,
                                b = d._paused,
                                _ = d._cycle; if (p !== d._time && (e += d._time - p), f - A <= e && 0 <= e) d._locked || (d._totalTime = f, d._cycle = d._repeat), d._reversed || d._hasPausedChild() || (r = !0, o = "onComplete", s = !!d._timeline.autoRemoveChildren, 0 === d._duration && (e <= 0 && -A <= e || y < 0 || y === A) && y !== e && d._first && (s = !0, A < y && (o = "onReverseComplete"))), d._rawPrevTime = d._duration || !t || e || d._rawPrevTime === e ? e : A, d._yoyo && 1 & d._cycle ? d._time = e = 0 : e = (d._time = m) + 1e-4;
                            else if (e < A)
                                if (d._locked || (d._totalTime = d._cycle = 0), d._time = 0, -A < e && (e = 0), (0 !== p || 0 === m && y !== A && (0 < y || e < 0 && 0 <= y) && !d._locked) && (o = "onReverseComplete", r = d._reversed), e < 0) d._active = !1, d._timeline.autoRemoveChildren && d._reversed ? (s = r = !0, o = "onReverseComplete") : 0 <= y && d._first && (s = !0), d._rawPrevTime = e;
                                else { if (d._rawPrevTime = m || !t || e || d._rawPrevTime === e ? e : A, 0 === e && r)
                                        for (n = d._first; n && 0 === n._startTime;) n._duration || (r = !1), n = n._next;
                                    e = 0, d._initted || (s = !0) }
                            else if (0 === m && y < 0 && (s = !0), d._time = d._rawPrevTime = e, d._locked || (d._totalTime = e, 0 !== d._repeat && (l = m + d._repeatDelay, d._cycle = d._totalTime / l >> 0, d._cycle && d._cycle === d._totalTime / l && g <= e && d._cycle--, d._time = d._totalTime - d._cycle * l, d._yoyo && 1 & d._cycle && (d._time = m - d._time), d._time > m ? e = (d._time = m) + 1e-4 : d._time < 0 ? d._time = e = 0 : e = d._time)), d._hasPause && !d._forcingPlayhead && !t) { if (p <= (e = d._time) || d._repeat && _ !== d._cycle)
                                    for (n = d._first; n && n._startTime <= e && !c;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === d._rawPrevTime || (c = n), n = n._next;
                                else
                                    for (n = d._last; n && n._startTime >= e && !c;) n._duration || "isPause" === n.data && 0 < n._rawPrevTime && (c = n), n = n._prev;
                                c && (u = d._startTime + c._startTime / d._timeScale, c._startTime < m && (d._time = d._rawPrevTime = e = c._startTime, d._totalTime = e + d._cycle * (d._totalDuration + d._repeatDelay))) } if (d._cycle !== _ && !d._locked) { var x = d._yoyo && 0 != (1 & _),
                                    T = x === (d._yoyo && 0 != (1 & d._cycle)),
                                    w = d._totalTime,
                                    S = d._cycle,
                                    E = d._rawPrevTime,
                                    P = d._time; if (d._totalTime = _ * m, d._cycle < _ ? x = !x : d._totalTime += m, d._time = p, d._rawPrevTime = 0 === m ? y - 1e-4 : y, d._cycle = _, d._locked = !0, p = x ? 0 : m, d.render(p, t, 0 === m), t || d._gc || d.vars.onRepeat && (d._cycle = S, d._locked = !1, d._callback("onRepeat")), p !== d._time) return; if (T && (d._cycle = _, d._locked = !0, p = x ? m + 1e-4 : -1e-4, d.render(p, !0, !1)), d._locked = !1, d._paused && !b) return;
                                d._time = P, d._totalTime = w, d._cycle = S, d._rawPrevTime = E } if (d._time !== p && d._first || i || s || c) { if (d._initted || (d._initted = !0), d._active || !d._paused && d._totalTime !== g && 0 < e && (d._active = !0), 0 === g && d.vars.onStart && (0 === d._totalTime && d._totalDuration || t || d._callback("onStart")), p <= (h = d._time))
                                    for (n = d._first; n && (a = n._next, h === d._time && (!d._paused || b));)(n._active || n._startTime <= d._time && !n._paused && !n._gc) && (c === n && (d.pause(), d._pauseTime = u), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i)), n = a;
                                else
                                    for (n = d._last; n && (a = n._prev, h === d._time && (!d._paused || b));) { if (n._active || n._startTime <= p && !n._paused && !n._gc) { if (c === n) { for (c = n._prev; c && c.endTime() > d._time;) c.render(c._reversed ? c.totalDuration() - (e - c._startTime) * c._timeScale : (e - c._startTime) * c._timeScale, t, i), c = c._prev;
                                                c = null, d.pause(), d._pauseTime = u }
                                            n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i) }
                                        n = a }
                                d._onUpdate && (t || (C.length && L(), d._callback("onUpdate"))), o && (d._locked || d._gc || v !== d._startTime && M === d._timeScale || (0 === d._time || f >= d.totalDuration()) && (r && (C.length && L(), d._timeline.autoRemoveChildren && d._enabled(!1, !1), d._active = !1), !t && d.vars[o] && d._callback(o))) } else g !== d._totalTime && d._onUpdate && (t || d._callback("onUpdate")) }, r.getActive = function(e, t, i) { var n, r, a = [],
                                o = this.getChildren(e || null == e, t || null == e, !!i),
                                s = 0,
                                l = o.length; for (n = 0; n < l; n++)(r = o[n]).isActive() && (a[s++] = r); return a }, r.getLabelAfter = function(e) { e || 0 !== e && (e = this._time); var t, i = this.getLabelsArray(),
                                n = i.length; for (t = 0; t < n; t++)
                                if (i[t].time > e) return i[t].name;
                            return null }, r.getLabelBefore = function(e) { null == e && (e = this._time); for (var t = this.getLabelsArray(), i = t.length; - 1 < --i;)
                                if (t[i].time < e) return t[i].name;
                            return null }, r.getLabelsArray = function() { var e, t = [],
                                i = 0; for (e in this._labels) t[i++] = { time: this._labels[e], name: e }; return t.sort(function(e, t) { return e.time - t.time }), t }, r.invalidate = function() { return this._locked = !1, t.prototype.invalidate.call(this) }, r.progress = function(e, t) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this._time / this.duration() || 0 }, r.totalProgress = function(e, t) { return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration() || 0 }, r.totalDuration = function(e) { return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration) }, r.time = function(e, t) { if (!arguments.length) return this._time;
                            this._dirty && this.totalDuration(); var i = this._duration,
                                n = this._cycle,
                                r = n * (i + this._repeatDelay); return i < e && (e = i), this.totalTime(this._yoyo && 1 & n ? i - e + r : this._repeat ? e + r : e, t) }, r.repeat = function(e) { return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat }, r.repeatDelay = function(e) { return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay }, r.yoyo = function(e) { return arguments.length ? (this._yoyo = e, this) : this._yoyo }, r.currentLabel = function(e) { return arguments.length ? this.seek(e, !0) : this.getLabelBefore(this._time + A) }, i }, !0), T = 180 / Math.PI, _ = [], x = [], w = [], v = {}, i = at._gsDefine.globals, M = function(e, t, i, n) { i === n && (i = n - (n - t) / 1e6), e === t && (t = e + (i - e) / 1e6), this.a = e, this.b = t, this.c = i, this.d = n, this.da = n - e, this.ca = i - e, this.ba = t - e }, S = function(e, t, i, n) { var r = { a: e },
                            a = {},
                            o = {},
                            s = { c: n },
                            l = (e + t) / 2,
                            c = (t + i) / 2,
                            h = (i + n) / 2,
                            u = (l + c) / 2,
                            d = (c + h) / 2,
                            p = (d - u) / 8; return r.b = l + (e - l) / 4, a.b = u + p, r.c = a.a = (r.b + a.b) / 2, a.c = o.a = (u + d) / 2, o.b = d - p, s.b = h + (n - h) / 4, o.c = s.a = (o.b + s.b) / 2, [r, a, o, s] }, y = function(e, t, i, n, r) { var a, o, s, l, c, h, u, d, p, f, m, g, v, M = e.length - 1,
                            y = 0,
                            b = e[0].a; for (a = 0; a < M; a++) o = (c = e[y]).a, s = c.d, l = e[y + 1].d, d = r ? (m = _[a], v = ((g = x[a]) + m) * t * .25 / (n ? .5 : w[a] || .5), s - ((h = s - (s - o) * (n ? .5 * t : 0 !== m ? v / m : 0)) + (((u = s + (l - s) * (n ? .5 * t : 0 !== g ? v / g : 0)) - h) * (3 * m / (m + g) + .5) / 4 || 0))) : s - ((h = s - (s - o) * t * .5) + (u = s + (l - s) * t * .5)) / 2, h += d, u += d, c.c = p = h, c.b = 0 !== a ? b : b = c.a + .6 * (c.c - c.a), c.da = s - o, c.ca = p - o, c.ba = b - o, i ? (f = S(o, b, p, s), e.splice(y, 1, f[0], f[1], f[2], f[3]), y += 4) : y++, b = u;
                        (c = e[y]).b = b, c.c = b + .4 * (c.d - b), c.da = c.d - c.a, c.ca = c.c - c.a, c.ba = b - c.a, i && (f = S(c.a, b, c.c, c.d), e.splice(y, 1, f[0], f[1], f[2], f[3])) }, b = function(e, t, i, n) { var r, a, o, s, l, c, h = []; if (n)
                            for (a = (e = [n].concat(e)).length; - 1 < --a;) "string" == typeof(c = e[a][t]) && "=" === c.charAt(1) && (e[a][t] = n[t] + Number(c.charAt(0) + c.substr(2))); if ((r = e.length - 2) < 0) return h[0] = new M(e[0][t], 0, 0, e[0][t]), h; for (a = 0; a < r; a++) o = e[a][t], s = e[a + 1][t], h[a] = new M(o, 0, 0, s), i && (l = e[a + 2][t], _[a] = (_[a] || 0) + (s - o) * (s - o), x[a] = (x[a] || 0) + (l - s) * (l - s)); return h[a] = new M(e[a][t], 0, 0, e[a + 1][t]), h }, p = function(e, t, i, n, r, a) { var o, s, l, c, h, u, d, p, f = {},
                            m = [],
                            g = a || e[0]; for (s in r = "string" == typeof r ? "," + r + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == t && (t = 1), e[0]) m.push(s); if (1 < e.length) { for (p = e[e.length - 1], d = !0, o = m.length; - 1 < --o;)
                                if (s = m[o], .05 < Math.abs(g[s] - p[s])) { d = !1; break }
                            d && (e = e.concat(), a && e.unshift(a), e.push(e[1]), a = e[e.length - 3]) } for (_.length = x.length = w.length = 0, o = m.length; - 1 < --o;) s = m[o], v[s] = -1 !== r.indexOf("," + s + ","), f[s] = b(e, s, v[s], a); for (o = _.length; - 1 < --o;) _[o] = Math.sqrt(_[o]), x[o] = Math.sqrt(x[o]); if (!n) { for (o = m.length; - 1 < --o;)
                                if (v[s])
                                    for (u = (l = f[m[o]]).length - 1, c = 0; c < u; c++) h = l[c + 1].da / x[c] + l[c].da / _[c] || 0, w[c] = (w[c] || 0) + h * h;
                            for (o = w.length; - 1 < --o;) w[o] = Math.sqrt(w[o]) } for (o = m.length, c = i ? 4 : 1; - 1 < --o;) l = f[s = m[o]], y(l, t, i, n, v[s]), d && (l.splice(0, c), l.splice(l.length - c, c)); return f }, f = function(e, t, i) { for (var n, r, a, o, s, l, c, h, u, d, p, f = 1 / i, m = e.length; - 1 < --m;)
                            for (a = (d = e[m]).a, o = d.d - a, s = d.c - a, l = d.b - a, n = r = 0, h = 1; h <= i; h++) n = r - (r = ((c = f * h) * c * o + 3 * (u = 1 - c) * (c * s + u * l)) * c), t[p = m * i + h - 1] = (t[p] || 0) + n * n }, g = at._gsDefine.plugin({ propName: "bezier", priority: -1, version: "1.3.8", API: 2, global: !0, init: function(e, t, i) { this._target = e, t instanceof Array && (t = { values: t }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == t.timeResolution ? 6 : parseInt(t.timeResolution, 10); var n, r, a, o, s, l = t.values || [],
                                c = {},
                                h = l[0],
                                u = t.autoRotate || i.vars.orientToBezier; for (n in this._autoRotate = u ? u instanceof Array ? u : [
                                    ["x", "y", "rotation", !0 === u ? 0 : Number(u) || 0]
                                ] : null, h) this._props.push(n); for (a = this._props.length; - 1 < --a;) n = this._props[a], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof e[n], c[n] = r ? e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(e[n]), s || c[n] !== l[0][n] && (s = c); if (this._beziers = "cubic" !== t.type && "quadratic" !== t.type && "soft" !== t.type ? p(l, isNaN(t.curviness) ? 1 : t.curviness, !1, "thruBasic" === t.type, t.correlate, s) : function(e, t, i) { var n, r, a, o, s, l, c, h, u, d, p, f = {},
                                        m = "cubic" === (t = t || "soft") ? 3 : 2,
                                        g = "soft" === t,
                                        v = []; if (g && i && (e = [i].concat(e)), null == e || e.length < m + 1) throw "invalid Bezier data"; for (u in e[0]) v.push(u); for (l = v.length; - 1 < --l;) { for (f[u = v[l]] = s = [], d = 0, h = e.length, c = 0; c < h; c++) n = null == i ? e[c][u] : "string" == typeof(p = e[c][u]) && "=" === p.charAt(1) ? i[u] + Number(p.charAt(0) + p.substr(2)) : Number(p), g && 1 < c && c < h - 1 && (s[d++] = (n + s[d - 2]) / 2), s[d++] = n; for (h = d - m + 1, c = d = 0; c < h; c += m) n = s[c], r = s[c + 1], a = s[c + 2], o = 2 === m ? 0 : s[c + 3], s[d++] = p = 3 === m ? new M(n, r, a, o) : new M(n, (2 * r + n) / 3, (2 * r + a) / 3, a);
                                        s.length = d } return f }(l, t.type, c), this._segCount = this._beziers[n].length, this._timeRes) { var d = function(e, t) { var i, n, r, a, o = [],
                                        s = [],
                                        l = 0,
                                        c = 0,
                                        h = (t = t >> 0 || 6) - 1,
                                        u = [],
                                        d = []; for (i in e) f(e[i], o, t); for (r = o.length, n = 0; n < r; n++) l += Math.sqrt(o[n]), d[a = n % t] = l, a === h && (c += l, u[a = n / t >> 0] = d, s[a] = c, l = 0, d = []); return { length: c, lengths: s, segments: u } }(this._beziers, this._timeRes);
                                this._length = d.length, this._lengths = d.lengths, this._segments = d.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length } if (u = this._autoRotate)
                                for (this._initialRotations = [], u[0] instanceof Array || (this._autoRotate = u = [u]), a = u.length; - 1 < --a;) { for (o = 0; o < 3; o++) n = u[a][o], this._func[n] = "function" == typeof e[n] && e[n.indexOf("set") || "function" != typeof e["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                                    n = u[a][2], this._initialRotations[a] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n) }
                            return this._startRatio = i.vars.runBackwards ? 1 : 0, !0 }, set: function(e) { var t, i, n, r, a, o, s, l, c, h, u = this._segCount,
                                d = this._func,
                                p = this._target,
                                f = e !== this._startRatio; if (this._timeRes) { if (c = this._lengths, h = this._curSeg, e *= this._length, n = this._li, e > this._l2 && n < u - 1) { for (l = u - 1; n < l && (this._l2 = c[++n]) <= e;);
                                    this._l1 = c[n - 1], this._li = n, this._curSeg = h = this._segments[n], this._s2 = h[this._s1 = this._si = 0] } else if (e < this._l1 && 0 < n) { for (; 0 < n && (this._l1 = c[--n]) >= e;);
                                    0 === n && e < this._l1 ? this._l1 = 0 : n++, this._l2 = c[n], this._li = n, this._curSeg = h = this._segments[n], this._s1 = h[(this._si = h.length - 1) - 1] || 0, this._s2 = h[this._si] } if (t = n, e -= this._l1, n = this._si, e > this._s2 && n < h.length - 1) { for (l = h.length - 1; n < l && (this._s2 = h[++n]) <= e;);
                                    this._s1 = h[n - 1], this._si = n } else if (e < this._s1 && 0 < n) { for (; 0 < n && (this._s1 = h[--n]) >= e;);
                                    0 === n && e < this._s1 ? this._s1 = 0 : n++, this._s2 = h[n], this._si = n }
                                o = (n + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0 } else o = (e - (t = e < 0 ? 0 : 1 <= e ? u - 1 : u * e >> 0) * (1 / u)) * u; for (i = 1 - o, n = this._props.length; - 1 < --n;) r = this._props[n], s = (o * o * (a = this._beziers[r][t]).da + 3 * i * (o * a.ca + i * a.ba)) * o + a.a, this._mod[r] && (s = this._mod[r](s, p)), d[r] ? p[r](s) : p[r] = s; if (this._autoRotate) { var m, g, v, M, y, b, _, x = this._autoRotate; for (n = x.length; - 1 < --n;) r = x[n][2], b = x[n][3] || 0, _ = !0 === x[n][4] ? 1 : T, a = this._beziers[x[n][0]], m = this._beziers[x[n][1]], a && m && (a = a[t], m = m[t], g = a.a + (a.b - a.a) * o, g += ((M = a.b + (a.c - a.b) * o) - g) * o, M += (a.c + (a.d - a.c) * o - M) * o, v = m.a + (m.b - m.a) * o, v += ((y = m.b + (m.c - m.b) * o) - v) * o, y += (m.c + (m.d - m.c) * o - y) * o, s = f ? Math.atan2(y - v, M - g) * _ + b : this._initialRotations[n], this._mod[r] && (s = this._mod[r](s, p)), d[r] ? p[r](s) : p[r] = s) } } }), e = g.prototype, g.bezierThrough = p, g.cubicToQuadratic = S, g._autoCSS = !0, g.quadraticToCubic = function(e, t, i) { return new M(e, (2 * t + e) / 3, (2 * t + i) / 3, i) }, g._cssRegister = function() { var e = i.CSSPlugin; if (e) { var t = e._internals,
                                p = t._parseToProxy,
                                f = t._setPluginRatio,
                                m = t.CSSPropTween;
                            t._registerComplexSpecialProp("bezier", { parser: function(e, t, i, n, r, a) { t instanceof Array && (t = { values: t }), a = new g; var o, s, l, c = t.values,
                                        h = c.length - 1,
                                        u = [],
                                        d = {}; if (h < 0) return r; for (o = 0; o <= h; o++) l = p(e, c[o], n, r, a, h !== o), u[o] = l.end; for (s in t) d[s] = t[s]; return d.values = u, (r = new m(e, "bezier", 0, 0, l.pt, 2)).data = l, r.plugin = a, r.setRatio = f, 0 === d.autoRotate && (d.autoRotate = !0), !d.autoRotate || d.autoRotate instanceof Array || (o = !0 === d.autoRotate ? 0 : Number(d.autoRotate), d.autoRotate = null != l.end.left ? [
                                        ["left", "top", "rotation", o, !1]
                                    ] : null != l.end.x && [
                                        ["x", "y", "rotation", o, !1]
                                    ]), d.autoRotate && (n._transform || n._enableTransforms(!1), l.autoRotate = n._target._gsTransform, l.proxy.rotation = l.autoRotate.rotation || 0, n._overwriteProps.push("rotation")), a._onInitTween(l.proxy, d, n._tween), r } }) } }, e._mod = function(e) { for (var t, i = this._overwriteProps, n = i.length; - 1 < --n;)(t = e[i[n]]) && "function" == typeof t && (this._mod[i[n]] = t) }, e._kill = function(e) { var t, i, n = this._props; for (t in this._beziers)
                            if (t in e)
                                for (delete this._beziers[t], delete this._func[t], i = n.length; - 1 < --i;) n[i] === t && n.splice(i, 1);
                        if (n = this._autoRotate)
                            for (i = n.length; - 1 < --i;) e[n[i][2]] && n.splice(i, 1); return this._super._kill.call(this, e) }, at._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(a, z) { var f, w, S, m, k = function e() { a.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = e.prototype.setRatio },
                            c = at._gsDefine.globals,
                            g = {},
                            e = k.prototype = new a("css");
                        (e.constructor = k).version = "2.1.0", k.API = 2, k.defaultTransformPerspective = 0, k.defaultSkewType = "compensated", k.defaultSmoothOrigin = !0, k.suffixMap = { top: e = "px", right: e, bottom: e, left: e, width: e, height: e, fontSize: e, padding: e, margin: e, perspective: e, lineHeight: "" }; var P, v, M, U, y, E, A, C, t, i, L = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                            R = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                            b = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                            h = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                            H = /(?:\d|\-|\+|=|#|\.)*/g,
                            O = /opacity *= *([^)]*)/i,
                            _ = /opacity:([^;]*)/i,
                            o = /alpha\(opacity *=.+?\)/i,
                            x = /^(rgb|hsl)/,
                            s = /([A-Z])/g,
                            l = /-([a-z])/gi,
                            T = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                            u = function(e, t) { return t.toUpperCase() },
                            p = /(?:Left|Right|Width)/i,
                            d = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                            G = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                            D = /,(?=[^\)]*(?:\(|$))/gi,
                            I = /[\s,\(]/i,
                            V = Math.PI / 180,
                            j = 180 / Math.PI,
                            B = {},
                            n = { style: {} },
                            N = at.document || { createElement: function() { return n } },
                            F = function(e, t) { return t && N.createElementNS ? N.createElementNS(t, e) : N.createElement(e) },
                            W = F("div"),
                            X = F("img"),
                            r = k._internals = { _specialProps: g },
                            Y = (at.navigator || {}).userAgent || "",
                            q = (t = Y.indexOf("Android"), i = F("a"), M = -1 !== Y.indexOf("Safari") && -1 === Y.indexOf("Chrome") && (-1 === t || 3 < parseFloat(Y.substr(t + 8, 2))), y = M && parseFloat(Y.substr(Y.indexOf("Version/") + 8, 2)) < 6, U = -1 !== Y.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(Y) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(Y)) && (E = parseFloat(RegExp.$1)), !!i && (i.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(i.style.opacity))),
                            Z = function(e) { return O.test("string" == typeof e ? e : (e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1 },
                            J = function(e) { at.console && console.log(e) },
                            K = "",
                            Q = "",
                            $ = function(e, t) { var i, n, r = (t = t || W).style; if (void 0 !== r[e]) return e; for (e = e.charAt(0).toUpperCase() + e.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; - 1 < --n && void 0 === r[i[n] + e];); return 0 <= n ? (K = "-" + (Q = 3 === n ? "ms" : i[n]).toLowerCase() + "-", Q + e) : null },
                            ee = "undefined" != typeof window ? window : N.defaultView || { getComputedStyle: function() {} },
                            te = function(e) { return ee.getComputedStyle(e) },
                            ie = k.getStyle = function(e, t, i, n, r) { var a; return q || "opacity" !== t ? (!n && e.style[t] ? a = e.style[t] : (i = i || te(e)) ? a = i[t] || i.getPropertyValue(t) || i.getPropertyValue(t.replace(s, "-$1").toLowerCase()) : e.currentStyle && (a = e.currentStyle[t]), null == r || a && "none" !== a && "auto" !== a && "auto auto" !== a ? a : r) : Z(e) },
                            ne = r.convertToPixels = function(e, t, i, n, r) { if ("px" === n || !n && "lineHeight" !== t) return i; if ("auto" === n || !i) return 0; var a, o, s, l = p.test(t),
                                    c = e,
                                    h = W.style,
                                    u = i < 0,
                                    d = 1 === i; if (u && (i = -i), d && (i *= 100), "lineHeight" !== t || n)
                                    if ("%" === n && -1 !== t.indexOf("border")) a = i / 100 * (l ? e.clientWidth : e.clientHeight);
                                    else { if (h.cssText = "border:0 solid red;position:" + ie(e, "position") + ";line-height:0;", "%" !== n && c.appendChild && "v" !== n.charAt(0) && "rem" !== n) h[l ? "borderLeftWidth" : "borderTopWidth"] = i + n;
                                        else { if (c = e.parentNode || N.body, -1 !== ie(c, "display").indexOf("flex") && (h.position = "absolute"), o = c._gsCache, s = z.ticker.frame, o && l && o.time === s) return o.width * i / 100;
                                            h[l ? "width" : "height"] = i + n }
                                        c.appendChild(W), a = parseFloat(W[l ? "offsetWidth" : "offsetHeight"]), c.removeChild(W), l && "%" === n && !1 !== k.cacheWidths && ((o = c._gsCache = c._gsCache || {}).time = s, o.width = a / i * 100), 0 !== a || r || (a = ne(e, t, i, n, !0)) }
                                else o = te(e).lineHeight, e.style.lineHeight = i, a = parseFloat(te(e).lineHeight), e.style.lineHeight = o; return d && (a /= 100), u ? -a : a },
                            re = r.calculateOffset = function(e, t, i) { if ("absolute" !== ie(e, "position", i)) return 0; var n = "left" === t ? "Left" : "Top",
                                    r = ie(e, "margin" + n, i); return e["offset" + n] - (ne(e, t, parseFloat(r), r.replace(H, "")) || 0) },
                            ae = function(e, t) { var i, n, r, a = {}; if (t = t || te(e))
                                    if (i = t.length)
                                        for (; - 1 < --i;) - 1 !== (r = t[i]).indexOf("-transform") && Ie !== r || (a[r.replace(l, u)] = t.getPropertyValue(r));
                                    else
                                        for (i in t) - 1 !== i.indexOf("Transform") && De !== i || (a[i] = t[i]);
                                else if (t = e.currentStyle || e.style)
                                    for (i in t) "string" == typeof i && void 0 === a[i] && (a[i.replace(l, u)] = t[i]); return q || (a.opacity = Z(e)), n = Ze(e, t, !1), a.rotation = n.rotation, a.skewX = n.skewX, a.scaleX = n.scaleX, a.scaleY = n.scaleY, a.x = n.x, a.y = n.y, Ne && (a.z = n.z, a.rotationX = n.rotationX, a.rotationY = n.rotationY, a.scaleZ = n.scaleZ), a.filters && delete a.filters, a },
                            oe = function(e, t, i, n, r) { var a, o, s, l = {},
                                    c = e.style; for (o in i) "cssText" !== o && "length" !== o && isNaN(o) && (t[o] !== (a = i[o]) || r && r[o]) && -1 === o.indexOf("Origin") && ("number" != typeof a && "string" != typeof a || (l[o] = "auto" !== a || "left" !== o && "top" !== o ? "" !== a && "auto" !== a && "none" !== a || "string" != typeof t[o] || "" === t[o].replace(h, "") ? a : 0 : re(e, o), void 0 !== c[o] && (s = new _e(c, o, c[o], s)))); if (n)
                                    for (o in n) "className" !== o && (l[o] = n[o]); return { difs: l, firstMPT: s } },
                            se = { width: ["Left", "Right"], height: ["Top", "Bottom"] },
                            le = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                            ce = function(e, t, i) { if ("svg" === (e.nodeName + "").toLowerCase()) return (i || te(e))[t] || 0; if (e.getCTM && Xe(e)) return e.getBBox()[t] || 0; var n = parseFloat("width" === t ? e.offsetWidth : e.offsetHeight),
                                    r = se[t],
                                    a = r.length; for (i = i || te(e); - 1 < --a;) n -= parseFloat(ie(e, "padding" + r[a], i, !0)) || 0, n -= parseFloat(ie(e, "border" + r[a] + "Width", i, !0)) || 0; return n },
                            he = function e(t, i) { if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                                null != t && "" !== t || (t = "0 0"); var n, r = t.split(" "),
                                    a = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : r[0],
                                    o = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : r[1]; if (3 < r.length && !i) { for (r = t.split(", ").join(",").split(","), t = [], n = 0; n < r.length; n++) t.push(e(r[n])); return t.join(",") } return null == o ? o = "center" === a ? "50%" : "0" : "center" === o && (o = "50%"), ("center" === a || isNaN(parseFloat(a)) && -1 === (a + "").indexOf("=")) && (a = "50%"), t = a + " " + o + (2 < r.length ? " " + r[2] : ""), i && (i.oxp = -1 !== a.indexOf("%"), i.oyp = -1 !== o.indexOf("%"), i.oxr = "=" === a.charAt(1), i.oyr = "=" === o.charAt(1), i.ox = parseFloat(a.replace(h, "")), i.oy = parseFloat(o.replace(h, "")), i.v = t), i || t },
                            ue = function(e, t) { return "function" == typeof e && (e = e(C, A)), "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t) || 0 },
                            de = function(e, t) { "function" == typeof e && (e = e(C, A)); var i = "string" == typeof e && "=" === e.charAt(1); return "string" == typeof e && "v" === e.charAt(e.length - 2) && (e = (i ? e.substr(0, 2) : 0) + window["inner" + ("vh" === e.substr(-2) ? "Height" : "Width")] * (parseFloat(i ? e.substr(2) : e) / 100)), null == e ? t : i ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) + t : parseFloat(e) || 0 },
                            pe = function(e, t, i, n) { var r, a, o, s, l; return "function" == typeof e && (e = e(C, A)), (s = null == e ? t : "number" == typeof e ? e : (r = 360, a = e.split("_"), o = ((l = "=" === e.charAt(1)) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(a[0].substr(2)) : parseFloat(a[0])) * (-1 === e.indexOf("rad") ? 1 : j) - (l ? 0 : t), a.length && (n && (n[i] = t + o), -1 !== e.indexOf("short") && (o %= r) !== o % 180 && (o = o < 0 ? o + r : o - r), -1 !== e.indexOf("_cw") && o < 0 ? o = (o + 3599999999640) % r - (o / r | 0) * r : -1 !== e.indexOf("ccw") && 0 < o && (o = (o - 3599999999640) % r - (o / r | 0) * r)), t + o)) < 1e-6 && -1e-6 < s && (s = 0), s },
                            fe = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], fuchsia: [255, 0, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] },
                            me = function(e, t, i) { return 255 * (6 * (e = e < 0 ? e + 1 : 1 < e ? e - 1 : e) < 1 ? t + (i - t) * e * 6 : e < .5 ? i : 3 * e < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) + .5 | 0 },
                            ge = k.parseColor = function(e, t) { var i, n, r, a, o, s, l, c, h, u, d; if (e)
                                    if ("number" == typeof e) i = [e >> 16, e >> 8 & 255, 255 & e];
                                    else { if ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), fe[e]) i = fe[e];
                                        else if ("#" === e.charAt(0)) 4 === e.length && (e = "#" + (n = e.charAt(1)) + n + (r = e.charAt(2)) + r + (a = e.charAt(3)) + a), i = [(e = parseInt(e.substr(1), 16)) >> 16, e >> 8 & 255, 255 & e];
                                        else if ("hsl" === e.substr(0, 3))
                                            if (i = d = e.match(L), t) { if (-1 !== e.indexOf("=")) return e.match(R) } else o = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, n = 2 * (l = Number(i[2]) / 100) - (r = l <= .5 ? l * (s + 1) : l + s - l * s), 3 < i.length && (i[3] = Number(i[3])), i[0] = me(o + 1 / 3, n, r), i[1] = me(o, n, r), i[2] = me(o - 1 / 3, n, r);
                                        else i = e.match(L) || fe.transparent;
                                        i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), 3 < i.length && (i[3] = Number(i[3])) }
                                else i = fe.black; return t && !d && (n = i[0] / 255, r = i[1] / 255, a = i[2] / 255, l = ((c = Math.max(n, r, a)) + (h = Math.min(n, r, a))) / 2, c === h ? o = s = 0 : (u = c - h, s = .5 < l ? u / (2 - c - h) : u / (c + h), o = c === n ? (r - a) / u + (r < a ? 6 : 0) : c === r ? (a - n) / u + 2 : (n - r) / u + 4, o *= 60), i[0] = o + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * l + .5 | 0), i },
                            ve = function(e, t) { var i, n, r, a = e.match(Me) || [],
                                    o = 0,
                                    s = ""; if (!a.length) return e; for (i = 0; i < a.length; i++) n = a[i], o += (r = e.substr(o, e.indexOf(n, o) - o)).length + n.length, 3 === (n = ge(n, t)).length && n.push(1), s += r + (t ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")"; return s + e.substr(o) },
                            Me = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; for (e in fe) Me += "|" + e + "\\b";
                        Me = new RegExp(Me + ")", "gi"), k.colorStringFilter = function(e) { var t, i = e[0] + " " + e[1];
                            Me.test(i) && (t = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), e[0] = ve(e[0], t), e[1] = ve(e[1], t)), Me.lastIndex = 0 }, z.defaultStringFilter || (z.defaultStringFilter = k.colorStringFilter); var ye = function(e, t, a, o) { if (null == e) return function(e) { return e }; var s, l = t ? (e.match(Me) || [""])[0] : "",
                                    c = e.split(l).join("").match(b) || [],
                                    h = e.substr(0, e.indexOf(c[0])),
                                    u = ")" === e.charAt(e.length - 1) ? ")" : "",
                                    d = -1 !== e.indexOf(" ") ? " " : ",",
                                    p = c.length,
                                    f = 0 < p ? c[0].replace(L, "") : ""; return p ? s = t ? function(e) { var t, i, n, r; if ("number" == typeof e) e += f;
                                    else if (o && D.test(e)) { for (r = e.replace(D, "|").split("|"), n = 0; n < r.length; n++) r[n] = s(r[n]); return r.join(",") } if (t = (e.match(Me) || [l])[0], n = (i = e.split(t).join("").match(b) || []).length, p > n--)
                                        for (; ++n < p;) i[n] = a ? i[(n - 1) / 2 | 0] : c[n]; return h + i.join(d) + d + t + u + (-1 !== e.indexOf("inset") ? " inset" : "") } : function(e) { var t, i, n; if ("number" == typeof e) e += f;
                                    else if (o && D.test(e)) { for (i = e.replace(D, "|").split("|"), n = 0; n < i.length; n++) i[n] = s(i[n]); return i.join(",") } if (n = (t = e.match(b) || []).length, p > n--)
                                        for (; ++n < p;) t[n] = a ? t[(n - 1) / 2 | 0] : c[n]; return h + t.join(d) + u } : function(e) { return e } },
                            be = function(c) { return c = c.split(","),
                                    function(e, t, i, n, r, a, o) { var s, l = (t + "").split(" "); for (o = {}, s = 0; s < 4; s++) o[c[s]] = l[s] = l[s] || l[(s - 1) / 2 >> 0]; return n.parse(e, o, r, a) } },
                            _e = (r._setPluginRatio = function(e) { this.plugin.setRatio(e); for (var t, i, n, r, a, o = this.data, s = o.proxy, l = o.firstMPT; l;) t = s[l.v], l.r ? t = l.r(t) : t < 1e-6 && -1e-6 < t && (t = 0), l.t[l.p] = t, l = l._next; if (o.autoRotate && (o.autoRotate.rotation = o.mod ? o.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === e || 0 === e)
                                    for (l = o.firstMPT, a = 1 === e ? "e" : "b"; l;) { if ((i = l.t).type) { if (1 === i.type) { for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                                                i[a] = r } } else i[a] = i.s + i.xs0;
                                        l = l._next } }, function(e, t, i, n, r) { this.t = e, this.p = t, this.v = i, this.r = r, n && ((n._prev = this)._next = n) }),
                            xe = (r._parseToProxy = function(e, t, i, n, r, a) { var o, s, l, c, h, u = n,
                                    d = {},
                                    p = {},
                                    f = i._transform,
                                    m = B; for (i._transform = null, B = t, n = h = i.parse(e, t, n, r), B = m, a && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) { if (n.type <= 1 && (p[s = n.p] = n.s + n.c, d[s] = n.s, a || (c = new _e(n, "s", s, c, n.r), n.c = 0), 1 === n.type))
                                        for (o = n.l; 0 < --o;) l = "xn" + o, p[s = n.p + "_" + l] = n.data[l], d[s] = n[l], a || (c = new _e(n, l, s, c, n.rxp[l]));
                                    n = n._next } return { proxy: d, end: p, firstMPT: c, pt: h } }, r.CSSPropTween = function(e, t, i, n, r, a, o, s, l, c, h) { this.t = e, this.p = t, this.s = i, this.c = n, this.n = o || t, e instanceof xe || m.push(this.n), this.r = s ? "function" == typeof s ? s : Math.round : s, this.type = a || 0, l && (this.pr = l, f = !0), this.b = void 0 === c ? i : c, this.e = void 0 === h ? i + n : h, r && ((this._next = r)._prev = this) }),
                            Te = function(e, t, i, n, r, a) { var o = new xe(e, t, i, n - i, r, -1, a); return o.b = i, o.e = o.xs0 = n, o },
                            we = k.parseComplex = function(e, t, i, n, r, a, o, s, l, c) { i = i || a || "", "function" == typeof n && (n = n(C, A)), o = new xe(e, t, 0, 0, o, c ? 2 : 1, null, !1, s, i, n), n += "", r && Me.test(n + i) && (k.colorStringFilter(n = [i, n]), i = n[0], n = n[1]); var h, u, d, p, f, m, g, v, M, y, b, _, x, T = i.split(", ").join(",").split(" "),
                                    w = n.split(", ").join(",").split(" "),
                                    S = T.length,
                                    E = !1 !== P; for (-1 === n.indexOf(",") && -1 === i.indexOf(",") || (w = -1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (T = T.join(" ").replace(D, ", ").split(" "), w.join(" ").replace(D, ", ").split(" ")) : (T = T.join(" ").split(",").join(", ").split(" "), w.join(" ").split(",").join(", ").split(" ")), S = T.length), S !== w.length && (S = (T = (a || "").split(" ")).length), o.plugin = l, o.setRatio = c, h = Me.lastIndex = 0; h < S; h++)
                                    if (p = T[h], f = w[h] + "", (v = parseFloat(p)) || 0 === v) o.appendXtra("", v, ue(f, v), f.replace(R, ""), !(!E || -1 === f.indexOf("px")) && Math.round, !0);
                                    else if (r && Me.test(p)) _ = ")" + ((_ = f.indexOf(")") + 1) ? f.substr(_) : ""), x = -1 !== f.indexOf("hsl") && q, y = f, p = ge(p, x), f = ge(f, x), (M = 6 < p.length + f.length) && !q && 0 === f[3] ? (o["xs" + o.l] += o.l ? " transparent" : "transparent", o.e = o.e.split(w[h]).join("transparent")) : (q || (M = !1), x ? o.appendXtra(y.substr(0, y.indexOf("hsl")) + (M ? "hsla(" : "hsl("), p[0], ue(f[0], p[0]), ",", !1, !0).appendXtra("", p[1], ue(f[1], p[1]), "%,", !1).appendXtra("", p[2], ue(f[2], p[2]), M ? "%," : "%" + _, !1) : o.appendXtra(y.substr(0, y.indexOf("rgb")) + (M ? "rgba(" : "rgb("), p[0], f[0] - p[0], ",", Math.round, !0).appendXtra("", p[1], f[1] - p[1], ",", Math.round).appendXtra("", p[2], f[2] - p[2], M ? "," : _, Math.round), M && (p = p.length < 4 ? 1 : p[3], o.appendXtra("", p, (f.length < 4 ? 1 : f[3]) - p, _, !1))), Me.lastIndex = 0;
                                else if (m = p.match(L)) { if (!(g = f.match(R)) || g.length !== m.length) return o; for (u = d = 0; u < m.length; u++) b = m[u], y = p.indexOf(b, d), o.appendXtra(p.substr(d, y - d), Number(b), ue(g[u], b), "", !(!E || "px" !== p.substr(y + b.length, 2)) && Math.round, 0 === u), d = y + b.length;
                                    o["xs" + o.l] += p.substr(d) } else o["xs" + o.l] += o.l || o["xs" + o.l] ? " " + f : f; if (-1 !== n.indexOf("=") && o.data) { for (_ = o.xs0 + o.data.s, h = 1; h < o.l; h++) _ += o["xs" + h] + o.data["xn" + h];
                                    o.e = _ + o["xs" + h] } return o.l || (o.type = -1, o.xs0 = o.e), o.xfirst || o },
                            Se = 9; for ((e = xe.prototype).l = e.pr = 0; 0 < --Se;) e["xn" + Se] = 0, e["xs" + Se] = "";
                        e.xs0 = "", e._next = e._prev = e.xfirst = e.data = e.plugin = e.setRatio = e.rxp = null, e.appendXtra = function(e, t, i, n, r, a) { var o = this,
                                s = o.l; return o["xs" + s] += a && (s || o["xs" + s]) ? " " + e : e || "", i || 0 === s || o.plugin ? (o.l++, o.type = o.setRatio ? 2 : 1, o["xs" + o.l] = n || "", 0 < s ? (o.data["xn" + s] = t + i, o.rxp["xn" + s] = r, o["xn" + s] = t, o.plugin || (o.xfirst = new xe(o, "xn" + s, t, i, o.xfirst || o, 0, o.n, r, o.pr), o.xfirst.xs0 = 0)) : (o.data = { s: t + i }, o.rxp = {}, o.s = t, o.c = i, o.r = r), o) : (o["xs" + s] += t + (n || ""), o) }; var Ee = function(e, t) { t = t || {}, this.p = t.prefix && $(e) || e, g[e] = g[this.p] = this, this.format = t.formatter || ye(t.defaultValue, t.color, t.collapsible, t.multi), t.parser && (this.parse = t.parser), this.clrs = t.color, this.multi = t.multi, this.keyword = t.keyword, this.dflt = t.defaultValue, this.allowFunc = t.allowFunc, this.pr = t.priority || 0 },
                            Pe = r._registerComplexSpecialProp = function(e, t, i) { "object" !== rt(t) && (t = { parser: i }); var n, r = e.split(","),
                                    a = t.defaultValue; for (i = i || [a], n = 0; n < r.length; n++) t.prefix = 0 === n && t.prefix, t.defaultValue = i[n] || a, new Ee(r[n], t) },
                            Ae = r._registerPluginProp = function(e) { if (!g[e]) { var l = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin";
                                    Pe(e, { parser: function(e, t, i, n, r, a, o) { var s = c.com.greensock.plugins[l]; return s ? (s._cssRegister(), g[i].parse(e, t, i, n, r, a, o)) : (J("Error: " + l + " js file not loaded."), r) } }) } };
                        (e = Ee.prototype).parseComplex = function(e, t, i, n, r, a) { var o, s, l, c, h, u, d = this.keyword; if (this.multi && (D.test(i) || D.test(t) ? (s = t.replace(D, "|").split("|"), l = i.replace(D, "|").split("|")) : d && (s = [t], l = [i])), l) { for (c = l.length > s.length ? l.length : s.length, o = 0; o < c; o++) t = s[o] = s[o] || this.dflt, i = l[o] = l[o] || this.dflt, d && (h = t.indexOf(d)) !== (u = i.indexOf(d)) && (-1 === u ? s[o] = s[o].split(d).join("") : -1 === h && (s[o] += " " + d));
                                t = s.join(", "), i = l.join(", ") } return we(e, this.p, t, i, this.clrs, this.dflt, n, this.pr, r, a) }, e.parse = function(e, t, i, n, r, a, o) { return this.parseComplex(e.style, this.format(ie(e, this.p, S, !1, this.dflt)), this.format(t), r, a) }, k.registerSpecialProp = function(e, l, c) { Pe(e, { parser: function(e, t, i, n, r, a, o) { var s = new xe(e, i, 0, 0, r, 2, i, !1, c); return s.plugin = a, s.setRatio = l(e, t, n._tween, i), s }, priority: c }) }, k.useSVGTransformAttr = !0; var Ce, Le, Re, He, Oe, Ge = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                            De = $("transform"),
                            Ie = K + "transform",
                            Be = $("transformOrigin"),
                            Ne = null !== $("perspective"),
                            Fe = r.Transform = function() { this.perspective = parseFloat(k.defaultTransformPerspective) || 0, this.force3D = !(!1 === k.defaultForce3D || !Ne) && (k.defaultForce3D || "auto") },
                            ze = at.SVGElement,
                            ke = function(e, t, i) { var n, r = N.createElementNS("http://www.w3.org/2000/svg", e),
                                    a = /([a-z])([A-Z])/g; for (n in i) r.setAttributeNS(null, n.replace(a, "$1-$2").toLowerCase(), i[n]); return t.appendChild(r), r },
                            Ue = N.documentElement || {},
                            Ve = (Oe = E || /Android/i.test(Y) && !at.chrome, N.createElementNS && !Oe && (Le = ke("svg", Ue), He = (Re = ke("rect", Le, { width: 100, height: 50, x: 100 })).getBoundingClientRect().width, Re.style[Be] = "50% 50%", Re.style[De] = "scaleX(0.5)", Oe = He === Re.getBoundingClientRect().width && !(U && Ne), Ue.removeChild(Le)), Oe),
                            je = function(e, t, i, n, r, a) { var o, s, l, c, h, u, d, p, f, m, g, v, M, y, b = e._gsTransform,
                                    _ = qe(e, !0);
                                b && (M = b.xOrigin, y = b.yOrigin), (!n || (o = n.split(" ")).length < 2) && (0 === (d = e.getBBox()).x && 0 === d.y && d.width + d.height === 0 && (d = { x: parseFloat(e.hasAttribute("x") ? e.getAttribute("x") : e.hasAttribute("cx") ? e.getAttribute("cx") : 0) || 0, y: parseFloat(e.hasAttribute("y") ? e.getAttribute("y") : e.hasAttribute("cy") ? e.getAttribute("cy") : 0) || 0, width: 0, height: 0 }), o = [(-1 !== (t = he(t).split(" "))[0].indexOf("%") ? parseFloat(t[0]) / 100 * d.width : parseFloat(t[0])) + d.x, (-1 !== t[1].indexOf("%") ? parseFloat(t[1]) / 100 * d.height : parseFloat(t[1])) + d.y]), i.xOrigin = c = parseFloat(o[0]), i.yOrigin = h = parseFloat(o[1]), n && _ !== Ye && (u = _[0], d = _[1], p = _[2], f = _[3], m = _[4], g = _[5], (v = u * f - d * p) && (s = c * (f / v) + h * (-p / v) + (p * g - f * m) / v, l = c * (-d / v) + h * (u / v) - (u * g - d * m) / v, c = i.xOrigin = o[0] = s, h = i.yOrigin = o[1] = l)), b && (a && (i.xOffset = b.xOffset, i.yOffset = b.yOffset, b = i), r || !1 !== r && !1 !== k.defaultSmoothOrigin ? (s = c - M, l = h - y, b.xOffset += s * _[0] + l * _[2] - s, b.yOffset += s * _[1] + l * _[3] - l) : b.xOffset = b.yOffset = 0), a || e.setAttribute("data-svg-origin", o.join(" ")) },
                            We = function(t) { try { return t.getBBox() } catch (e) { return function e(t) { var i, n = F("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                                            r = this.parentNode,
                                            a = this.nextSibling,
                                            o = this.style.cssText; if (Ue.appendChild(n), n.appendChild(this), this.style.display = "block", t) try { i = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = e } catch (e) {} else this._originalGetBBox && (i = this._originalGetBBox()); return a ? r.insertBefore(this, a) : r.appendChild(this), Ue.removeChild(n), this.style.cssText = o, i }.call(t, !0) } },
                            Xe = function(e) { return !(!ze || !e.getCTM || e.parentNode && !e.ownerSVGElement || !We(e)) },
                            Ye = [1, 0, 0, 1, 0, 0],
                            qe = function(e, t) { var i, n, r, a, o, s, l, c = e._gsTransform || new Fe,
                                    h = e.style; if (De ? n = ie(e, Ie, null, !0) : e.currentStyle && (n = (n = e.currentStyle.filter.match(d)) && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), c.x || 0, c.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, De && i && !e.offsetParent && (a = h.display, h.display = "block", (l = e.parentNode) && e.offsetParent || (o = 1, s = e.nextSibling, Ue.appendChild(e)), i = !(n = ie(e, Ie, null, !0)) || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, a ? h.display = a : $e(h, "display"), o && (s ? l.insertBefore(e, s) : l ? l.appendChild(e) : Ue.removeChild(e))), (c.svg || e.getCTM && Xe(e)) && (i && -1 !== (h[De] + "").indexOf("matrix") && (n = h[De], i = 0), r = e.getAttribute("transform"), i && r && (n = "matrix(" + (r = e.transform.baseVal.consolidate().matrix).a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", i = 0)), i) return Ye; for (r = (n || "").match(L) || [], Se = r.length; - 1 < --Se;) a = Number(r[Se]), r[Se] = (o = a - (a |= 0)) ? (1e5 * o + (o < 0 ? -.5 : .5) | 0) / 1e5 + a : a; return t && 6 < r.length ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r },
                            Ze = r.getTransform = function(e, t, i, n) { if (e._gsTransform && i && !n) return e._gsTransform; var r, a, o, s, l, c, h = i && e._gsTransform || new Fe,
                                    u = h.scaleX < 0,
                                    d = Ne && (parseFloat(ie(e, Be, t, !1, "0 0 0").split(" ")[2]) || h.zOrigin) || 0,
                                    p = parseFloat(k.defaultTransformPerspective) || 0; if (h.svg = !(!e.getCTM || !Xe(e)), h.svg && (je(e, ie(e, Be, t, !1, "50% 50%") + "", h, e.getAttribute("data-svg-origin")), Ce = k.useSVGTransformAttr || Ve), (r = qe(e)) !== Ye) { if (16 === r.length) { var f, m, g, v, M, y = r[0],
                                            b = r[1],
                                            _ = r[2],
                                            x = r[3],
                                            T = r[4],
                                            w = r[5],
                                            S = r[6],
                                            E = r[7],
                                            P = r[8],
                                            A = r[9],
                                            C = r[10],
                                            L = r[12],
                                            R = r[13],
                                            H = r[14],
                                            O = r[11],
                                            G = Math.atan2(S, C);
                                        h.zOrigin && (L = P * (H = -h.zOrigin) - r[12], R = A * H - r[13], H = C * H + h.zOrigin - r[14]), h.rotationX = G * j, G && (f = T * (v = Math.cos(-G)) + P * (M = Math.sin(-G)), m = w * v + A * M, g = S * v + C * M, P = T * -M + P * v, A = w * -M + A * v, C = S * -M + C * v, O = E * -M + O * v, T = f, w = m, S = g), G = Math.atan2(-_, C), h.rotationY = G * j, G && (m = b * (v = Math.cos(-G)) - A * (M = Math.sin(-G)), g = _ * v - C * M, A = b * M + A * v, C = _ * M + C * v, O = x * M + O * v, y = f = y * v - P * M, b = m, _ = g), G = Math.atan2(b, y), h.rotation = G * j, G && (f = y * (v = Math.cos(G)) + b * (M = Math.sin(G)), m = T * v + w * M, g = P * v + A * M, b = b * v - y * M, w = w * v - T * M, A = A * v - P * M, y = f, T = m, P = g), h.rotationX && 359.9 < Math.abs(h.rotationX) + Math.abs(h.rotation) && (h.rotationX = h.rotation = 0, h.rotationY = 180 - h.rotationY), G = Math.atan2(T, w), h.scaleX = (1e5 * Math.sqrt(y * y + b * b + _ * _) + .5 | 0) / 1e5, h.scaleY = (1e5 * Math.sqrt(w * w + S * S) + .5 | 0) / 1e5, h.scaleZ = (1e5 * Math.sqrt(P * P + A * A + C * C) + .5 | 0) / 1e5, y /= h.scaleX, T /= h.scaleY, b /= h.scaleX, w /= h.scaleY, 2e-5 < Math.abs(G) ? (h.skewX = G * j, T = 0, "simple" !== h.skewType && (h.scaleY *= 1 / Math.cos(G))) : h.skewX = 0, h.perspective = O ? 1 / (O < 0 ? -O : O) : 0, h.x = L, h.y = R, h.z = H, h.svg && (h.x -= h.xOrigin - (h.xOrigin * y - h.yOrigin * T), h.y -= h.yOrigin - (h.yOrigin * b - h.xOrigin * w)) } else if (!Ne || n || !r.length || h.x !== r[4] || h.y !== r[5] || !h.rotationX && !h.rotationY) { var D = 6 <= r.length,
                                            I = D ? r[0] : 1,
                                            B = r[1] || 0,
                                            N = r[2] || 0,
                                            F = D ? r[3] : 1;
                                        h.x = r[4] || 0, h.y = r[5] || 0, o = Math.sqrt(I * I + B * B), s = Math.sqrt(F * F + N * N), l = I || B ? Math.atan2(B, I) * j : h.rotation || 0, c = N || F ? Math.atan2(N, F) * j + l : h.skewX || 0, h.scaleX = o, h.scaleY = s, h.rotation = l, h.skewX = c, Ne && (h.rotationX = h.rotationY = h.z = 0, h.perspective = p, h.scaleZ = 1), h.svg && (h.x -= h.xOrigin - (h.xOrigin * I + h.yOrigin * N), h.y -= h.yOrigin - (h.xOrigin * B + h.yOrigin * F)) } for (a in 90 < Math.abs(h.skewX) && Math.abs(h.skewX) < 270 && (u ? (h.scaleX *= -1, h.skewX += h.rotation <= 0 ? 180 : -180, h.rotation += h.rotation <= 0 ? 180 : -180) : (h.scaleY *= -1, h.skewX += h.skewX <= 0 ? 180 : -180)), h.zOrigin = d, h) h[a] < 2e-5 && -2e-5 < h[a] && (h[a] = 0) } return i && (e._gsTransform = h).svg && (Ce && e.style[De] ? z.delayedCall(.001, function() { $e(e.style, De) }) : !Ce && e.getAttribute("transform") && z.delayedCall(.001, function() { e.removeAttribute("transform") })), h },
                            Je = function(e) { var t, i, n = this.data,
                                    r = -n.rotation * V,
                                    a = r + n.skewX * V,
                                    o = 1e5,
                                    s = (Math.cos(r) * n.scaleX * o | 0) / o,
                                    l = (Math.sin(r) * n.scaleX * o | 0) / o,
                                    c = (Math.sin(a) * -n.scaleY * o | 0) / o,
                                    h = (Math.cos(a) * n.scaleY * o | 0) / o,
                                    u = this.t.style,
                                    d = this.t.currentStyle; if (d) { i = l, l = -c, c = -i, t = d.filter, u.filter = ""; var p, f, m = this.t.offsetWidth,
                                        g = this.t.offsetHeight,
                                        v = "absolute" !== d.position,
                                        M = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + c + ", M22=" + h,
                                        y = n.x + m * n.xPercent / 100,
                                        b = n.y + g * n.yPercent / 100; if (null != n.ox && (y += (p = (n.oxp ? m * n.ox * .01 : n.ox) - m / 2) - (p * s + (f = (n.oyp ? g * n.oy * .01 : n.oy) - g / 2) * l), b += f - (p * c + f * h)), M += v ? ", Dx=" + ((p = m / 2) - (p * s + (f = g / 2) * l) + y) + ", Dy=" + (f - (p * c + f * h) + b) + ")" : ", sizingMethod='auto expand')", -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(") ? u.filter = t.replace(G, M) : u.filter = M + " " + t, 0 !== e && 1 !== e || 1 === s && 0 === l && 0 === c && 1 === h && (v && -1 === M.indexOf("Dx=0, Dy=0") || O.test(t) && 100 !== parseFloat(RegExp.$1) || -1 === t.indexOf(t.indexOf("Alpha")) && u.removeAttribute("filter")), !v) { var _, x, T, w = E < 8 ? 1 : -1; for (p = n.ieOffsetX || 0, f = n.ieOffsetY || 0, n.ieOffsetX = Math.round((m - ((s < 0 ? -s : s) * m + (l < 0 ? -l : l) * g)) / 2 + y), n.ieOffsetY = Math.round((g - ((h < 0 ? -h : h) * g + (c < 0 ? -c : c) * m)) / 2 + b), Se = 0; Se < 4; Se++) T = (i = -1 !== (_ = d[x = le[Se]]).indexOf("px") ? parseFloat(_) : ne(this.t, x, parseFloat(_), _.replace(H, "")) || 0) !== n[x] ? Se < 2 ? -n.ieOffsetX : -n.ieOffsetY : Se < 2 ? p - n.ieOffsetX : f - n.ieOffsetY, u[x] = (n[x] = Math.round(i - T * (0 === Se || 2 === Se ? 1 : w))) + "px" } } },
                            Ke = r.set3DTransformRatio = r.setTransformRatio = function(e) { var t, i, n, r, a, o, s, l, c, h, u, d, p, f, m, g, v, M, y, b, _, x, T, w = this.data,
                                    S = this.t.style,
                                    E = w.rotation,
                                    P = w.rotationX,
                                    A = w.rotationY,
                                    C = w.scaleX,
                                    L = w.scaleY,
                                    R = w.scaleZ,
                                    H = w.x,
                                    O = w.y,
                                    G = w.z,
                                    D = w.svg,
                                    I = w.perspective,
                                    B = w.force3D,
                                    N = w.skewY,
                                    F = w.skewX; if (N && (F += N, E += N), !((1 !== e && 0 !== e || "auto" !== B || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && B || G || I || A || P || 1 !== R) || Ce && D || !Ne) E || F || D ? (E *= V, x = F * V, T = 1e5, i = Math.cos(E) * C, a = Math.sin(E) * C, n = Math.sin(E - x) * -L, o = Math.cos(E - x) * L, x && "simple" === w.skewType && (t = Math.tan(x - N * V), n *= t = Math.sqrt(1 + t * t), o *= t, N && (t = Math.tan(N * V), i *= t = Math.sqrt(1 + t * t), a *= t)), D && (H += w.xOrigin - (w.xOrigin * i + w.yOrigin * n) + w.xOffset, O += w.yOrigin - (w.xOrigin * a + w.yOrigin * o) + w.yOffset, Ce && (w.xPercent || w.yPercent) && (m = this.t.getBBox(), H += .01 * w.xPercent * m.width, O += .01 * w.yPercent * m.height), H < (m = 1e-6) && -m < H && (H = 0), O < m && -m < O && (O = 0)), y = (i * T | 0) / T + "," + (a * T | 0) / T + "," + (n * T | 0) / T + "," + (o * T | 0) / T + "," + H + "," + O + ")", D && Ce ? this.t.setAttribute("transform", "matrix(" + y) : S[De] = (w.xPercent || w.yPercent ? "translate(" + w.xPercent + "%," + w.yPercent + "%) matrix(" : "matrix(") + y) : S[De] = (w.xPercent || w.yPercent ? "translate(" + w.xPercent + "%," + w.yPercent + "%) matrix(" : "matrix(") + C + ",0,0," + L + "," + H + "," + O + ")";
                                else { if (U && (C < (m = 1e-4) && -m < C && (C = R = 2e-5), L < m && -m < L && (L = R = 2e-5), !I || w.z || w.rotationX || w.rotationY || (I = 0)), E || F) E *= V, g = i = Math.cos(E), v = a = Math.sin(E), F && (E -= F * V, g = Math.cos(E), v = Math.sin(E), "simple" === w.skewType && (t = Math.tan((F - N) * V), g *= t = Math.sqrt(1 + t * t), v *= t, w.skewY && (t = Math.tan(N * V), i *= t = Math.sqrt(1 + t * t), a *= t))), n = -v, o = g;
                                    else { if (!(A || P || 1 !== R || I || D)) return void(S[De] = (w.xPercent || w.yPercent ? "translate(" + w.xPercent + "%," + w.yPercent + "%) translate3d(" : "translate3d(") + H + "px," + O + "px," + G + "px)" + (1 !== C || 1 !== L ? " scale(" + C + "," + L + ")" : ""));
                                        i = o = 1, n = a = 0 }
                                    h = 1, r = s = l = c = u = d = 0, p = I ? -1 / I : 0, f = w.zOrigin, m = 1e-6, b = ",", _ = "0", (E = A * V) && (g = Math.cos(E), u = p * (l = -(v = Math.sin(E))), r = i * v, s = a * v, p *= h = g, i *= g, a *= g), (E = P * V) && (t = n * (g = Math.cos(E)) + r * (v = Math.sin(E)), M = o * g + s * v, c = h * v, d = p * v, r = n * -v + r * g, s = o * -v + s * g, h *= g, p *= g, n = t, o = M), 1 !== R && (r *= R, s *= R, h *= R, p *= R), 1 !== L && (n *= L, o *= L, c *= L, d *= L), 1 !== C && (i *= C, a *= C, l *= C, u *= C), (f || D) && (f && (H += r * -f, O += s * -f, G += h * -f + f), D && (H += w.xOrigin - (w.xOrigin * i + w.yOrigin * n) + w.xOffset, O += w.yOrigin - (w.xOrigin * a + w.yOrigin * o) + w.yOffset), H < m && -m < H && (H = _), O < m && -m < O && (O = _), G < m && -m < G && (G = 0)), y = w.xPercent || w.yPercent ? "translate(" + w.xPercent + "%," + w.yPercent + "%) matrix3d(" : "matrix3d(", y += (i < m && -m < i ? _ : i) + b + (a < m && -m < a ? _ : a) + b + (l < m && -m < l ? _ : l), y += b + (u < m && -m < u ? _ : u) + b + (n < m && -m < n ? _ : n) + b + (o < m && -m < o ? _ : o), P || A || 1 !== R ? (y += b + (c < m && -m < c ? _ : c) + b + (d < m && -m < d ? _ : d) + b + (r < m && -m < r ? _ : r), y += b + (s < m && -m < s ? _ : s) + b + (h < m && -m < h ? _ : h) + b + (p < m && -m < p ? _ : p) + b) : y += ",0,0,0,0,1,0,", y += H + b + O + b + G + b + (I ? 1 + -G / I : 1) + ")", S[De] = y } };
                        (e = Fe.prototype).x = e.y = e.z = e.skewX = e.skewY = e.rotation = e.rotationX = e.rotationY = e.zOrigin = e.xPercent = e.yPercent = e.xOffset = e.yOffset = 0, e.scaleX = e.scaleY = e.scaleZ = 1, Pe("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", { parser: function(e, t, i, n, r, a, o) { if (n._lastParsedTransform === o) return r; var s = (n._lastParsedTransform = o).scale && "function" == typeof o.scale ? o.scale : 0;
                                s && (o.scale = s(C, e)); var l, c, h, u, d, p, f, m, g, v = e._gsTransform,
                                    M = e.style,
                                    y = Ge.length,
                                    b = o,
                                    _ = {},
                                    x = "transformOrigin",
                                    T = Ze(e, S, !0, b.parseTransform),
                                    w = b.transform && ("function" == typeof b.transform ? b.transform(C, A) : b.transform); if (T.skewType = b.skewType || T.skewType || k.defaultSkewType, n._transform = T, "rotationZ" in b && (b.rotation = b.rotationZ), w && "string" == typeof w && De)(c = W.style)[De] = w, c.display = "block", c.position = "absolute", -1 !== w.indexOf("%") && (c.width = ie(e, "width"), c.height = ie(e, "height")), N.body.appendChild(W), l = Ze(W, null, !1), "simple" === T.skewType && (l.scaleY *= Math.cos(l.skewX * V)), T.svg && (p = T.xOrigin, f = T.yOrigin, l.x -= T.xOffset, l.y -= T.yOffset, (b.transformOrigin || b.svgOrigin) && (w = {}, je(e, he(b.transformOrigin), w, b.svgOrigin, b.smoothOrigin, !0), p = w.xOrigin, f = w.yOrigin, l.x -= w.xOffset - T.xOffset, l.y -= w.yOffset - T.yOffset), (p || f) && (m = qe(W, !0), l.x -= p - (p * m[0] + f * m[2]), l.y -= f - (p * m[1] + f * m[3]))), N.body.removeChild(W), l.perspective || (l.perspective = T.perspective), null != b.xPercent && (l.xPercent = de(b.xPercent, T.xPercent)), null != b.yPercent && (l.yPercent = de(b.yPercent, T.yPercent));
                                else if ("object" === rt(b)) { if (l = { scaleX: de(null != b.scaleX ? b.scaleX : b.scale, T.scaleX), scaleY: de(null != b.scaleY ? b.scaleY : b.scale, T.scaleY), scaleZ: de(b.scaleZ, T.scaleZ), x: de(b.x, T.x), y: de(b.y, T.y), z: de(b.z, T.z), xPercent: de(b.xPercent, T.xPercent), yPercent: de(b.yPercent, T.yPercent), perspective: de(b.transformPerspective, T.perspective) }, null != (d = b.directionalRotation))
                                        if ("object" === rt(d))
                                            for (c in d) b[c] = d[c];
                                        else b.rotation = d;
                                        "string" == typeof b.x && -1 !== b.x.indexOf("%") && (l.x = 0, l.xPercent = de(b.x, T.xPercent)), "string" == typeof b.y && -1 !== b.y.indexOf("%") && (l.y = 0, l.yPercent = de(b.y, T.yPercent)), l.rotation = pe("rotation" in b ? b.rotation : "shortRotation" in b ? b.shortRotation + "_short" : T.rotation, T.rotation, "rotation", _), Ne && (l.rotationX = pe("rotationX" in b ? b.rotationX : "shortRotationX" in b ? b.shortRotationX + "_short" : T.rotationX || 0, T.rotationX, "rotationX", _), l.rotationY = pe("rotationY" in b ? b.rotationY : "shortRotationY" in b ? b.shortRotationY + "_short" : T.rotationY || 0, T.rotationY, "rotationY", _)), l.skewX = pe(b.skewX, T.skewX), l.skewY = pe(b.skewY, T.skewY) } for (Ne && null != b.force3D && (T.force3D = b.force3D, u = !0), (h = T.force3D || T.z || T.rotationX || T.rotationY || l.z || l.rotationX || l.rotationY || l.perspective) || null == b.scale || (l.scaleZ = 1); - 1 < --y;)(1e-6 < (w = l[g = Ge[y]] - T[g]) || w < -1e-6 || null != b[g] || null != B[g]) && (u = !0, r = new xe(T, g, T[g], w, r), g in _ && (r.e = _[g]), r.xs0 = 0, r.plugin = a, n._overwriteProps.push(r.n)); return w = "function" == typeof b.transformOrigin ? b.transformOrigin(C, A) : b.transformOrigin, T.svg && (w || b.svgOrigin) && (p = T.xOffset, f = T.yOffset, je(e, he(w), l, b.svgOrigin, b.smoothOrigin), r = Te(T, "xOrigin", (v ? T : l).xOrigin, l.xOrigin, r, x), r = Te(T, "yOrigin", (v ? T : l).yOrigin, l.yOrigin, r, x), p === T.xOffset && f === T.yOffset || (r = Te(T, "xOffset", v ? p : T.xOffset, T.xOffset, r, x), r = Te(T, "yOffset", v ? f : T.yOffset, T.yOffset, r, x)), w = "0px 0px"), (w || Ne && h && T.zOrigin) && (De ? (u = !0, g = Be, w || (w = (w = (ie(e, g, S, !1, "50% 50%") + "").split(" "))[0] + " " + w[1] + " " + T.zOrigin + "px"), w += "", (r = new xe(M, g, 0, 0, r, -1, x)).b = M[g], r.plugin = a, r.xs0 = r.e = Ne ? (c = T.zOrigin, w = w.split(" "), T.zOrigin = (2 < w.length ? parseFloat(w[2]) : c) || 0, r.xs0 = r.e = w[0] + " " + (w[1] || "50%") + " 0px", (r = new xe(T, "zOrigin", 0, 0, r, -1, r.n)).b = c, T.zOrigin) : w) : he(w + "", T)), u && (n._transformType = T.svg && Ce || !h && 3 !== this._transformType ? 2 : 3), s && (o.scale = s), r }, allowFunc: !0, prefix: !0 }), Pe("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset" }), Pe("clipPath", { defaultValue: "inset(0px)", prefix: !0, multi: !0, formatter: ye("inset(0px 0px 0px 0px)", !1, !0) }), Pe("borderRadius", { defaultValue: "0px", parser: function(e, t, i, n, r, a) { t = this.format(t); var o, s, l, c, h, u, d, p, f, m, g, v, M, y, b, _, x = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                    T = e.style; for (f = parseFloat(e.offsetWidth), m = parseFloat(e.offsetHeight), o = t.split(" "), s = 0; s < x.length; s++) this.p.indexOf("border") && (x[s] = $(x[s])), -1 !== (h = c = ie(e, x[s], S, !1, "0px")).indexOf(" ") && (h = (c = h.split(" "))[0], c = c[1]), u = l = o[s], d = parseFloat(h), v = h.substr((d + "").length), "" === (g = (M = "=" === u.charAt(1)) ? (p = parseInt(u.charAt(0) + "1", 10), u = u.substr(2), p *= parseFloat(u), u.substr((p + "").length - (p < 0 ? 1 : 0)) || "") : (p = parseFloat(u), u.substr((p + "").length))) && (g = w[i] || v), g !== v && (y = ne(e, "borderLeft", d, v), b = ne(e, "borderTop", d, v), c = "%" === g ? (h = y / f * 100 + "%", b / m * 100 + "%") : "em" === g ? (h = y / (_ = ne(e, "borderLeft", 1, "em")) + "em", b / _ + "em") : (h = y + "px", b + "px"), M && (u = parseFloat(h) + p + g, l = parseFloat(c) + p + g)), r = we(T, x[s], h + " " + c, u + " " + l, !1, "0px", r); return r }, prefix: !0, formatter: ye("0px 0px 0px 0px", !1, !0) }), Pe("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", { defaultValue: "0px", parser: function(e, t, i, n, r, a) { return we(e.style, i, this.format(ie(e, i, S, !1, "0px 0px")), this.format(t), !1, "0px", r) }, prefix: !0, formatter: ye("0px 0px", !1, !0) }), Pe("backgroundPosition", { defaultValue: "0 0", parser: function(e, t, i, n, r, a) { var o, s, l, c, h, u, d = "background-position",
                                    p = S || te(e),
                                    f = this.format((p ? E ? p.getPropertyValue(d + "-x") + " " + p.getPropertyValue(d + "-y") : p.getPropertyValue(d) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"),
                                    m = this.format(t); if (-1 !== f.indexOf("%") != (-1 !== m.indexOf("%")) && m.split(",").length < 2 && (u = ie(e, "backgroundImage").replace(T, "")) && "none" !== u) { for (o = f.split(" "), s = m.split(" "), X.setAttribute("src", u), l = 2; - 1 < --l;)(c = -1 !== (f = o[l]).indexOf("%")) !== (-1 !== s[l].indexOf("%")) && (h = 0 === l ? e.offsetWidth - X.width : e.offsetHeight - X.height, o[l] = c ? parseFloat(f) / 100 * h + "px" : parseFloat(f) / h * 100 + "%");
                                    f = o.join(" ") } return this.parseComplex(e.style, f, m, r, a) }, formatter: he }), Pe("backgroundSize", { defaultValue: "0 0", formatter: function(e) { return "co" === (e += "").substr(0, 2) ? e : he(-1 === e.indexOf(" ") ? e + " " + e : e) } }), Pe("perspective", { defaultValue: "0px", prefix: !0 }), Pe("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), Pe("transformStyle", { prefix: !0 }), Pe("backfaceVisibility", { prefix: !0 }), Pe("userSelect", { prefix: !0 }), Pe("margin", { parser: be("marginTop,marginRight,marginBottom,marginLeft") }), Pe("padding", { parser: be("paddingTop,paddingRight,paddingBottom,paddingLeft") }), Pe("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function(e, t, i, n, r, a) { var o, s, l; return t = E < 9 ? (s = e.currentStyle, l = E < 8 ? " " : ",", o = "rect(" + s.clipTop + l + s.clipRight + l + s.clipBottom + l + s.clipLeft + ")", this.format(t).split(",").join(l)) : (o = this.format(ie(e, this.p, S, !1, this.dflt)), this.format(t)), this.parseComplex(e.style, o, t, r, a) } }), Pe("textShadow", { defaultValue: "0px 0px 0px #999", color: !0, multi: !0 }), Pe("autoRound,strictUnits", { parser: function(e, t, i, n, r) { return r } }), Pe("border", { defaultValue: "0px solid #000", parser: function(e, t, i, n, r, a) { var o = ie(e, "borderTopWidth", S, !1, "0px"),
                                    s = this.format(t).split(" "),
                                    l = s[0].replace(H, ""); return "px" !== l && (o = parseFloat(o) / ne(e, "borderTopWidth", 1, l) + l), this.parseComplex(e.style, this.format(o + " " + ie(e, "borderTopStyle", S, !1, "solid") + " " + ie(e, "borderTopColor", S, !1, "#000")), s.join(" "), r, a) }, color: !0, formatter: function(e) { var t = e.split(" "); return t[0] + " " + (t[1] || "solid") + " " + (e.match(Me) || ["#000"])[0] } }), Pe("borderWidth", { parser: be("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }), Pe("float,cssFloat,styleFloat", { parser: function(e, t, i, n, r, a) { var o = e.style,
                                    s = "cssFloat" in o ? "cssFloat" : "styleFloat"; return new xe(o, s, 0, 0, r, -1, i, !1, 0, o[s], t) } }); var Qe = function(e) { var t, i = this.t,
                                n = i.filter || ie(this.data, "filter") || "",
                                r = this.s + this.c * e | 0;
                            100 === r && (t = -1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), !ie(this.data, "filter")) : (i.filter = n.replace(o, ""), !0)), t || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(O, "opacity=" + r)) };
                        Pe("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function(e, t, i, n, r, a) { var o = parseFloat(ie(e, "opacity", S, !1, "1")),
                                    s = e.style,
                                    l = "autoAlpha" === i; return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + o), l && 1 === o && "hidden" === ie(e, "visibility", S) && 0 !== t && (o = 0), q ? r = new xe(s, "opacity", o, t - o, r) : ((r = new xe(s, "opacity", 100 * o, 100 * (t - o), r)).xn1 = l ? 1 : 0, s.zoom = 1, r.type = 2, r.b = "alpha(opacity=" + r.s + ")", r.e = "alpha(opacity=" + (r.s + r.c) + ")", r.data = e, r.plugin = a, r.setRatio = Qe), l && ((r = new xe(s, "visibility", 0, 0, r, -1, null, !1, 0, 0 !== o ? "inherit" : "hidden", 0 === t ? "hidden" : "inherit")).xs0 = "inherit", n._overwriteProps.push(r.n), n._overwriteProps.push(i)), r } }); var $e = function(e, t) { t && (e.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), e.removeProperty(t.replace(s, "-$1").toLowerCase())) : e.removeAttribute(t)) },
                            et = function(e) { if (this.t._gsClassPT = this, 1 === e || 0 === e) { this.t.setAttribute("class", 0 === e ? this.b : this.e); for (var t = this.data, i = this.t.style; t;) t.v ? i[t.p] = t.v : $e(i, t.p), t = t._next;
                                    1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null) } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e) };
                        Pe("className", { parser: function(e, t, i, n, r, a, o) { var s, l, c, h, u, d = e.getAttribute("class") || "",
                                    p = e.style.cssText; if ((r = n._classNamePT = new xe(e, i, 0, 0, r, 2)).setRatio = et, r.pr = -11, f = !0, r.b = d, l = ae(e, S), c = e._gsClassPT) { for (h = {}, u = c.data; u;) h[u.p] = 1, u = u._next;
                                    c.setRatio(1) } return (e._gsClassPT = r).e = "=" !== t.charAt(1) ? t : d.replace(new RegExp("(?:\\s|^)" + t.substr(2) + "(?![\\w-])"), "") + ("+" === t.charAt(0) ? " " + t.substr(2) : ""), e.setAttribute("class", r.e), s = oe(e, l, ae(e), o, h), e.setAttribute("class", d), r.data = s.firstMPT, e.style.cssText = p, r = r.xfirst = n.parse(e, s.difs, r, a) } }); var tt = function(e) { if ((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) { var t, i, n, r, a, o = this.t.style,
                                    s = g.transform.parse; if ("all" === this.e) r = !(o.cssText = "");
                                else
                                    for (n = (t = this.e.split(" ").join("").split(",")).length; - 1 < --n;) i = t[n], g[i] && (g[i].parse === s ? r = !0 : i = "transformOrigin" === i ? Be : g[i].p), $e(o, i);
                                r && ($e(o, De), (a = this.t._gsTransform) && (a.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform)) } }; for (Pe("clearProps", { parser: function(e, t, i, n, r) { return (r = new xe(e, i, 0, 0, r, 2)).setRatio = tt, r.e = t, r.pr = -10, r.data = n._tween, f = !0, r } }), e = "bezier,throwProps,physicsProps,physics2D".split(","), Se = e.length; Se--;) Ae(e[Se]);
                        (e = k.prototype)._firstPT = e._lastParsedTransform = e._transform = null, e._onInitTween = function(e, t, i, n) { if (!e.nodeType) return !1;
                            this._target = A = e, this._tween = i, this._vars = t, C = n, P = t.autoRound, f = !1, w = t.suffixMap || k.suffixMap, S = te(e), m = this._overwriteProps; var r, a, o, s, l, c, h, u, d, p = e.style; if (v && "" === p.zIndex && ("auto" !== (r = ie(e, "zIndex", S)) && "" !== r || this._addLazySet(p, "zIndex", 0)), "string" == typeof t && (s = p.cssText, r = ae(e, S), p.cssText = s + ";" + t, r = oe(e, r, ae(e)).difs, !q && _.test(t) && (r.opacity = parseFloat(RegExp.$1)), t = r, p.cssText = s), t.className ? this._firstPT = a = g.className.parse(e, t.className, "className", this, null, null, t) : this._firstPT = a = this.parse(e, t, null), this._transformType) { for (d = 3 === this._transformType, De ? M && (v = !0, "" === p.zIndex && ("auto" !== (h = ie(e, "zIndex", S)) && "" !== h || this._addLazySet(p, "zIndex", 0)), y && this._addLazySet(p, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (d ? "visible" : "hidden"))) : p.zoom = 1, o = a; o && o._next;) o = o._next;
                                u = new xe(e, "transform", 0, 0, null, 2), this._linkCSSP(u, null, o), u.setRatio = De ? Ke : Je, u.data = this._transform || Ze(e, S, !0), u.tween = i, u.pr = -1, m.pop() } if (f) { for (; a;) { for (c = a._next, o = s; o && o.pr > a.pr;) o = o._next;
                                    (a._prev = o ? o._prev : l) ? a._prev._next = a: s = a, (a._next = o) ? o._prev = a : l = a, a = c }
                                this._firstPT = s } return !0 }, e.parse = function(e, t, i, n) { var r, a, o, s, l, c, h, u, d, p, f = e.style; for (r in t) { if (c = t[r], a = g[r], "function" != typeof c || a && a.allowFunc || (c = c(C, A)), a) i = a.parse(e, c, r, this, i, n, t);
                                else { if ("--" === r.substr(0, 2)) { this._tween._propLookup[r] = this._addTween.call(this._tween, e.style, "setProperty", te(e).getPropertyValue(r) + "", c + "", r, !1, r); continue }
                                    l = ie(e, r, S) + "", d = "string" == typeof c, "color" === r || "fill" === r || "stroke" === r || -1 !== r.indexOf("Color") || d && x.test(c) ? (d || (c = (3 < (c = ge(c)).length ? "rgba(" : "rgb(") + c.join(",") + ")"), i = we(f, r, l, c, !0, "transparent", i, 0, n)) : d && I.test(c) ? i = we(f, r, l, c, !0, null, i, 0, n) : (h = (o = parseFloat(l)) || 0 === o ? l.substr((o + "").length) : "", "" !== l && "auto" !== l || (h = "width" === r || "height" === r ? (o = ce(e, r, S), "px") : "left" === r || "top" === r ? (o = re(e, r, S), "px") : (o = "opacity" !== r ? 0 : 1, "")), "" === (u = (p = d && "=" === c.charAt(1)) ? (s = parseInt(c.charAt(0) + "1", 10), c = c.substr(2), s *= parseFloat(c), c.replace(H, "")) : (s = parseFloat(c), d ? c.replace(H, "") : "")) && (u = r in w ? w[r] : h), c = s || 0 === s ? (p ? s + o : s) + u : t[r], h !== u && ("" === u && "lineHeight" !== r || (s || 0 === s) && o && (o = ne(e, r, o, h), "%" === u ? (o /= ne(e, r, 100, "%") / 100, !0 !== t.strictUnits && (l = o + "%")) : "em" === u || "rem" === u || "vw" === u || "vh" === u ? o /= ne(e, r, 1, u) : "px" !== u && (s = ne(e, r, s, u), u = "px"), p && (s || 0 === s) && (c = s + o + u))), p && (s += o), !o && 0 !== o || !s && 0 !== s ? void 0 !== f[r] && (c || c + "" != "NaN" && null != c) ? (i = new xe(f, r, s || o || 0, 0, i, -1, r, !1, 0, l, c)).xs0 = "none" !== c || "display" !== r && -1 === r.indexOf("Style") ? c : l : J("invalid " + r + " tween value: " + t[r]) : (i = new xe(f, r, o, s - o, i, 0, r, !1 !== P && ("px" === u || "zIndex" === r), 0, l, c)).xs0 = u) }
                                n && i && !i.plugin && (i.plugin = n) } return i }, e.setRatio = function(e) { var t, i, n, r = this._firstPT; if (1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                if (e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                                    for (; r;) { if (t = r.c * e + r.s, r.r ? t = r.r(t) : t < 1e-6 && -1e-6 < t && (t = 0), r.type)
                                            if (1 === r.type)
                                                if (2 === (n = r.l)) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2;
                                                else if (3 === n) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                                        else if (4 === n) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4;
                                        else if (5 === n) r.t[r.p] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5;
                                        else { for (i = r.xs0 + t + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                            r.t[r.p] = i } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(e);
                                        else r.t[r.p] = t + r.xs0;
                                        r = r._next } else
                                        for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(e), r = r._next;
                                else
                                    for (; r;) { if (2 !== r.type)
                                            if (r.r && -1 !== r.type)
                                                if (t = r.r(r.s + r.c), r.type) { if (1 === r.type) { for (n = r.l, i = r.xs0 + t + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                                                        r.t[r.p] = i } } else r.t[r.p] = t + r.xs0;
                                        else r.t[r.p] = r.e;
                                        else r.setRatio(e);
                                        r = r._next } }, e._enableTransforms = function(e) { this._transform = this._transform || Ze(this._target, S, !0), this._transformType = this._transform.svg && Ce || !e && 3 !== this._transformType ? 2 : 3 }; var it = function(e) { this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0) };
                        e._addLazySet = function(e, t, i) { var n = this._firstPT = new xe(e, t, 0, 0, this._firstPT, 2);
                            n.e = i, n.setRatio = it, n.data = this }, e._linkCSSP = function(e, t, i, n) { return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next : this._firstPT === e && (this._firstPT = e._next, n = !0), i ? i._next = e : n || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = i), e }, e._mod = function(e) { for (var t = this._firstPT; t;) "function" == typeof e[t.p] && (t.r = e[t.p]), t = t._next }, e._kill = function(e) { var t, i, n, r = e; if (e.autoAlpha || e.alpha) { for (i in r = {}, e) r[i] = e[i];
                                r.opacity = 1, r.autoAlpha && (r.visibility = 1) } for (e.className && (t = this._classNamePT) && ((n = t.xfirst) && n._prev ? this._linkCSSP(n._prev, t._next, n._prev._prev) : n === this._firstPT && (this._firstPT = t._next), t._next && this._linkCSSP(t._next, t._next._next, n._prev), this._classNamePT = null), t = this._firstPT; t;) t.plugin && t.plugin !== i && t.plugin._kill && (t.plugin._kill(e), i = t.plugin), t = t._next; return a.prototype._kill.call(this, r) }; var nt = function e(t, i, n) { var r, a, o, s; if (t.slice)
                                for (a = t.length; - 1 < --a;) e(t[a], i, n);
                            else
                                for (a = (r = t.childNodes).length; - 1 < --a;) s = (o = r[a]).type, o.style && (i.push(ae(o)), n && n.push(o)), 1 !== s && 9 !== s && 11 !== s || !o.childNodes.length || e(o, i, n) }; return k.cascadeTo = function(e, t, i) { var n, r, a, o, s = z.to(e, t, i),
                                l = [s],
                                c = [],
                                h = [],
                                u = [],
                                d = z._internals.reservedProps; for (e = s._targets || s.target, nt(e, c, u), s.render(t, !0, !0), nt(e, h), s.render(0, !0, !0), s._enabled(!0), n = u.length; - 1 < --n;)
                                if ((r = oe(u[n], c[n], h[n])).firstMPT) { for (a in r = r.difs, i) d[a] && (r[a] = i[a]); for (a in o = {}, r) o[a] = c[n][a];
                                    l.push(z.fromTo(u[n], t, o, r)) }
                            return l }, a.activate([k]), k }, !0), t = at._gsDefine.plugin({ propName: "roundProps", version: "1.7.0", priority: -1, API: 2, init: function(e, t, i) { return this._tween = i, !0 } }), l = function(t) { var i = t < 1 ? Math.pow(10, (t + "").length - 2) : 1; return function(e) { return (Math.round(e / t) * t * i | 0) / i } }, c = function(e, t) { for (; e;) e.f || e.blob || (e.m = t || Math.round), e = e._next }, (n = t.prototype)._onInitAllProps = function() { var e, t, i, n, r = this._tween,
                            a = r.vars.roundProps,
                            o = {},
                            s = r._propLookup.roundProps; if ("object" !== rt(a) || a.push)
                            for ("string" == typeof a && (a = a.split(",")), i = a.length; - 1 < --i;) o[a[i]] = Math.round;
                        else
                            for (n in a) o[n] = l(a[n]); for (n in o)
                            for (e = r._firstPT; e;) t = e._next, e.pg ? e.t._mod(o) : e.n === n && (2 === e.f && e.t ? c(e.t._firstPT, o[n]) : (this._add(e.t, n, e.s, e.c, o[n]), t && (t._prev = e._prev), e._prev ? e._prev._next = t : r._firstPT === e && (r._firstPT = t), e._next = e._prev = null, r._propLookup[n] = s)), e = t; return !1 }, n._add = function(e, t, i, n, r) { this._addTween(e, t, i, i + n, t, r || Math.round), this._overwriteProps.push(t) }, at._gsDefine.plugin({ propName: "attr", API: 2, version: "0.6.1", init: function(e, t, i, n) { var r, a; if ("function" != typeof e.setAttribute) return !1; for (r in t) "function" == typeof(a = t[r]) && (a = a(n, e)), this._addTween(e, "setAttribute", e.getAttribute(r) + "", a + "", r, !1, r), this._overwriteProps.push(r); return !0 } }), at._gsDefine.plugin({ propName: "directionalRotation", version: "0.3.1", API: 2, init: function(e, t, i, n) { "object" !== rt(t) && (t = { rotation: t }), this.finals = {}; var r, a, o, s, l, c, h = !0 === t.useRadians ? 2 * Math.PI : 360; for (r in t) "useRadians" !== r && ("function" == typeof(s = t[r]) && (s = s(n, e)), a = (c = (s + "").split("_"))[0], o = parseFloat("function" != typeof e[r] ? e[r] : e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), l = (s = this.finals[r] = "string" == typeof a && "=" === a.charAt(1) ? o + parseInt(a.charAt(0) + "1", 10) * Number(a.substr(2)) : Number(a) || 0) - o, c.length && (-1 !== (a = c.join("_")).indexOf("short") && (l %= h) !== l % (h / 2) && (l = l < 0 ? l + h : l - h), -1 !== a.indexOf("_cw") && l < 0 ? l = (l + 9999999999 * h) % h - (l / h | 0) * h : -1 !== a.indexOf("ccw") && 0 < l && (l = (l - 9999999999 * h) % h - (l / h | 0) * h)), (1e-6 < l || l < -1e-6) && (this._addTween(e, r, o, o + l, r), this._overwriteProps.push(r))); return !0 }, set: function(e) { var t; if (1 !== e) this._super.setRatio.call(this, e);
                            else
                                for (t = this._firstPT; t;) t.f ? t.t[t.p](this.finals[t.p]) : t.t[t.p] = this.finals[t.p], t = t._next } })._autoCSS = !0, at._gsDefine("easing.Back", ["easing.Ease"], function(g) { var i, n, t, e, r = at.GreenSockGlobals || at,
                            a = r.com.greensock,
                            o = 2 * Math.PI,
                            s = Math.PI / 2,
                            l = a._class,
                            c = function(e, t) { var i = l("easing." + e, function() {}, !0),
                                    n = i.prototype = new g; return n.constructor = i, n.getRatio = t, i },
                            h = g.register || function() {},
                            u = function(e, t, i, n, r) { var a = l("easing." + e, { easeOut: new t, easeIn: new i, easeInOut: new n }, !0); return h(a, e), a },
                            v = function(e, t, i) { this.t = e, this.v = t, i && (((this.next = i).prev = this).c = i.v - t, this.gap = i.t - e) },
                            d = function(e, t) { var i = l("easing." + e, function(e) { this._p1 = e || 0 === e ? e : 1.70158, this._p2 = 1.525 * this._p1 }, !0),
                                    n = i.prototype = new g; return n.constructor = i, n.getRatio = t, n.config = function(e) { return new i(e) }, i },
                            p = u("Back", d("BackOut", function(e) { return (e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1 }), d("BackIn", function(e) { return e * e * ((this._p1 + 1) * e - this._p1) }), d("BackInOut", function(e) { return (e *= 2) < 1 ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2) })),
                            f = l("easing.SlowMo", function(e, t, i) { t = t || 0 === t ? t : .7, null == e ? e = .7 : 1 < e && (e = 1), this._p = 1 !== e ? t : 0, this._p1 = (1 - e) / 2, this._p2 = e, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i }, !0),
                            m = f.prototype = new g; return m.constructor = f, m.getRatio = function(e) { var t = e + (.5 - e) * this._p; return e < this._p1 ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e : t - (e = 1 - e / this._p1) * e * e * e * t : e > this._p3 ? this._calcEnd ? 1 === e ? 0 : 1 - (e = (e - this._p3) / this._p1) * e : t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e : this._calcEnd ? 1 : t }, f.ease = new f(.7, .7), m.config = f.config = function(e, t, i) { return new f(e, t, i) }, (m = (i = l("easing.SteppedEase", function(e, t) { e = e || 1, this._p1 = 1 / e, this._p2 = e + (t ? 0 : 1), this._p3 = t ? 1 : 0 }, !0)).prototype = new g).constructor = i, m.getRatio = function(e) { return e < 0 ? e = 0 : 1 <= e && (e = .999999999), ((this._p2 * e | 0) + this._p3) * this._p1 }, m.config = i.config = function(e, t) { return new i(e, t) }, (m = (n = l("easing.ExpoScaleEase", function(e, t, i) { this._p1 = Math.log(t / e), this._p2 = t - e, this._p3 = e, this._ease = i }, !0)).prototype = new g).constructor = n, m.getRatio = function(e) { return this._ease && (e = this._ease.getRatio(e)), (this._p3 * Math.exp(this._p1 * e) - this._p3) / this._p2 }, m.config = n.config = function(e, t, i) { return new n(e, t, i) }, (m = (t = l("easing.RoughEase", function(e) { for (var t, i, n, r, a, o, s = (e = e || {}).taper || "none", l = [], c = 0, h = 0 | (e.points || 20), u = h, d = !1 !== e.randomize, p = !0 === e.clamp, f = e.template instanceof g ? e.template : null, m = "number" == typeof e.strength ? .4 * e.strength : .4; - 1 < --u;) t = d ? Math.random() : 1 / h * u, i = f ? f.getRatio(t) : t, n = "none" === s ? m : "out" === s ? (r = 1 - t) * r * m : "in" === s ? t * t * m : t < .5 ? (r = 2 * t) * r * .5 * m : (r = 2 * (1 - t)) * r * .5 * m, d ? i += Math.random() * n - .5 * n : u % 2 ? i += .5 * n : i -= .5 * n, p && (1 < i ? i = 1 : i < 0 && (i = 0)), l[c++] = { x: t, y: i }; for (l.sort(function(e, t) { return e.x - t.x }), o = new v(1, 1, null), u = h; - 1 < --u;) a = l[u], o = new v(a.x, a.y, o);
                            this._prev = new v(0, 0, 0 !== o.t ? o : o.next) }, !0)).prototype = new g).constructor = t, m.getRatio = function(e) { var t = this._prev; if (e > t.t) { for (; t.next && e >= t.t;) t = t.next;
                                t = t.prev } else
                                for (; t.prev && e <= t.t;) t = t.prev; return (this._prev = t).v + (e - t.t) / t.gap * t.c }, m.config = function(e) { return new t(e) }, t.ease = new t, u("Bounce", c("BounceOut", function(e) { return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375 }), c("BounceIn", function(e) { return (e = 1 - e) < 1 / 2.75 ? 1 - 7.5625 * e * e : e < 2 / 2.75 ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : e < 2.5 / 2.75 ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375) }), c("BounceInOut", function(e) { var t = e < .5; return (e = t ? 1 - 2 * e : 2 * e - 1) < 1 / 2.75 ? e *= 7.5625 * e : e = e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, t ? .5 * (1 - e) : .5 * e + .5 })), u("Circ", c("CircOut", function(e) { return Math.sqrt(1 - (e -= 1) * e) }), c("CircIn", function(e) { return -(Math.sqrt(1 - e * e) - 1) }), c("CircInOut", function(e) { return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1) })), u("Elastic", (e = function(e, t, i) { var n = l("easing." + e, function(e, t) { this._p1 = 1 <= e ? e : 1, this._p2 = (t || i) / (e < 1 ? e : 1), this._p3 = this._p2 / o * (Math.asin(1 / this._p1) || 0), this._p2 = o / this._p2 }, !0),
                                r = n.prototype = new g; return r.constructor = n, r.getRatio = t, r.config = function(e, t) { return new n(e, t) }, n })("ElasticOut", function(e) { return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * this._p2) + 1 }, .3), e("ElasticIn", function(e) { return -this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) }, .3), e("ElasticInOut", function(e) { return (e *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * .5 + 1 }, .45)), u("Expo", c("ExpoOut", function(e) { return 1 - Math.pow(2, -10 * e) }), c("ExpoIn", function(e) { return Math.pow(2, 10 * (e - 1)) - .001 }), c("ExpoInOut", function(e) { return (e *= 2) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1))) })), u("Sine", c("SineOut", function(e) { return Math.sin(e * s) }), c("SineIn", function(e) { return 1 - Math.cos(e * s) }), c("SineInOut", function(e) { return -.5 * (Math.cos(Math.PI * e) - 1) })), l("easing.EaseLookup", { find: function(e) { return g.map[e] } }, !0), h(r.SlowMo, "SlowMo", "ease,"), h(t, "RoughEase", "ease,"), h(i, "SteppedEase", "ease,"), p }, !0) }), at._gsDefine && at._gsQueue.pop()(),
                function(p, f) { var m = {},
                        r = p.document,
                        g = p.GreenSockGlobals = p.GreenSockGlobals || p,
                        e = g[f]; if (e) return void 0 !== ae && ae.exports && (ae.exports = e); var t, i, n, v, M, a, o, y = function(e) { var t, i = e.split("."),
                                n = g; for (t = 0; t < i.length; t++) n[i[t]] = n = n[i[t]] || {}; return n },
                        u = y("com.greensock"),
                        b = 1e-8,
                        l = function(e) { var t, i = [],
                                n = e.length; for (t = 0; t !== n; i.push(e[t++])); return i },
                        _ = function() {},
                        x = (a = Object.prototype.toString, o = a.call([]), function(e) { return null != e && (e instanceof Array || "object" === rt(e) && !!e.push && a.call(e) === o) }),
                        T = {},
                        s = function s(l, c, h, u) { this.sc = T[l] ? T[l].sc : [], (T[l] = this).gsClass = null, this.func = h; var d = [];
                            this.check = function(e) { for (var t, i, n, r, a = c.length, o = a; - 1 < --a;)(t = T[c[a]] || new s(c[a], [])).gsClass ? (d[a] = t.gsClass, o--) : e && t.sc.push(this); if (0 === o && h) { if (n = (i = ("com.greensock." + l).split(".")).pop(), r = y(i.join("."))[n] = this.gsClass = h.apply(h, d), u)
                                        if (g[n] = m[n] = r, void 0 !== ae && ae.exports)
                                            if (l === f)
                                                for (a in ae.exports = m[f] = r, m) r[a] = m[a];
                                            else m[f] && (m[f][n] = r);
                                    else "function" == typeof define && define.amd && define((p.GreenSockAMDPath ? p.GreenSockAMDPath + "/" : "") + l.split(".").pop(), [], function() { return r }); for (a = 0; a < this.sc.length; a++) this.sc[a].check() } }, this.check(!0) },
                        c = p._gsDefine = function(e, t, i, n) { return new s(e, t, i, n) },
                        d = u._class = function(e, t, i) { return t = t || function() {}, c(e, [], function() { return t }, i), t };
                    c.globals = g; var h = [0, 0, 1, 1],
                        w = d("easing.Ease", function(e, t, i, n) { this._func = e, this._type = i || 0, this._power = n || 0, this._params = t ? h.concat(t) : h }, !0),
                        S = w.map = {},
                        E = w.register = function(e, t, i, n) { for (var r, a, o, s, l = t.split(","), c = l.length, h = (i || "easeIn,easeOut,easeInOut").split(","); - 1 < --c;)
                                for (a = l[c], r = n ? d("easing." + a, null, !0) : u.easing[a] || {}, o = h.length; - 1 < --o;) s = h[o], S[a + "." + s] = S[s + a] = r[s] = e.getRatio ? e : e[s] || new e }; for ((n = w.prototype)._calcEnd = !1, n.getRatio = function(e) { if (this._func) return this._params[0] = e, this._func.apply(null, this._params); var t = this._type,
                                i = this._power,
                                n = 1 === t ? 1 - e : 2 === t ? e : e < .5 ? 2 * e : 2 * (1 - e); return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === t ? 1 - n : 2 === t ? n : e < .5 ? n / 2 : 1 - n / 2 }, i = (t = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; - 1 < --i;) n = t[i] + ",Power" + i, E(new w(null, null, 1, i), n, "easeOut", !0), E(new w(null, null, 2, i), n, "easeIn" + (0 === i ? ",easeNone" : "")), E(new w(null, null, 3, i), n, "easeInOut");
                    S.linear = u.easing.Linear.easeIn, S.swing = u.easing.Quad.easeInOut; var P = d("events.EventDispatcher", function(e) { this._listeners = {}, this._eventTarget = e || this });
                    (n = P.prototype).addEventListener = function(e, t, i, n, r) { r = r || 0; var a, o, s = this._listeners[e],
                            l = 0; for (this !== v || M || v.wake(), null == s && (this._listeners[e] = s = []), o = s.length; - 1 < --o;)(a = s[o]).c === t && a.s === i ? s.splice(o, 1) : 0 === l && a.pr < r && (l = o + 1);
                        s.splice(l, 0, { c: t, s: i, up: n, pr: r }) }, n.removeEventListener = function(e, t) { var i, n = this._listeners[e]; if (n)
                            for (i = n.length; - 1 < --i;)
                                if (n[i].c === t) return void n.splice(i, 1) }, n.dispatchEvent = function(e) { var t, i, n, r = this._listeners[e]; if (r)
                            for (1 < (t = r.length) && (r = r.slice(0)), i = this._eventTarget; - 1 < --t;)(n = r[t]) && (n.up ? n.c.call(n.s || i, { type: e, target: i }) : n.c.call(n.s || i)) }; var A = p.requestAnimationFrame,
                        C = p.cancelAnimationFrame,
                        L = Date.now || function() { return (new Date).getTime() },
                        R = L(); for (i = (t = ["ms", "moz", "webkit", "o"]).length; - 1 < --i && !A;) A = p[t[i] + "RequestAnimationFrame"], C = p[t[i] + "CancelAnimationFrame"] || p[t[i] + "CancelRequestAnimationFrame"];
                    d("Ticker", function(e, t) { var a, o, s, l, c, h = this,
                            u = L(),
                            i = !(!1 === t || !A) && "auto",
                            d = 500,
                            p = 33,
                            n = function e(t) { var i, n, r = L() - R;
                                d < r && (u += r - p), R += r, h.time = (R - u) / 1e3, i = h.time - c, (!a || 0 < i || !0 === t) && (h.frame++, c += i + (l <= i ? .004 : l - i), n = !0), !0 !== t && (s = o(e)), n && h.dispatchEvent("tick") };
                        P.call(h), h.time = h.frame = 0, h.tick = function() { n(!0) }, h.lagSmoothing = function(e, t) { if (!arguments.length) return d < 1e8;
                            d = e || 1e8, p = Math.min(t, d, 0) }, h.sleep = function() { null != s && (i && C ? C(s) : clearTimeout(s), o = _, s = null, h === v && (M = !1)) }, h.wake = function(e) { null !== s ? h.sleep() : e ? u += -R + (R = L()) : 10 < h.frame && (R = L() - d + 5), o = 0 === a ? _ : i && A ? A : function(e) { return setTimeout(e, 1e3 * (c - h.time) + 1 | 0) }, h === v && (M = !0), n(2) }, h.fps = function(e) { if (!arguments.length) return a;
                            l = 1 / ((a = e) || 60), c = this.time + l, h.wake() }, h.useRAF = function(e) { if (!arguments.length) return i;
                            h.sleep(), i = e, h.fps(a) }, h.fps(e), setTimeout(function() { "auto" === i && h.frame < 5 && "hidden" !== (r || {}).visibilityState && h.useRAF(!1) }, 1500) }), (n = u.Ticker.prototype = new u.events.EventDispatcher).constructor = u.Ticker; var H = d("core.Animation", function(e, t) { if (this.vars = t = t || {}, this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = !!t.immediateRender, this.data = t.data, this._reversed = !!t.reversed, K) { M || v.wake(); var i = this.vars.useFrames ? J : K;
                            i.add(this, i._time), this.vars.paused && this.paused(!0) } });
                    v = H.ticker = new u.Ticker, (n = H.prototype)._dirty = n._gc = n._initted = n._paused = !1, n._totalTime = n._time = 0, n._rawPrevTime = -1, n._next = n._last = n._onUpdate = n._timeline = n.timeline = null, n._paused = !1;! function e() { M && 2e3 < L() - R && ("hidden" !== (r || {}).visibilityState || !v.lagSmoothing()) && v.wake(); var t = setTimeout(e, 2e3);
                        t.unref && t.unref() }(), n.play = function(e, t) { return null != e && this.seek(e, t), this.reversed(!1).paused(!1) }, n.pause = function(e, t) { return null != e && this.seek(e, t), this.paused(!0) }, n.resume = function(e, t) { return null != e && this.seek(e, t), this.paused(!1) }, n.seek = function(e, t) { return this.totalTime(Number(e), !1 !== t) }, n.restart = function(e, t) { return this.reversed(!1).paused(!1).totalTime(e ? -this._delay : 0, !1 !== t, !0) }, n.reverse = function(e, t) { return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1) }, n.render = function(e, t, i) {}, n.invalidate = function() { return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this }, n.isActive = function() { var e, t = this._timeline,
                            i = this._startTime; return !t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime(!0)) >= i && e < i + this.totalDuration() / this._timeScale - b }, n._enabled = function(e, t) { return M || v.wake(), this._gc = !e, this._active = this.isActive(), !0 !== t && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)), !1 }, n._kill = function(e, t) { return this._enabled(!1, !1) }, n.kill = function(e, t) { return this._kill(e, t), this }, n._uncache = function(e) { for (var t = e ? this : this.timeline; t;) t._dirty = !0, t = t.timeline; return this }, n._swapSelfInParams = function(e) { for (var t = e.length, i = e.concat(); - 1 < --t;) "{self}" === e[t] && (i[t] = this); return i }, n._callback = function(e) { var t = this.vars,
                            i = t[e],
                            n = t[e + "Params"],
                            r = t[e + "Scope"] || t.callbackScope || this; switch (n ? n.length : 0) {
                            case 0:
                                i.call(r); break;
                            case 1:
                                i.call(r, n[0]); break;
                            case 2:
                                i.call(r, n[0], n[1]); break;
                            default:
                                i.apply(r, n) } }, n.eventCallback = function(e, t, i, n) { if ("on" === (e || "").substr(0, 2)) { var r = this.vars; if (1 === arguments.length) return r[e];
                            null == t ? delete r[e] : (r[e] = t, r[e + "Params"] = x(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[e + "Scope"] = n), "onUpdate" === e && (this._onUpdate = t) } return this }, n.delay = function(e) { return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay }, n.duration = function(e) { return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && 0 < this._time && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration) }, n.totalDuration = function(e) { return this._dirty = !1, arguments.length ? this.duration(e) : this._totalDuration }, n.time = function(e, t) { return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration : e, t)) : this._time }, n.totalTime = function(e, t, i) { if (M || v.wake(), !arguments.length) return this._totalTime; if (this._timeline) { if (e < 0 && !i && (e += this.totalDuration()), this._timeline.smoothChildTiming) { this._dirty && this.totalDuration(); var n = this._totalDuration,
                                    r = this._timeline; if (n < e && !i && (e = n), this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - e : e) / this._timeScale, r._dirty || this._uncache(!1), r._timeline)
                                    for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline }
                            this._gc && this._enabled(!0, !1), this._totalTime === e && 0 !== this._duration || (I.length && $(), this.render(e, t, !1), I.length && $()) } return this }, n.progress = n.totalProgress = function(e, t) { var i = this.duration(); return arguments.length ? this.totalTime(i * e, t) : i ? this._time / i : this.ratio }, n.startTime = function(e) { return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime }, n.endTime = function(e) { return this._startTime + (0 != e ? this.totalDuration() : this.duration()) / this._timeScale }, n.timeScale = function(e) { if (!arguments.length) return this._timeScale; var t, i; for (e = e || b, this._timeline && this._timeline.smoothChildTiming && (i = (t = this._pauseTime) || 0 === t ? t : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / e), this._timeScale = e, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline; return this }, n.reversed = function(e) { return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed }, n.paused = function(e) { if (!arguments.length) return this._paused; var t, i, n = this._timeline; return e != this._paused && n && (M || e || v.wake(), i = (t = n.rawTime()) - this._pauseTime, !e && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = e ? t : null, this._paused = e, this._active = this.isActive(), !e && 0 !== i && this._initted && this.duration() && (t = n.smoothChildTiming ? this._totalTime : (t - this._startTime) / this._timeScale, this.render(t, t === this._totalTime, !0))), this._gc && !e && this._enabled(!0, !1), this }; var O = d("core.SimpleTimeline", function(e) { H.call(this, 0, e), this.autoRemoveChildren = this.smoothChildTiming = !0 });
                    (n = O.prototype = new H).constructor = O, n.kill()._gc = !1, n._first = n._last = n._recent = null, n._sortChildren = !1, n.add = n.insert = function(e, t, i, n) { var r, a; if (e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = this.rawTime() - (e._timeline.rawTime() - e._pauseTime)), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), r = this._last, this._sortChildren)
                            for (a = e._startTime; r && r._startTime > a;) r = r._prev; return r ? (e._next = r._next, r._next = e) : (e._next = this._first, this._first = e), e._next ? e._next._prev = e : this._last = e, e._prev = r, this._recent = e, this._timeline && this._uncache(!0), this }, n._remove = function(e, t) { return e.timeline === this && (t || e._enabled(!1, !0), e._prev ? e._prev._next = e._next : this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev : this._last === e && (this._last = e._prev), e._next = e._prev = e.timeline = null, e === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this }, n.render = function(e, t, i) { var n, r = this._first; for (this._totalTime = this._time = this._rawPrevTime = e; r;) n = r._next, (r._active || e >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)), r = n }, n.rawTime = function() { return M || v.wake(), this._totalTime }; var G = d("TweenLite", function(e, t, i) { if (H.call(this, t, i), this.render = G.prototype.render, null == e) throw "Cannot tween a null target.";
                            this.target = e = "string" != typeof e ? e : G.selector(e) || e; var n, r, a, o = e.jquery || e.length && e !== p && e[0] && (e[0] === p || e[0].nodeType && e[0].style && !e.nodeType),
                                s = this.vars.overwrite; if (this._overwrite = s = null == s ? Z[G.defaultOverwrite] : "number" == typeof s ? s >> 0 : Z[s], (o || e instanceof Array || e.push && x(e)) && "number" != typeof e[0])
                                for (this._targets = a = l(e), this._propLookup = [], this._siblings = [], n = 0; n < a.length; n++)(r = a[n]) ? "string" != typeof r ? r.length && r !== p && r[0] && (r[0] === p || r[0].nodeType && r[0].style && !r.nodeType) ? (a.splice(n--, 1), this._targets = a = a.concat(l(r))) : (this._siblings[n] = ee(r, this, !1), 1 === s && 1 < this._siblings[n].length && ie(r, this, null, 1, this._siblings[n])) : "string" == typeof(r = a[n--] = G.selector(r)) && a.splice(n + 1, 1) : a.splice(n--, 1);
                            else this._propLookup = {}, this._siblings = ee(e, this, !1), 1 === s && 1 < this._siblings.length && ie(e, this, null, 1, this._siblings);
                            (this.vars.immediateRender || 0 === t && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -b, this.render(Math.min(0, -this._delay))) }, !0),
                        D = function(e) { return e && e.length && e !== p && e[0] && (e[0] === p || e[0].nodeType && e[0].style && !e.nodeType) };
                    (n = G.prototype = new H).constructor = G, n.kill()._gc = !1, n.ratio = 0, n._firstPT = n._targets = n._overwrittenProps = n._startAt = null, n._notifyPluginsOfEnabled = n._lazy = !1, G.version = "2.1.2", G.defaultEase = n._ease = new w(null, null, 1, 1), G.defaultOverwrite = "auto", G.ticker = v, G.autoSleep = 120, G.lagSmoothing = function(e, t) { v.lagSmoothing(e, t) }, G.selector = p.$ || p.jQuery || function(e) { var t = p.$ || p.jQuery; return t ? (G.selector = t)(e) : (r || (r = p.document), r ? r.querySelectorAll ? r.querySelectorAll(e) : r.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e) }; var I = [],
                        B = {},
                        N = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                        F = /[\+-]=-?[\.\d]/,
                        z = function(e) { for (var t, i = this._firstPT; i;) t = i.blob ? 1 === e && null != this.end ? this.end : e ? this.join("") : this.start : i.c * e + i.s, i.m ? t = i.m.call(this._tween, t, this._target || i.t, this._tween) : t < 1e-6 && -1e-6 < t && !i.blob && (t = 0), i.f ? i.fp ? i.t[i.p](i.fp, t) : i.t[i.p](t) : i.t[i.p] = t, i = i._next },
                        k = function(e) { return (1e3 * e | 0) / 1e3 + "" },
                        U = function(e, t, i, n) { var r, a, o, s, l, c, h, u = [],
                                d = 0,
                                p = "",
                                f = 0; for (u.start = e, u.end = t, e = u[0] = e + "", t = u[1] = t + "", i && (i(u), e = u[0], t = u[1]), u.length = 0, r = e.match(N) || [], a = t.match(N) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), l = a.length, s = 0; s < l; s++) h = a[s], p += (c = t.substr(d, t.indexOf(h, d) - d)) || !s ? c : ",", d += c.length, f ? f = (f + 1) % 5 : "rgba(" === c.substr(-5) && (f = 1), h === r[s] || r.length <= s ? p += h : (p && (u.push(p), p = ""), o = parseFloat(r[s]), u.push(o), u._firstPT = { _next: u._firstPT, t: u, p: u.length - 1, s: o, c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - o) || 0, f: 0, m: f && f < 4 ? Math.round : k }), d += h.length; return (p += t.substr(d)) && u.push(p), u.setRatio = z, F.test(t) && (u.end = null), u },
                        V = function(e, t, i, n, r, a, o, s, l) { "function" == typeof n && (n = n(l || 0, e)); var c = rt(e[t]),
                                h = "function" !== c ? "" : t.indexOf("set") || "function" != typeof e["get" + t.substr(3)] ? t : "get" + t.substr(3),
                                u = "get" !== i ? i : h ? o ? e[h](o) : e[h]() : e[t],
                                d = "string" == typeof n && "=" === n.charAt(1),
                                p = { t: e, p: t, s: u, f: "function" === c, pg: 0, n: r || t, m: a ? "function" == typeof a ? a : Math.round : 0, pr: 0, c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - u || 0 }; if (("number" != typeof u || "number" != typeof n && !d) && (o || isNaN(u) || !d && isNaN(n) || "boolean" == typeof u || "boolean" == typeof n ? (p.fp = o, p = { t: U(u, d ? parseFloat(p.s) + p.c + (p.s + "").replace(/[0-9\-\.]/g, "") : n, s || G.defaultStringFilter, p), p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: r || t, pr: 0, m: 0 }) : (p.s = parseFloat(u), d || (p.c = parseFloat(n) - p.s || 0))), p.c) return (p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p },
                        j = G._internals = { isArray: x, isSelector: D, lazyTweens: I, blobDif: U },
                        W = G._plugins = {},
                        X = j.tweenLookup = {},
                        Y = 0,
                        q = j.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1, id: 1, yoyoEase: 1, stagger: 1 },
                        Z = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, true: 1, false: 0 },
                        J = H._rootFramesTimeline = new O,
                        K = H._rootTimeline = new O,
                        Q = 30,
                        $ = j.lazyRender = function() { var e, t, i = I.length; for (B = {}, e = 0; e < i; e++)(t = I[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                            I.length = 0 };
                    K._startTime = v.time, J._startTime = v.frame, K._active = J._active = !0, setTimeout($, 1), H._updateRoot = G.render = function() { var e, t, i; if (I.length && $(), K.render((v.time - K._startTime) * K._timeScale, !1, !1), J.render((v.frame - J._startTime) * J._timeScale, !1, !1), I.length && $(), v.frame >= Q) { for (i in Q = v.frame + (parseInt(G.autoSleep, 10) || 120), X) { for (e = (t = X[i].tweens).length; - 1 < --e;) t[e]._gc && t.splice(e, 1);
                                0 === t.length && delete X[i] } if ((!(i = K._first) || i._paused) && G.autoSleep && !J._first && 1 === v._listeners.tick.length) { for (; i && i._paused;) i = i._next;
                                i || v.sleep() } } }, v.addEventListener("tick", H._updateRoot); var ee = function(e, t, i) { var n, r, a = e._gsTweenID; if (X[a || (e._gsTweenID = a = "t" + Y++)] || (X[a] = { target: e, tweens: [] }), t && ((n = X[a].tweens)[r = n.length] = t, i))
                                for (; - 1 < --r;) n[r] === t && n.splice(r, 1); return X[a].tweens },
                        te = function(e, t, i, n) { var r, a, o = e.vars.onOverwrite; return o && (r = o(e, t, i, n)), (o = G.onOverwrite) && (a = o(e, t, i, n)), !1 !== r && !1 !== a },
                        ie = function(e, t, i, n, r) { var a, o, s, l; if (1 === n || 4 <= n) { for (l = r.length, a = 0; a < l; a++)
                                    if ((s = r[a]) !== t) s._gc || s._kill(null, e, t) && (o = !0);
                                    else if (5 === n) break; return o } var c, h = t._startTime + b,
                                u = [],
                                d = 0,
                                p = 0 === t._duration; for (a = r.length; - 1 < --a;)(s = r[a]) === t || s._gc || s._paused || (s._timeline !== t._timeline ? (c = c || ne(t, 0, p), 0 === ne(s, c, p) && (u[d++] = s)) : s._startTime <= h && s._startTime + s.totalDuration() / s._timeScale > h && ((p || !s._initted) && h - s._startTime <= 2e-8 || (u[d++] = s))); for (a = d; - 1 < --a;)
                                if (l = (s = u[a])._firstPT, 2 === n && s._kill(i, e, t) && (o = !0), 2 !== n || !s._firstPT && s._initted && l) { if (2 !== n && !te(s, t)) continue;
                                    s._enabled(!1, !1) && (o = !0) }
                            return o },
                        ne = function(e, t, i) { for (var n = e._timeline, r = n._timeScale, a = e._startTime; n._timeline;) { if (a += n._startTime, r *= n._timeScale, n._paused) return -100;
                                n = n._timeline } return t < (a /= r) ? a - t : i && a === t || !e._initted && a - t < 2e-8 ? b : (a += e.totalDuration() / e._timeScale / r) > t + b ? 0 : a - t - b };
                    n._init = function() { var e, t, i, n, r, a, o = this.vars,
                            s = this._overwrittenProps,
                            l = this._duration,
                            c = !!o.immediateRender,
                            h = o.ease,
                            u = this._startAt; if (o.startAt) { for (n in u && (u.render(-1, !0), u.kill()), r = {}, o.startAt) r[n] = o.startAt[n]; if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = c && !1 !== o.lazy, r.startAt = r.delay = null, r.onUpdate = o.onUpdate, r.onUpdateParams = o.onUpdateParams, r.onUpdateScope = o.onUpdateScope || o.callbackScope || this, this._startAt = G.to(this.target || {}, 0, r), c)
                                if (0 < this._time) this._startAt = null;
                                else if (0 !== l) return } else if (o.runBackwards && 0 !== l)
                            if (u) u.render(-1, !0), u.kill(), this._startAt = null;
                            else { for (n in 0 !== this._time && (c = !1), i = {}, o) q[n] && "autoCSS" !== n || (i[n] = o[n]); if (i.overwrite = 0, i.data = "isFromStart", i.lazy = c && !1 !== o.lazy, i.immediateRender = c, this._startAt = G.to(this.target, 0, i), c) { if (0 === this._time) return } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null) }
                        if (this._ease = h = h ? h instanceof w ? h : "function" == typeof h ? new w(h, o.easeParams) : S[h] || G.defaultEase : G.defaultEase, o.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, o.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                            for (a = this._targets.length, e = 0; e < a; e++) this._initProps(this._targets[e], this._propLookup[e] = {}, this._siblings[e], s ? s[e] : null, e) && (t = !0);
                        else t = this._initProps(this.target, this._propLookup, this._siblings, s, 0); if (t && G._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), o.runBackwards)
                            for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                        this._onUpdate = o.onUpdate, this._initted = !0 }, n._initProps = function(e, t, i, n, r) { var a, o, s, l, c, h; if (null == e) return !1; for (a in B[e._gsTweenID] && $(), this.vars.css || e.style && e !== p && e.nodeType && W.css && !1 !== this.vars.autoCSS && function(e, t) { var i, n = {}; for (i in e) q[i] || i in t && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!W[i] || W[i] && W[i]._autoCSS) || (n[i] = e[i], delete e[i]);
                                e.css = n }(this.vars, e), this.vars)
                            if (h = this.vars[a], q[a]) h && (h instanceof Array || h.push && x(h)) && -1 !== h.join("").indexOf("{self}") && (this.vars[a] = h = this._swapSelfInParams(h, this));
                            else if (W[a] && (l = new W[a])._onInitTween(e, this.vars[a], this, r)) { for (this._firstPT = c = { _next: this._firstPT, t: l, p: "setRatio", s: 0, c: 1, f: 1, n: a, pg: 1, pr: l._priority, m: 0 }, o = l._overwriteProps.length; - 1 < --o;) t[l._overwriteProps[o]] = this._firstPT;
                            (l._priority || l._onInitAllProps) && (s = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), c._next && (c._next._prev = c) } else t[a] = V.call(this, e, a, "get", h, a, 0, null, this.vars.stringFilter, r); return n && this._kill(n, e) ? this._initProps(e, t, i, n, r) : 1 < this._overwrite && this._firstPT && 1 < i.length && ie(e, this, t, this._overwrite, i) ? (this._kill(t, e), this._initProps(e, t, i, n, r)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (B[e._gsTweenID] = !0), s) }, n.render = function(e, t, i) { var n, r, a, o, s = this,
                            l = s._time,
                            c = s._duration,
                            h = s._rawPrevTime; if (c - b <= e && 0 <= e) s._totalTime = s._time = c, s.ratio = s._ease._calcEnd ? s._ease.getRatio(1) : 1, s._reversed || (n = !0, r = "onComplete", i = i || s._timeline.autoRemoveChildren), 0 === c && (s._initted || !s.vars.lazy || i) && (s._startTime === s._timeline._duration && (e = 0), (h < 0 || e <= 0 && -b <= e || h === b && "isPause" !== s.data) && h !== e && (i = !0, b < h && (r = "onReverseComplete")), s._rawPrevTime = o = !t || e || h === e ? e : b);
                        else if (e < b) s._totalTime = s._time = 0, s.ratio = s._ease._calcEnd ? s._ease.getRatio(0) : 0, (0 !== l || 0 === c && 0 < h) && (r = "onReverseComplete", n = s._reversed), -b < e ? e = 0 : e < 0 && (s._active = !1, 0 === c && (s._initted || !s.vars.lazy || i) && (0 <= h && (h !== b || "isPause" !== s.data) && (i = !0), s._rawPrevTime = o = !t || e || h === e ? e : b)), (!s._initted || s._startAt && s._startAt.progress()) && (i = !0);
                        else if (s._totalTime = s._time = e, s._easeType) { var u = e / c,
                                d = s._easeType,
                                p = s._easePower;
                            (1 === d || 3 === d && .5 <= u) && (u = 1 - u), 3 === d && (u *= 2), 1 === p ? u *= u : 2 === p ? u *= u * u : 3 === p ? u *= u * u * u : 4 === p && (u *= u * u * u * u), s.ratio = 1 === d ? 1 - u : 2 === d ? u : e / c < .5 ? u / 2 : 1 - u / 2 } else s.ratio = s._ease.getRatio(e / c); if (s._time !== l || i) { if (!s._initted) { if (s._init(), !s._initted || s._gc) return; if (!i && s._firstPT && (!1 !== s.vars.lazy && s._duration || s.vars.lazy && !s._duration)) return s._time = s._totalTime = l, s._rawPrevTime = h, I.push(s), void(s._lazy = [e, t]);
                                s._time && !n ? s.ratio = s._ease.getRatio(s._time / c) : n && s._ease._calcEnd && (s.ratio = s._ease.getRatio(0 === s._time ? 0 : 1)) } for (!1 !== s._lazy && (s._lazy = !1), s._active || !s._paused && s._time !== l && 0 <= e && (s._active = !0), 0 === l && (s._startAt && (0 <= e ? s._startAt.render(e, !0, i) : r || (r = "_dummyGS")), s.vars.onStart && (0 === s._time && 0 !== c || t || s._callback("onStart"))), a = s._firstPT; a;) a.f ? a.t[a.p](a.c * s.ratio + a.s) : a.t[a.p] = a.c * s.ratio + a.s, a = a._next;
                            s._onUpdate && (e < 0 && s._startAt && -1e-4 !== e && s._startAt.render(e, !0, i), t || (s._time !== l || n || i) && s._callback("onUpdate")), r && (s._gc && !i || (e < 0 && s._startAt && !s._onUpdate && -1e-4 !== e && s._startAt.render(e, !0, i), n && (s._timeline.autoRemoveChildren && s._enabled(!1, !1), s._active = !1), !t && s.vars[r] && s._callback(r), 0 === c && s._rawPrevTime === b && o !== b && (s._rawPrevTime = 0))) } }, n._kill = function(e, t, i) { if ("all" === e && (e = null), null == e && (null == t || t === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                        t = "string" != typeof t ? t || this._targets || this.target : G.selector(t) || t; var n, r, a, o, s, l, c, h, u, d = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline,
                            p = this._firstPT; if ((x(t) || D(t)) && "number" != typeof t[0])
                            for (n = t.length; - 1 < --n;) this._kill(e, t[n], i) && (l = !0);
                        else { if (this._targets) { for (n = this._targets.length; - 1 < --n;)
                                    if (t === this._targets[n]) { s = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = e ? this._overwrittenProps[n] || {} : "all"; break } } else { if (t !== this.target) return !1;
                                s = this._propLookup, r = this._overwrittenProps = e ? this._overwrittenProps || {} : "all" } if (s) { if (c = e || s, h = e !== r && "all" !== r && e !== s && ("object" !== rt(e) || !e._tempKill), i && (G.onOverwrite || this.vars.onOverwrite)) { for (a in c) s[a] && (u || (u = []), u.push(a)); if ((u || !e) && !te(this, i, t, u)) return !1 } for (a in c)(o = s[a]) && (d && (o.f ? o.t[o.p](o.s) : o.t[o.p] = o.s, l = !0), o.pg && o.t._kill(c) && (l = !0), o.pg && 0 !== o.t._overwriteProps.length || (o._prev ? o._prev._next = o._next : o === this._firstPT && (this._firstPT = o._next), o._next && (o._next._prev = o._prev), o._next = o._prev = null), delete s[a]), h && (r[a] = 1);!this._firstPT && this._initted && p && this._enabled(!1, !1) } } return l }, n.invalidate = function() { this._notifyPluginsOfEnabled && G._onPluginEvent("_onDisable", this); var e = this._time; return this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], H.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -b, this.render(e, !1, !1 !== this.vars.lazy)), this }, n._enabled = function(e, t) { if (M || v.wake(), e && this._gc) { var i, n = this._targets; if (n)
                                for (i = n.length; - 1 < --i;) this._siblings[i] = ee(n[i], this, !0);
                            else this._siblings = ee(this.target, this, !0) } return H.prototype._enabled.call(this, e, t), !(!this._notifyPluginsOfEnabled || !this._firstPT) && G._onPluginEvent(e ? "_onEnable" : "_onDisable", this) }, G.to = function(e, t, i) { return new G(e, t, i) }, G.from = function(e, t, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new G(e, t, i) }, G.fromTo = function(e, t, i, n) { return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new G(e, t, n) }, G.delayedCall = function(e, t, i, n, r) { return new G(t, 0, { delay: e, onComplete: t, onCompleteParams: i, callbackScope: n, onReverseComplete: t, onReverseCompleteParams: i, immediateRender: !1, lazy: !1, useFrames: r, overwrite: 0 }) }, G.set = function(e, t) { return new G(e, 0, t) }, G.getTweensOf = function(e, t) { if (null == e) return []; var i, n, r, a; if (e = "string" != typeof e ? e : G.selector(e) || e, (x(e) || D(e)) && "number" != typeof e[0]) { for (i = e.length, n = []; - 1 < --i;) n = n.concat(G.getTweensOf(e[i], t)); for (i = n.length; - 1 < --i;)
                                for (a = n[i], r = i; - 1 < --r;) a === n[r] && n.splice(i, 1) } else if (e._gsTweenID)
                            for (i = (n = ee(e).concat()).length; - 1 < --i;)(n[i]._gc || t && !n[i].isActive()) && n.splice(i, 1); return n || [] }, G.killTweensOf = G.killDelayedCallsTo = function(e, t, i) { "object" === rt(t) && (i = t, t = !1); for (var n = G.getTweensOf(e, t), r = n.length; - 1 < --r;) n[r]._kill(i, e) }; var re = d("plugins.TweenPlugin", function(e, t) { this._overwriteProps = (e || "").split(","), this._propName = this._overwriteProps[0], this._priority = t || 0, this._super = re.prototype }, !0); if (n = re.prototype, re.version = "1.19.0", re.API = 2, n._firstPT = null, n._addTween = V, n.setRatio = z, n._kill = function(e) { var t, i = this._overwriteProps,
                                n = this._firstPT; if (null != e[this._propName]) this._overwriteProps = [];
                            else
                                for (t = i.length; - 1 < --t;) null != e[i[t]] && i.splice(t, 1); for (; n;) null != e[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next; return !1 }, n._mod = n._roundProps = function(e) { for (var t, i = this._firstPT; i;)(t = e[this._propName] || null != i.n && e[i.n.split(this._propName + "_").join("")]) && "function" == typeof t && (2 === i.f ? i.t._applyPT.m = t : i.m = t), i = i._next }, G._onPluginEvent = function(e, t) { var i, n, r, a, o, s = t._firstPT; if ("_onInitAllProps" === e) { for (; s;) { for (o = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                                    (s._prev = n ? n._prev : a) ? s._prev._next = s: r = s, (s._next = n) ? n._prev = s : a = s, s = o }
                                s = t._firstPT = r } for (; s;) s.pg && "function" == typeof s.t[e] && s.t[e]() && (i = !0), s = s._next; return i }, re.activate = function(e) { for (var t = e.length; - 1 < --t;) e[t].API === re.API && (W[(new e[t])._propName] = e[t]); return !0 }, c.plugin = function(e) { if (!(e && e.propName && e.init && e.API)) throw "illegal plugin definition."; var t, i = e.propName,
                                n = e.priority || 0,
                                r = e.overwriteProps,
                                a = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_mod", mod: "_mod", initAll: "_onInitAllProps" },
                                o = d("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() { re.call(this, i, n), this._overwriteProps = r || [] }, !0 === e.global),
                                s = o.prototype = new re(i); for (t in (s.constructor = o).API = e.API, a) "function" == typeof e[t] && (s[a[t]] = e[t]); return o.version = e.version, re.activate([o]), o }, t = p._gsQueue) { for (i = 0; i < t.length; i++) t[i](); for (n in T) T[n].func || p.console.log("GSAP encountered missing dependency: " + n) }
                    M = !1 }(void 0 !== ae && ae.exports && void 0 !== e ? e : window, "TweenMax") }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, {}], 13: [function(e, t, i) { var u;! function(e) { if (void 0 !== t && t.exports) return function(e) { t.exports = e() }; if ("function" == typeof define && define.amd) return define; if ("undefined" != typeof window) return function(e) { window.MobileDetect = e() }; throw new Error("unknown environment") }()(function() { "use strict"; var s, l = { mobileDetectRules: { phones: { iPhone: "\\biPhone\\b|\\biPod\\b", BlackBerry: "BlackBerry|\\bBB10\\b|rim[0-9]+", HTC: "HTC|HTC.*(Sensation|Evo|Vision|Explorer|6800|8100|8900|A7272|S510e|C110e|Legend|Desire|T8282)|APX515CKT|Qtek9090|APA9292KT|HD_mini|Sensation.*Z710e|PG86100|Z715e|Desire.*(A8181|HD)|ADR6200|ADR6400L|ADR6425|001HT|Inspire 4G|Android.*\\bEVO\\b|T-Mobile G1|Z520m|Android [0-9.]+; Pixel", Nexus: "Nexus One|Nexus S|Galaxy.*Nexus|Android.*Nexus.*Mobile|Nexus 4|Nexus 5|Nexus 6", Dell: "Dell[;]? (Streak|Aero|Venue|Venue Pro|Flash|Smoke|Mini 3iX)|XCD28|XCD35|\\b001DL\\b|\\b101DL\\b|\\bGS01\\b", Motorola: "Motorola|DROIDX|DROID BIONIC|\\bDroid\\b.*Build|Android.*Xoom|HRI39|MOT-|A1260|A1680|A555|A853|A855|A953|A955|A956|Motorola.*ELECTRIFY|Motorola.*i1|i867|i940|MB200|MB300|MB501|MB502|MB508|MB511|MB520|MB525|MB526|MB611|MB612|MB632|MB810|MB855|MB860|MB861|MB865|MB870|ME501|ME502|ME511|ME525|ME600|ME632|ME722|ME811|ME860|ME863|ME865|MT620|MT710|MT716|MT720|MT810|MT870|MT917|Motorola.*TITANIUM|WX435|WX445|XT300|XT301|XT311|XT316|XT317|XT319|XT320|XT390|XT502|XT530|XT531|XT532|XT535|XT603|XT610|XT611|XT615|XT681|XT701|XT702|XT711|XT720|XT800|XT806|XT860|XT862|XT875|XT882|XT883|XT894|XT901|XT907|XT909|XT910|XT912|XT928|XT926|XT915|XT919|XT925|XT1021|\\bMoto E\\b|XT1068|XT1092|XT1052", Samsung: "\\bSamsung\\b|SM-G950F|SM-G955F|SM-G9250|GT-19300|SGH-I337|BGT-S5230|GT-B2100|GT-B2700|GT-B2710|GT-B3210|GT-B3310|GT-B3410|GT-B3730|GT-B3740|GT-B5510|GT-B5512|GT-B5722|GT-B6520|GT-B7300|GT-B7320|GT-B7330|GT-B7350|GT-B7510|GT-B7722|GT-B7800|GT-C3010|GT-C3011|GT-C3060|GT-C3200|GT-C3212|GT-C3212I|GT-C3262|GT-C3222|GT-C3300|GT-C3300K|GT-C3303|GT-C3303K|GT-C3310|GT-C3322|GT-C3330|GT-C3350|GT-C3500|GT-C3510|GT-C3530|GT-C3630|GT-C3780|GT-C5010|GT-C5212|GT-C6620|GT-C6625|GT-C6712|GT-E1050|GT-E1070|GT-E1075|GT-E1080|GT-E1081|GT-E1085|GT-E1087|GT-E1100|GT-E1107|GT-E1110|GT-E1120|GT-E1125|GT-E1130|GT-E1160|GT-E1170|GT-E1175|GT-E1180|GT-E1182|GT-E1200|GT-E1210|GT-E1225|GT-E1230|GT-E1390|GT-E2100|GT-E2120|GT-E2121|GT-E2152|GT-E2220|GT-E2222|GT-E2230|GT-E2232|GT-E2250|GT-E2370|GT-E2550|GT-E2652|GT-E3210|GT-E3213|GT-I5500|GT-I5503|GT-I5700|GT-I5800|GT-I5801|GT-I6410|GT-I6420|GT-I7110|GT-I7410|GT-I7500|GT-I8000|GT-I8150|GT-I8160|GT-I8190|GT-I8320|GT-I8330|GT-I8350|GT-I8530|GT-I8700|GT-I8703|GT-I8910|GT-I9000|GT-I9001|GT-I9003|GT-I9010|GT-I9020|GT-I9023|GT-I9070|GT-I9082|GT-I9100|GT-I9103|GT-I9220|GT-I9250|GT-I9300|GT-I9305|GT-I9500|GT-I9505|GT-M3510|GT-M5650|GT-M7500|GT-M7600|GT-M7603|GT-M8800|GT-M8910|GT-N7000|GT-S3110|GT-S3310|GT-S3350|GT-S3353|GT-S3370|GT-S3650|GT-S3653|GT-S3770|GT-S3850|GT-S5210|GT-S5220|GT-S5229|GT-S5230|GT-S5233|GT-S5250|GT-S5253|GT-S5260|GT-S5263|GT-S5270|GT-S5300|GT-S5330|GT-S5350|GT-S5360|GT-S5363|GT-S5369|GT-S5380|GT-S5380D|GT-S5560|GT-S5570|GT-S5600|GT-S5603|GT-S5610|GT-S5620|GT-S5660|GT-S5670|GT-S5690|GT-S5750|GT-S5780|GT-S5830|GT-S5839|GT-S6102|GT-S6500|GT-S7070|GT-S7200|GT-S7220|GT-S7230|GT-S7233|GT-S7250|GT-S7500|GT-S7530|GT-S7550|GT-S7562|GT-S7710|GT-S8000|GT-S8003|GT-S8500|GT-S8530|GT-S8600|SCH-A310|SCH-A530|SCH-A570|SCH-A610|SCH-A630|SCH-A650|SCH-A790|SCH-A795|SCH-A850|SCH-A870|SCH-A890|SCH-A930|SCH-A950|SCH-A970|SCH-A990|SCH-I100|SCH-I110|SCH-I400|SCH-I405|SCH-I500|SCH-I510|SCH-I515|SCH-I600|SCH-I730|SCH-I760|SCH-I770|SCH-I830|SCH-I910|SCH-I920|SCH-I959|SCH-LC11|SCH-N150|SCH-N300|SCH-R100|SCH-R300|SCH-R351|SCH-R400|SCH-R410|SCH-T300|SCH-U310|SCH-U320|SCH-U350|SCH-U360|SCH-U365|SCH-U370|SCH-U380|SCH-U410|SCH-U430|SCH-U450|SCH-U460|SCH-U470|SCH-U490|SCH-U540|SCH-U550|SCH-U620|SCH-U640|SCH-U650|SCH-U660|SCH-U700|SCH-U740|SCH-U750|SCH-U810|SCH-U820|SCH-U900|SCH-U940|SCH-U960|SCS-26UC|SGH-A107|SGH-A117|SGH-A127|SGH-A137|SGH-A157|SGH-A167|SGH-A177|SGH-A187|SGH-A197|SGH-A227|SGH-A237|SGH-A257|SGH-A437|SGH-A517|SGH-A597|SGH-A637|SGH-A657|SGH-A667|SGH-A687|SGH-A697|SGH-A707|SGH-A717|SGH-A727|SGH-A737|SGH-A747|SGH-A767|SGH-A777|SGH-A797|SGH-A817|SGH-A827|SGH-A837|SGH-A847|SGH-A867|SGH-A877|SGH-A887|SGH-A897|SGH-A927|SGH-B100|SGH-B130|SGH-B200|SGH-B220|SGH-C100|SGH-C110|SGH-C120|SGH-C130|SGH-C140|SGH-C160|SGH-C170|SGH-C180|SGH-C200|SGH-C207|SGH-C210|SGH-C225|SGH-C230|SGH-C417|SGH-C450|SGH-D307|SGH-D347|SGH-D357|SGH-D407|SGH-D415|SGH-D780|SGH-D807|SGH-D980|SGH-E105|SGH-E200|SGH-E315|SGH-E316|SGH-E317|SGH-E335|SGH-E590|SGH-E635|SGH-E715|SGH-E890|SGH-F300|SGH-F480|SGH-I200|SGH-I300|SGH-I320|SGH-I550|SGH-I577|SGH-I600|SGH-I607|SGH-I617|SGH-I627|SGH-I637|SGH-I677|SGH-I700|SGH-I717|SGH-I727|SGH-i747M|SGH-I777|SGH-I780|SGH-I827|SGH-I847|SGH-I857|SGH-I896|SGH-I897|SGH-I900|SGH-I907|SGH-I917|SGH-I927|SGH-I937|SGH-I997|SGH-J150|SGH-J200|SGH-L170|SGH-L700|SGH-M110|SGH-M150|SGH-M200|SGH-N105|SGH-N500|SGH-N600|SGH-N620|SGH-N625|SGH-N700|SGH-N710|SGH-P107|SGH-P207|SGH-P300|SGH-P310|SGH-P520|SGH-P735|SGH-P777|SGH-Q105|SGH-R210|SGH-R220|SGH-R225|SGH-S105|SGH-S307|SGH-T109|SGH-T119|SGH-T139|SGH-T209|SGH-T219|SGH-T229|SGH-T239|SGH-T249|SGH-T259|SGH-T309|SGH-T319|SGH-T329|SGH-T339|SGH-T349|SGH-T359|SGH-T369|SGH-T379|SGH-T409|SGH-T429|SGH-T439|SGH-T459|SGH-T469|SGH-T479|SGH-T499|SGH-T509|SGH-T519|SGH-T539|SGH-T559|SGH-T589|SGH-T609|SGH-T619|SGH-T629|SGH-T639|SGH-T659|SGH-T669|SGH-T679|SGH-T709|SGH-T719|SGH-T729|SGH-T739|SGH-T746|SGH-T749|SGH-T759|SGH-T769|SGH-T809|SGH-T819|SGH-T839|SGH-T919|SGH-T929|SGH-T939|SGH-T959|SGH-T989|SGH-U100|SGH-U200|SGH-U800|SGH-V205|SGH-V206|SGH-X100|SGH-X105|SGH-X120|SGH-X140|SGH-X426|SGH-X427|SGH-X475|SGH-X495|SGH-X497|SGH-X507|SGH-X600|SGH-X610|SGH-X620|SGH-X630|SGH-X700|SGH-X820|SGH-X890|SGH-Z130|SGH-Z150|SGH-Z170|SGH-ZX10|SGH-ZX20|SHW-M110|SPH-A120|SPH-A400|SPH-A420|SPH-A460|SPH-A500|SPH-A560|SPH-A600|SPH-A620|SPH-A660|SPH-A700|SPH-A740|SPH-A760|SPH-A790|SPH-A800|SPH-A820|SPH-A840|SPH-A880|SPH-A900|SPH-A940|SPH-A960|SPH-D600|SPH-D700|SPH-D710|SPH-D720|SPH-I300|SPH-I325|SPH-I330|SPH-I350|SPH-I500|SPH-I600|SPH-I700|SPH-L700|SPH-M100|SPH-M220|SPH-M240|SPH-M300|SPH-M305|SPH-M320|SPH-M330|SPH-M350|SPH-M360|SPH-M370|SPH-M380|SPH-M510|SPH-M540|SPH-M550|SPH-M560|SPH-M570|SPH-M580|SPH-M610|SPH-M620|SPH-M630|SPH-M800|SPH-M810|SPH-M850|SPH-M900|SPH-M910|SPH-M920|SPH-M930|SPH-N100|SPH-N200|SPH-N240|SPH-N300|SPH-N400|SPH-Z400|SWC-E100|SCH-i909|GT-N7100|GT-N7105|SCH-I535|SM-N900A|SGH-I317|SGH-T999L|GT-S5360B|GT-I8262|GT-S6802|GT-S6312|GT-S6310|GT-S5312|GT-S5310|GT-I9105|GT-I8510|GT-S6790N|SM-G7105|SM-N9005|GT-S5301|GT-I9295|GT-I9195|SM-C101|GT-S7392|GT-S7560|GT-B7610|GT-I5510|GT-S7582|GT-S7530E|GT-I8750|SM-G9006V|SM-G9008V|SM-G9009D|SM-G900A|SM-G900D|SM-G900F|SM-G900H|SM-G900I|SM-G900J|SM-G900K|SM-G900L|SM-G900M|SM-G900P|SM-G900R4|SM-G900S|SM-G900T|SM-G900V|SM-G900W8|SHV-E160K|SCH-P709|SCH-P729|SM-T2558|GT-I9205|SM-G9350|SM-J120F|SM-G920F|SM-G920V|SM-G930F|SM-N910C|SM-A310F|GT-I9190|SM-J500FN|SM-G903F|SM-J330F", LG: "\\bLG\\b;|LG[- ]?(C800|C900|E400|E610|E900|E-900|F160|F180K|F180L|F180S|730|855|L160|LS740|LS840|LS970|LU6200|MS690|MS695|MS770|MS840|MS870|MS910|P500|P700|P705|VM696|AS680|AS695|AX840|C729|E970|GS505|272|C395|E739BK|E960|L55C|L75C|LS696|LS860|P769BK|P350|P500|P509|P870|UN272|US730|VS840|VS950|LN272|LN510|LS670|LS855|LW690|MN270|MN510|P509|P769|P930|UN200|UN270|UN510|UN610|US670|US740|US760|UX265|UX840|VN271|VN530|VS660|VS700|VS740|VS750|VS910|VS920|VS930|VX9200|VX11000|AX840A|LW770|P506|P925|P999|E612|D955|D802|MS323|M257)", Sony: "SonyST|SonyLT|SonyEricsson|SonyEricssonLT15iv|LT18i|E10i|LT28h|LT26w|SonyEricssonMT27i|C5303|C6902|C6903|C6906|C6943|D2533", Asus: "Asus.*Galaxy|PadFone.*Mobile", NokiaLumia: "Lumia [0-9]{3,4}", Micromax: "Micromax.*\\b(A210|A92|A88|A72|A111|A110Q|A115|A116|A110|A90S|A26|A51|A35|A54|A25|A27|A89|A68|A65|A57|A90)\\b", Palm: "PalmSource|Palm", Vertu: "Vertu|Vertu.*Ltd|Vertu.*Ascent|Vertu.*Ayxta|Vertu.*Constellation(F|Quest)?|Vertu.*Monika|Vertu.*Signature", Pantech: "PANTECH|IM-A850S|IM-A840S|IM-A830L|IM-A830K|IM-A830S|IM-A820L|IM-A810K|IM-A810S|IM-A800S|IM-T100K|IM-A725L|IM-A780L|IM-A775C|IM-A770K|IM-A760S|IM-A750K|IM-A740S|IM-A730S|IM-A720L|IM-A710K|IM-A690L|IM-A690S|IM-A650S|IM-A630K|IM-A600S|VEGA PTL21|PT003|P8010|ADR910L|P6030|P6020|P9070|P4100|P9060|P5000|CDM8992|TXT8045|ADR8995|IS11PT|P2030|P6010|P8000|PT002|IS06|CDM8999|P9050|PT001|TXT8040|P2020|P9020|P2000|P7040|P7000|C790", Fly: "IQ230|IQ444|IQ450|IQ440|IQ442|IQ441|IQ245|IQ256|IQ236|IQ255|IQ235|IQ245|IQ275|IQ240|IQ285|IQ280|IQ270|IQ260|IQ250", Wiko: "KITE 4G|HIGHWAY|GETAWAY|STAIRWAY|DARKSIDE|DARKFULL|DARKNIGHT|DARKMOON|SLIDE|WAX 4G|RAINBOW|BLOOM|SUNSET|GOA(?!nna)|LENNY|BARRY|IGGY|OZZY|CINK FIVE|CINK PEAX|CINK PEAX 2|CINK SLIM|CINK SLIM 2|CINK +|CINK KING|CINK PEAX|CINK SLIM|SUBLIM", iMobile: "i-mobile (IQ|i-STYLE|idea|ZAA|Hitz)", SimValley: "\\b(SP-80|XT-930|SX-340|XT-930|SX-310|SP-360|SP60|SPT-800|SP-120|SPT-800|SP-140|SPX-5|SPX-8|SP-100|SPX-8|SPX-12)\\b", Wolfgang: "AT-B24D|AT-AS50HD|AT-AS40W|AT-AS55HD|AT-AS45q2|AT-B26D|AT-AS50Q", Alcatel: "Alcatel", Nintendo: "Nintendo (3DS|Switch)", Amoi: "Amoi", INQ: "INQ", GenericPhone: "Tapatalk|PDA;|SAGEM|\\bmmp\\b|pocket|\\bpsp\\b|symbian|Smartphone|smartfon|treo|up.browser|up.link|vodafone|\\bwap\\b|nokia|Series40|Series60|S60|SonyEricsson|N900|MAUI.*WAP.*Browser" }, tablets: { iPad: "iPad|iPad.*Mobile", NexusTablet: "Android.*Nexus[\\s]+(7|9|10)", GoogleTablet: "Android.*Pixel C", SamsungTablet: "SAMSUNG.*Tablet|Galaxy.*Tab|SC-01C|GT-P1000|GT-P1003|GT-P1010|GT-P3105|GT-P6210|GT-P6800|GT-P6810|GT-P7100|GT-P7300|GT-P7310|GT-P7500|GT-P7510|SCH-I800|SCH-I815|SCH-I905|SGH-I957|SGH-I987|SGH-T849|SGH-T859|SGH-T869|SPH-P100|GT-P3100|GT-P3108|GT-P3110|GT-P5100|GT-P5110|GT-P6200|GT-P7320|GT-P7511|GT-N8000|GT-P8510|SGH-I497|SPH-P500|SGH-T779|SCH-I705|SCH-I915|GT-N8013|GT-P3113|GT-P5113|GT-P8110|GT-N8010|GT-N8005|GT-N8020|GT-P1013|GT-P6201|GT-P7501|GT-N5100|GT-N5105|GT-N5110|SHV-E140K|SHV-E140L|SHV-E140S|SHV-E150S|SHV-E230K|SHV-E230L|SHV-E230S|SHW-M180K|SHW-M180L|SHW-M180S|SHW-M180W|SHW-M300W|SHW-M305W|SHW-M380K|SHW-M380S|SHW-M380W|SHW-M430W|SHW-M480K|SHW-M480S|SHW-M480W|SHW-M485W|SHW-M486W|SHW-M500W|GT-I9228|SCH-P739|SCH-I925|GT-I9200|GT-P5200|GT-P5210|GT-P5210X|SM-T311|SM-T310|SM-T310X|SM-T210|SM-T210R|SM-T211|SM-P600|SM-P601|SM-P605|SM-P900|SM-P901|SM-T217|SM-T217A|SM-T217S|SM-P6000|SM-T3100|SGH-I467|XE500|SM-T110|GT-P5220|GT-I9200X|GT-N5110X|GT-N5120|SM-P905|SM-T111|SM-T2105|SM-T315|SM-T320|SM-T320X|SM-T321|SM-T520|SM-T525|SM-T530NU|SM-T230NU|SM-T330NU|SM-T900|XE500T1C|SM-P605V|SM-P905V|SM-T337V|SM-T537V|SM-T707V|SM-T807V|SM-P600X|SM-P900X|SM-T210X|SM-T230|SM-T230X|SM-T325|GT-P7503|SM-T531|SM-T330|SM-T530|SM-T705|SM-T705C|SM-T535|SM-T331|SM-T800|SM-T700|SM-T537|SM-T807|SM-P907A|SM-T337A|SM-T537A|SM-T707A|SM-T807A|SM-T237|SM-T807P|SM-P607T|SM-T217T|SM-T337T|SM-T807T|SM-T116NQ|SM-T116BU|SM-P550|SM-T350|SM-T550|SM-T9000|SM-P9000|SM-T705Y|SM-T805|GT-P3113|SM-T710|SM-T810|SM-T815|SM-T360|SM-T533|SM-T113|SM-T335|SM-T715|SM-T560|SM-T670|SM-T677|SM-T377|SM-T567|SM-T357T|SM-T555|SM-T561|SM-T713|SM-T719|SM-T813|SM-T819|SM-T580|SM-T355Y?|SM-T280|SM-T817A|SM-T820|SM-W700|SM-P580|SM-T587|SM-P350|SM-P555M|SM-P355M|SM-T113NU|SM-T815Y|SM-T585|SM-T285|SM-T825|SM-W708|SM-T835", Kindle: "Kindle|Silk.*Accelerated|Android.*\\b(KFOT|KFTT|KFJWI|KFJWA|KFOTE|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|WFJWAE|KFSAWA|KFSAWI|KFASWI|KFARWI|KFFOWI|KFGIWI|KFMEWI)\\b|Android.*Silk/[0-9.]+ like Chrome/[0-9.]+ (?!Mobile)", SurfaceTablet: "Windows NT [0-9.]+; ARM;.*(Tablet|ARMBJS)", HPTablet: "HP Slate (7|8|10)|HP ElitePad 900|hp-tablet|EliteBook.*Touch|HP 8|Slate 21|HP SlateBook 10", AsusTablet: "^.*PadFone((?!Mobile).)*$|Transformer|TF101|TF101G|TF300T|TF300TG|TF300TL|TF700T|TF700KL|TF701T|TF810C|ME171|ME301T|ME302C|ME371MG|ME370T|ME372MG|ME172V|ME173X|ME400C|Slider SL101|\\bK00F\\b|\\bK00C\\b|\\bK00E\\b|\\bK00L\\b|TX201LA|ME176C|ME102A|\\bM80TA\\b|ME372CL|ME560CG|ME372CG|ME302KL| K010 | K011 | K017 | K01E |ME572C|ME103K|ME170C|ME171C|\\bME70C\\b|ME581C|ME581CL|ME8510C|ME181C|P01Y|PO1MA|P01Z|\\bP027\\b|\\bP024\\b|\\bP00C\\b", BlackBerryTablet: "PlayBook|RIM Tablet", HTCtablet: "HTC_Flyer_P512|HTC Flyer|HTC Jetstream|HTC-P715a|HTC EVO View 4G|PG41200|PG09410", MotorolaTablet: "xoom|sholest|MZ615|MZ605|MZ505|MZ601|MZ602|MZ603|MZ604|MZ606|MZ607|MZ608|MZ609|MZ615|MZ616|MZ617", NookTablet: "Android.*Nook|NookColor|nook browser|BNRV200|BNRV200A|BNTV250|BNTV250A|BNTV400|BNTV600|LogicPD Zoom2", AcerTablet: "Android.*; \\b(A100|A101|A110|A200|A210|A211|A500|A501|A510|A511|A700|A701|W500|W500P|W501|W501P|W510|W511|W700|G100|G100W|B1-A71|B1-710|B1-711|A1-810|A1-811|A1-830)\\b|W3-810|\\bA3-A10\\b|\\bA3-A11\\b|\\bA3-A20\\b|\\bA3-A30", ToshibaTablet: "Android.*(AT100|AT105|AT200|AT205|AT270|AT275|AT300|AT305|AT1S5|AT500|AT570|AT700|AT830)|TOSHIBA.*FOLIO", LGTablet: "\\bL-06C|LG-V909|LG-V900|LG-V700|LG-V510|LG-V500|LG-V410|LG-V400|LG-VK810\\b", FujitsuTablet: "Android.*\\b(F-01D|F-02F|F-05E|F-10D|M532|Q572)\\b", PrestigioTablet: "PMP3170B|PMP3270B|PMP3470B|PMP7170B|PMP3370B|PMP3570C|PMP5870C|PMP3670B|PMP5570C|PMP5770D|PMP3970B|PMP3870C|PMP5580C|PMP5880D|PMP5780D|PMP5588C|PMP7280C|PMP7280C3G|PMP7280|PMP7880D|PMP5597D|PMP5597|PMP7100D|PER3464|PER3274|PER3574|PER3884|PER5274|PER5474|PMP5097CPRO|PMP5097|PMP7380D|PMP5297C|PMP5297C_QUAD|PMP812E|PMP812E3G|PMP812F|PMP810E|PMP880TD|PMT3017|PMT3037|PMT3047|PMT3057|PMT7008|PMT5887|PMT5001|PMT5002", LenovoTablet: "Lenovo TAB|Idea(Tab|Pad)( A1|A10| K1|)|ThinkPad([ ]+)?Tablet|YT3-850M|YT3-X90L|YT3-X90F|YT3-X90X|Lenovo.*(S2109|S2110|S5000|S6000|K3011|A3000|A3500|A1000|A2107|A2109|A1107|A5500|A7600|B6000|B8000|B8080)(-|)(FL|F|HV|H|)|TB-X103F|TB-X304F|TB-X304L|TB-8703F|Tab2A7-10F|TB2-X30L", DellTablet: "Venue 11|Venue 8|Venue 7|Dell Streak 10|Dell Streak 7", YarvikTablet: "Android.*\\b(TAB210|TAB211|TAB224|TAB250|TAB260|TAB264|TAB310|TAB360|TAB364|TAB410|TAB411|TAB420|TAB424|TAB450|TAB460|TAB461|TAB464|TAB465|TAB467|TAB468|TAB07-100|TAB07-101|TAB07-150|TAB07-151|TAB07-152|TAB07-200|TAB07-201-3G|TAB07-210|TAB07-211|TAB07-212|TAB07-214|TAB07-220|TAB07-400|TAB07-485|TAB08-150|TAB08-200|TAB08-201-3G|TAB08-201-30|TAB09-100|TAB09-211|TAB09-410|TAB10-150|TAB10-201|TAB10-211|TAB10-400|TAB10-410|TAB13-201|TAB274EUK|TAB275EUK|TAB374EUK|TAB462EUK|TAB474EUK|TAB9-200)\\b", MedionTablet: "Android.*\\bOYO\\b|LIFE.*(P9212|P9514|P9516|S9512)|LIFETAB", ArnovaTablet: "97G4|AN10G2|AN7bG3|AN7fG3|AN8G3|AN8cG3|AN7G3|AN9G3|AN7dG3|AN7dG3ST|AN7dG3ChildPad|AN10bG3|AN10bG3DT|AN9G2", IntensoTablet: "INM8002KP|INM1010FP|INM805ND|Intenso Tab|TAB1004", IRUTablet: "M702pro", MegafonTablet: "MegaFon V9|\\bZTE V9\\b|Android.*\\bMT7A\\b", EbodaTablet: "E-Boda (Supreme|Impresspeed|Izzycomm|Essential)", AllViewTablet: "Allview.*(Viva|Alldro|City|Speed|All TV|Frenzy|Quasar|Shine|TX1|AX1|AX2)", ArchosTablet: "\\b(101G9|80G9|A101IT)\\b|Qilive 97R|Archos5|\\bARCHOS (70|79|80|90|97|101|FAMILYPAD|)(b|c|)(G10| Cobalt| TITANIUM(HD|)| Xenon| Neon|XSK| 2| XS 2| PLATINUM| CARBON|GAMEPAD)\\b", AinolTablet: "NOVO7|NOVO8|NOVO10|Novo7Aurora|Novo7Basic|NOVO7PALADIN|novo9-Spark", NokiaLumiaTablet: "Lumia 2520", SonyTablet: "Sony.*Tablet|Xperia Tablet|Sony Tablet S|SO-03E|SGPT12|SGPT13|SGPT114|SGPT121|SGPT122|SGPT123|SGPT111|SGPT112|SGPT113|SGPT131|SGPT132|SGPT133|SGPT211|SGPT212|SGPT213|SGP311|SGP312|SGP321|EBRD1101|EBRD1102|EBRD1201|SGP351|SGP341|SGP511|SGP512|SGP521|SGP541|SGP551|SGP621|SGP641|SGP612|SOT31|SGP771|SGP611|SGP612|SGP712", PhilipsTablet: "\\b(PI2010|PI3000|PI3100|PI3105|PI3110|PI3205|PI3210|PI3900|PI4010|PI7000|PI7100)\\b", CubeTablet: "Android.*(K8GT|U9GT|U10GT|U16GT|U17GT|U18GT|U19GT|U20GT|U23GT|U30GT)|CUBE U8GT", CobyTablet: "MID1042|MID1045|MID1125|MID1126|MID7012|MID7014|MID7015|MID7034|MID7035|MID7036|MID7042|MID7048|MID7127|MID8042|MID8048|MID8127|MID9042|MID9740|MID9742|MID7022|MID7010", MIDTablet: "M9701|M9000|M9100|M806|M1052|M806|T703|MID701|MID713|MID710|MID727|MID760|MID830|MID728|MID933|MID125|MID810|MID732|MID120|MID930|MID800|MID731|MID900|MID100|MID820|MID735|MID980|MID130|MID833|MID737|MID960|MID135|MID860|MID736|MID140|MID930|MID835|MID733|MID4X10", MSITablet: "MSI \\b(Primo 73K|Primo 73L|Primo 81L|Primo 77|Primo 93|Primo 75|Primo 76|Primo 73|Primo 81|Primo 91|Primo 90|Enjoy 71|Enjoy 7|Enjoy 10)\\b", SMiTTablet: "Android.*(\\bMID\\b|MID-560|MTV-T1200|MTV-PND531|MTV-P1101|MTV-PND530)", RockChipTablet: "Android.*(RK2818|RK2808A|RK2918|RK3066)|RK2738|RK2808A", FlyTablet: "IQ310|Fly Vision", bqTablet: "Android.*(bq)?.*(Elcano|Curie|Edison|Maxwell|Kepler|Pascal|Tesla|Hypatia|Platon|Newton|Livingstone|Cervantes|Avant|Aquaris ([E|M]10|M8))|Maxwell.*Lite|Maxwell.*Plus", HuaweiTablet: "MediaPad|MediaPad 7 Youth|IDEOS S7|S7-201c|S7-202u|S7-101|S7-103|S7-104|S7-105|S7-106|S7-201|S7-Slim|M2-A01L|BAH-L09|BAH-W09", NecTablet: "\\bN-06D|\\bN-08D", PantechTablet: "Pantech.*P4100", BronchoTablet: "Broncho.*(N701|N708|N802|a710)", VersusTablet: "TOUCHPAD.*[78910]|\\bTOUCHTAB\\b", ZyncTablet: "z1000|Z99 2G|z99|z930|z999|z990|z909|Z919|z900", PositivoTablet: "TB07STA|TB10STA|TB07FTA|TB10FTA", NabiTablet: "Android.*\\bNabi", KoboTablet: "Kobo Touch|\\bK080\\b|\\bVox\\b Build|\\bArc\\b Build", DanewTablet: "DSlide.*\\b(700|701R|702|703R|704|802|970|971|972|973|974|1010|1012)\\b", TexetTablet: "NaviPad|TB-772A|TM-7045|TM-7055|TM-9750|TM-7016|TM-7024|TM-7026|TM-7041|TM-7043|TM-7047|TM-8041|TM-9741|TM-9747|TM-9748|TM-9751|TM-7022|TM-7021|TM-7020|TM-7011|TM-7010|TM-7023|TM-7025|TM-7037W|TM-7038W|TM-7027W|TM-9720|TM-9725|TM-9737W|TM-1020|TM-9738W|TM-9740|TM-9743W|TB-807A|TB-771A|TB-727A|TB-725A|TB-719A|TB-823A|TB-805A|TB-723A|TB-715A|TB-707A|TB-705A|TB-709A|TB-711A|TB-890HD|TB-880HD|TB-790HD|TB-780HD|TB-770HD|TB-721HD|TB-710HD|TB-434HD|TB-860HD|TB-840HD|TB-760HD|TB-750HD|TB-740HD|TB-730HD|TB-722HD|TB-720HD|TB-700HD|TB-500HD|TB-470HD|TB-431HD|TB-430HD|TB-506|TB-504|TB-446|TB-436|TB-416|TB-146SE|TB-126SE", PlaystationTablet: "Playstation.*(Portable|Vita)", TrekstorTablet: "ST10416-1|VT10416-1|ST70408-1|ST702xx-1|ST702xx-2|ST80208|ST97216|ST70104-2|VT10416-2|ST10216-2A|SurfTab", PyleAudioTablet: "\\b(PTBL10CEU|PTBL10C|PTBL72BC|PTBL72BCEU|PTBL7CEU|PTBL7C|PTBL92BC|PTBL92BCEU|PTBL9CEU|PTBL9CUK|PTBL9C)\\b", AdvanTablet: "Android.* \\b(E3A|T3X|T5C|T5B|T3E|T3C|T3B|T1J|T1F|T2A|T1H|T1i|E1C|T1-E|T5-A|T4|E1-B|T2Ci|T1-B|T1-D|O1-A|E1-A|T1-A|T3A|T4i)\\b ", DanyTechTablet: "Genius Tab G3|Genius Tab S2|Genius Tab Q3|Genius Tab G4|Genius Tab Q4|Genius Tab G-II|Genius TAB GII|Genius TAB GIII|Genius Tab S1", GalapadTablet: "Android.*\\bG1\\b(?!\\))", MicromaxTablet: "Funbook|Micromax.*\\b(P250|P560|P360|P362|P600|P300|P350|P500|P275)\\b", KarbonnTablet: "Android.*\\b(A39|A37|A34|ST8|ST10|ST7|Smart Tab3|Smart Tab2)\\b", AllFineTablet: "Fine7 Genius|Fine7 Shine|Fine7 Air|Fine8 Style|Fine9 More|Fine10 Joy|Fine11 Wide", PROSCANTablet: "\\b(PEM63|PLT1023G|PLT1041|PLT1044|PLT1044G|PLT1091|PLT4311|PLT4311PL|PLT4315|PLT7030|PLT7033|PLT7033D|PLT7035|PLT7035D|PLT7044K|PLT7045K|PLT7045KB|PLT7071KG|PLT7072|PLT7223G|PLT7225G|PLT7777G|PLT7810K|PLT7849G|PLT7851G|PLT7852G|PLT8015|PLT8031|PLT8034|PLT8036|PLT8080K|PLT8082|PLT8088|PLT8223G|PLT8234G|PLT8235G|PLT8816K|PLT9011|PLT9045K|PLT9233G|PLT9735|PLT9760G|PLT9770G)\\b", YONESTablet: "BQ1078|BC1003|BC1077|RK9702|BC9730|BC9001|IT9001|BC7008|BC7010|BC708|BC728|BC7012|BC7030|BC7027|BC7026", ChangJiaTablet: "TPC7102|TPC7103|TPC7105|TPC7106|TPC7107|TPC7201|TPC7203|TPC7205|TPC7210|TPC7708|TPC7709|TPC7712|TPC7110|TPC8101|TPC8103|TPC8105|TPC8106|TPC8203|TPC8205|TPC8503|TPC9106|TPC9701|TPC97101|TPC97103|TPC97105|TPC97106|TPC97111|TPC97113|TPC97203|TPC97603|TPC97809|TPC97205|TPC10101|TPC10103|TPC10106|TPC10111|TPC10203|TPC10205|TPC10503", GUTablet: "TX-A1301|TX-M9002|Q702|kf026", PointOfViewTablet: "TAB-P506|TAB-navi-7-3G-M|TAB-P517|TAB-P-527|TAB-P701|TAB-P703|TAB-P721|TAB-P731N|TAB-P741|TAB-P825|TAB-P905|TAB-P925|TAB-PR945|TAB-PL1015|TAB-P1025|TAB-PI1045|TAB-P1325|TAB-PROTAB[0-9]+|TAB-PROTAB25|TAB-PROTAB26|TAB-PROTAB27|TAB-PROTAB26XL|TAB-PROTAB2-IPS9|TAB-PROTAB30-IPS9|TAB-PROTAB25XXL|TAB-PROTAB26-IPS10|TAB-PROTAB30-IPS10", OvermaxTablet: "OV-(SteelCore|NewBase|Basecore|Baseone|Exellen|Quattor|EduTab|Solution|ACTION|BasicTab|TeddyTab|MagicTab|Stream|TB-08|TB-09)|Qualcore 1027", HCLTablet: "HCL.*Tablet|Connect-3G-2.0|Connect-2G-2.0|ME Tablet U1|ME Tablet U2|ME Tablet G1|ME Tablet X1|ME Tablet Y2|ME Tablet Sync", DPSTablet: "DPS Dream 9|DPS Dual 7", VistureTablet: "V97 HD|i75 3G|Visture V4( HD)?|Visture V5( HD)?|Visture V10", CrestaTablet: "CTP(-)?810|CTP(-)?818|CTP(-)?828|CTP(-)?838|CTP(-)?888|CTP(-)?978|CTP(-)?980|CTP(-)?987|CTP(-)?988|CTP(-)?989", MediatekTablet: "\\bMT8125|MT8389|MT8135|MT8377\\b", ConcordeTablet: "Concorde([ ]+)?Tab|ConCorde ReadMan", GoCleverTablet: "GOCLEVER TAB|A7GOCLEVER|M1042|M7841|M742|R1042BK|R1041|TAB A975|TAB A7842|TAB A741|TAB A741L|TAB M723G|TAB M721|TAB A1021|TAB I921|TAB R721|TAB I720|TAB T76|TAB R70|TAB R76.2|TAB R106|TAB R83.2|TAB M813G|TAB I721|GCTA722|TAB I70|TAB I71|TAB S73|TAB R73|TAB R74|TAB R93|TAB R75|TAB R76.1|TAB A73|TAB A93|TAB A93.2|TAB T72|TAB R83|TAB R974|TAB R973|TAB A101|TAB A103|TAB A104|TAB A104.2|R105BK|M713G|A972BK|TAB A971|TAB R974.2|TAB R104|TAB R83.3|TAB A1042", ModecomTablet: "FreeTAB 9000|FreeTAB 7.4|FreeTAB 7004|FreeTAB 7800|FreeTAB 2096|FreeTAB 7.5|FreeTAB 1014|FreeTAB 1001 |FreeTAB 8001|FreeTAB 9706|FreeTAB 9702|FreeTAB 7003|FreeTAB 7002|FreeTAB 1002|FreeTAB 7801|FreeTAB 1331|FreeTAB 1004|FreeTAB 8002|FreeTAB 8014|FreeTAB 9704|FreeTAB 1003", VoninoTablet: "\\b(Argus[ _]?S|Diamond[ _]?79HD|Emerald[ _]?78E|Luna[ _]?70C|Onyx[ _]?S|Onyx[ _]?Z|Orin[ _]?HD|Orin[ _]?S|Otis[ _]?S|SpeedStar[ _]?S|Magnet[ _]?M9|Primus[ _]?94[ _]?3G|Primus[ _]?94HD|Primus[ _]?QS|Android.*\\bQ8\\b|Sirius[ _]?EVO[ _]?QS|Sirius[ _]?QS|Spirit[ _]?S)\\b", ECSTablet: "V07OT2|TM105A|S10OT1|TR10CS1", StorexTablet: "eZee[_']?(Tab|Go)[0-9]+|TabLC7|Looney Tunes Tab", VodafoneTablet: "SmartTab([ ]+)?[0-9]+|SmartTabII10|SmartTabII7|VF-1497", EssentielBTablet: "Smart[ ']?TAB[ ]+?[0-9]+|Family[ ']?TAB2", RossMoorTablet: "RM-790|RM-997|RMD-878G|RMD-974R|RMT-705A|RMT-701|RME-601|RMT-501|RMT-711", iMobileTablet: "i-mobile i-note", TolinoTablet: "tolino tab [0-9.]+|tolino shine", AudioSonicTablet: "\\bC-22Q|T7-QC|T-17B|T-17P\\b", AMPETablet: "Android.* A78 ", SkkTablet: "Android.* (SKYPAD|PHOENIX|CYCLOPS)", TecnoTablet: "TECNO P9|TECNO DP8D", JXDTablet: "Android.* \\b(F3000|A3300|JXD5000|JXD3000|JXD2000|JXD300B|JXD300|S5800|S7800|S602b|S5110b|S7300|S5300|S602|S603|S5100|S5110|S601|S7100a|P3000F|P3000s|P101|P200s|P1000m|P200m|P9100|P1000s|S6600b|S908|P1000|P300|S18|S6600|S9100)\\b", iJoyTablet: "Tablet (Spirit 7|Essentia|Galatea|Fusion|Onix 7|Landa|Titan|Scooby|Deox|Stella|Themis|Argon|Unique 7|Sygnus|Hexen|Finity 7|Cream|Cream X2|Jade|Neon 7|Neron 7|Kandy|Scape|Saphyr 7|Rebel|Biox|Rebel|Rebel 8GB|Myst|Draco 7|Myst|Tab7-004|Myst|Tadeo Jones|Tablet Boing|Arrow|Draco Dual Cam|Aurix|Mint|Amity|Revolution|Finity 9|Neon 9|T9w|Amity 4GB Dual Cam|Stone 4GB|Stone 8GB|Andromeda|Silken|X2|Andromeda II|Halley|Flame|Saphyr 9,7|Touch 8|Planet|Triton|Unique 10|Hexen 10|Memphis 4GB|Memphis 8GB|Onix 10)", FX2Tablet: "FX2 PAD7|FX2 PAD10", XoroTablet: "KidsPAD 701|PAD[ ]?712|PAD[ ]?714|PAD[ ]?716|PAD[ ]?717|PAD[ ]?718|PAD[ ]?720|PAD[ ]?721|PAD[ ]?722|PAD[ ]?790|PAD[ ]?792|PAD[ ]?900|PAD[ ]?9715D|PAD[ ]?9716DR|PAD[ ]?9718DR|PAD[ ]?9719QR|PAD[ ]?9720QR|TelePAD1030|Telepad1032|TelePAD730|TelePAD731|TelePAD732|TelePAD735Q|TelePAD830|TelePAD9730|TelePAD795|MegaPAD 1331|MegaPAD 1851|MegaPAD 2151", ViewsonicTablet: "ViewPad 10pi|ViewPad 10e|ViewPad 10s|ViewPad E72|ViewPad7|ViewPad E100|ViewPad 7e|ViewSonic VB733|VB100a", VerizonTablet: "QTAQZ3|QTAIR7|QTAQTZ3|QTASUN1|QTASUN2|QTAXIA1", OdysTablet: "LOOX|XENO10|ODYS[ -](Space|EVO|Xpress|NOON)|\\bXELIO\\b|Xelio10Pro|XELIO7PHONETAB|XELIO10EXTREME|XELIOPT2|NEO_QUAD10", CaptivaTablet: "CAPTIVA PAD", IconbitTablet: "NetTAB|NT-3702|NT-3702S|NT-3702S|NT-3603P|NT-3603P|NT-0704S|NT-0704S|NT-3805C|NT-3805C|NT-0806C|NT-0806C|NT-0909T|NT-0909T|NT-0907S|NT-0907S|NT-0902S|NT-0902S", TeclastTablet: "T98 4G|\\bP80\\b|\\bX90HD\\b|X98 Air|X98 Air 3G|\\bX89\\b|P80 3G|\\bX80h\\b|P98 Air|\\bX89HD\\b|P98 3G|\\bP90HD\\b|P89 3G|X98 3G|\\bP70h\\b|P79HD 3G|G18d 3G|\\bP79HD\\b|\\bP89s\\b|\\bA88\\b|\\bP10HD\\b|\\bP19HD\\b|G18 3G|\\bP78HD\\b|\\bA78\\b|\\bP75\\b|G17s 3G|G17h 3G|\\bP85t\\b|\\bP90\\b|\\bP11\\b|\\bP98t\\b|\\bP98HD\\b|\\bG18d\\b|\\bP85s\\b|\\bP11HD\\b|\\bP88s\\b|\\bA80HD\\b|\\bA80se\\b|\\bA10h\\b|\\bP89\\b|\\bP78s\\b|\\bG18\\b|\\bP85\\b|\\bA70h\\b|\\bA70\\b|\\bG17\\b|\\bP18\\b|\\bA80s\\b|\\bA11s\\b|\\bP88HD\\b|\\bA80h\\b|\\bP76s\\b|\\bP76h\\b|\\bP98\\b|\\bA10HD\\b|\\bP78\\b|\\bP88\\b|\\bA11\\b|\\bA10t\\b|\\bP76a\\b|\\bP76t\\b|\\bP76e\\b|\\bP85HD\\b|\\bP85a\\b|\\bP86\\b|\\bP75HD\\b|\\bP76v\\b|\\bA12\\b|\\bP75a\\b|\\bA15\\b|\\bP76Ti\\b|\\bP81HD\\b|\\bA10\\b|\\bT760VE\\b|\\bT720HD\\b|\\bP76\\b|\\bP73\\b|\\bP71\\b|\\bP72\\b|\\bT720SE\\b|\\bC520Ti\\b|\\bT760\\b|\\bT720VE\\b|T720-3GE|T720-WiFi", OndaTablet: "\\b(V975i|Vi30|VX530|V701|Vi60|V701s|Vi50|V801s|V719|Vx610w|VX610W|V819i|Vi10|VX580W|Vi10|V711s|V813|V811|V820w|V820|Vi20|V711|VI30W|V712|V891w|V972|V819w|V820w|Vi60|V820w|V711|V813s|V801|V819|V975s|V801|V819|V819|V818|V811|V712|V975m|V101w|V961w|V812|V818|V971|V971s|V919|V989|V116w|V102w|V973|Vi40)\\b[\\s]+|V10 \\b4G\\b", JaytechTablet: "TPC-PA762", BlaupunktTablet: "Endeavour 800NG|Endeavour 1010", DigmaTablet: "\\b(iDx10|iDx9|iDx8|iDx7|iDxD7|iDxD8|iDsQ8|iDsQ7|iDsQ8|iDsD10|iDnD7|3TS804H|iDsQ11|iDj7|iDs10)\\b", EvolioTablet: "ARIA_Mini_wifi|Aria[ _]Mini|Evolio X10|Evolio X7|Evolio X8|\\bEvotab\\b|\\bNeura\\b", LavaTablet: "QPAD E704|\\bIvoryS\\b|E-TAB IVORY|\\bE-TAB\\b", AocTablet: "MW0811|MW0812|MW0922|MTK8382|MW1031|MW0831|MW0821|MW0931|MW0712", MpmanTablet: "MP11 OCTA|MP10 OCTA|MPQC1114|MPQC1004|MPQC994|MPQC974|MPQC973|MPQC804|MPQC784|MPQC780|\\bMPG7\\b|MPDCG75|MPDCG71|MPDC1006|MP101DC|MPDC9000|MPDC905|MPDC706HD|MPDC706|MPDC705|MPDC110|MPDC100|MPDC99|MPDC97|MPDC88|MPDC8|MPDC77|MP709|MID701|MID711|MID170|MPDC703|MPQC1010", CelkonTablet: "CT695|CT888|CT[\\s]?910|CT7 Tab|CT9 Tab|CT3 Tab|CT2 Tab|CT1 Tab|C820|C720|\\bCT-1\\b", WolderTablet: "miTab \\b(DIAMOND|SPACE|BROOKLYN|NEO|FLY|MANHATTAN|FUNK|EVOLUTION|SKY|GOCAR|IRON|GENIUS|POP|MINT|EPSILON|BROADWAY|JUMP|HOP|LEGEND|NEW AGE|LINE|ADVANCE|FEEL|FOLLOW|LIKE|LINK|LIVE|THINK|FREEDOM|CHICAGO|CLEVELAND|BALTIMORE-GH|IOWA|BOSTON|SEATTLE|PHOENIX|DALLAS|IN 101|MasterChef)\\b", MediacomTablet: "M-MPI10C3G|M-SP10EG|M-SP10EGP|M-SP10HXAH|M-SP7HXAH|M-SP10HXBH|M-SP8HXAH|M-SP8MXA", MiTablet: "\\bMI PAD\\b|\\bHM NOTE 1W\\b", NibiruTablet: "Nibiru M1|Nibiru Jupiter One", NexoTablet: "NEXO NOVA|NEXO 10|NEXO AVIO|NEXO FREE|NEXO GO|NEXO EVO|NEXO 3G|NEXO SMART|NEXO KIDDO|NEXO MOBI", LeaderTablet: "TBLT10Q|TBLT10I|TBL-10WDKB|TBL-10WDKBO2013|TBL-W230V2|TBL-W450|TBL-W500|SV572|TBLT7I|TBA-AC7-8G|TBLT79|TBL-8W16|TBL-10W32|TBL-10WKB|TBL-W100", UbislateTablet: "UbiSlate[\\s]?7C", PocketBookTablet: "Pocketbook", KocasoTablet: "\\b(TB-1207)\\b", HisenseTablet: "\\b(F5281|E2371)\\b", Hudl: "Hudl HT7S3|Hudl 2", TelstraTablet: "T-Hub2", GenericTablet: "Android.*\\b97D\\b|Tablet(?!.*PC)|BNTV250A|MID-WCDMA|LogicPD Zoom2|\\bA7EB\\b|CatNova8|A1_07|CT704|CT1002|\\bM721\\b|rk30sdk|\\bEVOTAB\\b|M758A|ET904|ALUMIUM10|Smartfren Tab|Endeavour 1010|Tablet-PC-4|Tagi Tab|\\bM6pro\\b|CT1020W|arc 10HD|\\bTP750\\b|\\bQTAQZ3\\b|WVT101|TM1088|KT107" }, oss: { AndroidOS: "Android", BlackBerryOS: "blackberry|\\bBB10\\b|rim tablet os", PalmOS: "PalmOS|avantgo|blazer|elaine|hiptop|palm|plucker|xiino", SymbianOS: "Symbian|SymbOS|Series60|Series40|SYB-[0-9]+|\\bS60\\b", WindowsMobileOS: "Windows CE.*(PPC|Smartphone|Mobile|[0-9]{3}x[0-9]{3})|Window Mobile|Windows Phone [0-9.]+|WCE;", WindowsPhoneOS: "Windows Phone 10.0|Windows Phone 8.1|Windows Phone 8.0|Windows Phone OS|XBLWP7|ZuneWP7|Windows NT 6.[23]; ARM;", iOS: "\\biPhone.*Mobile|\\biPod|\\biPad|AppleCoreMedia", MeeGoOS: "MeeGo", MaemoOS: "Maemo", JavaOS: "J2ME/|\\bMIDP\\b|\\bCLDC\\b", webOS: "webOS|hpwOS", badaOS: "\\bBada\\b", BREWOS: "BREW" }, uas: { Chrome: "\\bCrMo\\b|CriOS|Android.*Chrome/[.0-9]* (Mobile)?", Dolfin: "\\bDolfin\\b", Opera: "Opera.*Mini|Opera.*Mobi|Android.*Opera|Mobile.*OPR/[0-9.]+$|Coast/[0-9.]+", Skyfire: "Skyfire", Edge: "Mobile Safari/[.0-9]* Edge", IE: "IEMobile|MSIEMobile", Firefox: "fennec|firefox.*maemo|(Mobile|Tablet).*Firefox|Firefox.*Mobile|FxiOS", Bolt: "bolt", TeaShark: "teashark", Blazer: "Blazer", Safari: "Version.*Mobile.*Safari|Safari.*Mobile|MobileSafari", WeChat: "\\bMicroMessenger\\b", UCBrowser: "UC.*Browser|UCWEB", baiduboxapp: "baiduboxapp", baidubrowser: "baidubrowser", DiigoBrowser: "DiigoBrowser", Puffin: "Puffin", Mercury: "\\bMercury\\b", ObigoBrowser: "Obigo", NetFront: "NF-Browser", GenericBrowser: "NokiaBrowser|OviBrowser|OneBrowser|TwonkyBeamBrowser|SEMC.*Browser|FlyFlow|Minimo|NetFront|Novarra-Vision|MQQBrowser|MicroMessenger", PaleMoon: "Android.*PaleMoon|Mobile.*PaleMoon" }, props: { Mobile: "Mobile/[VER]", Build: "Build/[VER]", Version: "Version/[VER]", VendorID: "VendorID/[VER]", iPad: "iPad.*CPU[a-z ]+[VER]", iPhone: "iPhone.*CPU[a-z ]+[VER]", iPod: "iPod.*CPU[a-z ]+[VER]", Kindle: "Kindle/[VER]", Chrome: ["Chrome/[VER]", "CriOS/[VER]", "CrMo/[VER]"], Coast: ["Coast/[VER]"], Dolfin: "Dolfin/[VER]", Firefox: ["Firefox/[VER]", "FxiOS/[VER]"], Fennec: "Fennec/[VER]", Edge: "Edge/[VER]", IE: ["IEMobile/[VER];", "IEMobile [VER]", "MSIE [VER];", "Trident/[0-9.]+;.*rv:[VER]"], NetFront: "NetFront/[VER]", NokiaBrowser: "NokiaBrowser/[VER]", Opera: [" OPR/[VER]", "Opera Mini/[VER]", "Version/[VER]"], "Opera Mini": "Opera Mini/[VER]", "Opera Mobi": "Version/[VER]", UCBrowser: ["UCWEB[VER]", "UC.*Browser/[VER]"], MQQBrowser: "MQQBrowser/[VER]", MicroMessenger: "MicroMessenger/[VER]", baiduboxapp: "baiduboxapp/[VER]", baidubrowser: "baidubrowser/[VER]", SamsungBrowser: "SamsungBrowser/[VER]", Iron: "Iron/[VER]", Safari: ["Version/[VER]", "Safari/[VER]"], Skyfire: "Skyfire/[VER]", Tizen: "Tizen/[VER]", Webkit: "webkit[ /][VER]", PaleMoon: "PaleMoon/[VER]", Gecko: "Gecko/[VER]", Trident: "Trident/[VER]", Presto: "Presto/[VER]", Goanna: "Goanna/[VER]", iOS: " \\bi?OS\\b [VER][ ;]{1}", Android: "Android [VER]", BlackBerry: ["BlackBerry[\\w]+/[VER]", "BlackBerry.*Version/[VER]", "Version/[VER]"], BREW: "BREW [VER]", Java: "Java/[VER]", "Windows Phone OS": ["Windows Phone OS [VER]", "Windows Phone [VER]"], "Windows Phone": "Windows Phone [VER]", "Windows CE": "Windows CE/[VER]", "Windows NT": "Windows NT [VER]", Symbian: ["SymbianOS/[VER]", "Symbian/[VER]"], webOS: ["webOS/[VER]", "hpwOS/[VER];"] }, utils: { Bot: "Googlebot|facebookexternalhit|AdsBot-Google|Google Keyword Suggestion|Facebot|YandexBot|YandexMobileBot|bingbot|ia_archiver|AhrefsBot|Ezooms|GSLFbot|WBSearchBot|Twitterbot|TweetmemeBot|Twikle|PaperLiBot|Wotbox|UnwindFetchor|Exabot|MJ12bot|YandexImages|TurnitinBot|Pingdom", MobileBot: "Googlebot-Mobile|AdsBot-Google-Mobile|YahooSeeker/M1A1-R2D2", DesktopMode: "WPDesktop", TV: "SonyDTV|HbbTV", WebKit: "(webkit)[ /]([\\w.]+)", Console: "\\b(Nintendo|Nintendo WiiU|Nintendo 3DS|Nintendo Switch|PLAYSTATION|Xbox)\\b", Watch: "SM-V700" } }, detectMobileBrowsers: { fullPattern: /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i, shortPattern: /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i, tabletPattern: /android|ipad|playbook|silk/i } },
                c = Object.prototype.hasOwnProperty;

            function t(e, t) { return null != e && null != t && e.toLowerCase() === t.toLowerCase() }

            function i(e, t) { var i, n, r = e.length; if (!r || !t) return !1; for (i = t.toLowerCase(), n = 0; n < r; ++n)
                    if (i === e[n].toLowerCase()) return !0;
                return !1 }

            function h(e) { for (var t in e) c.call(e, t) && (e[t] = new RegExp(e[t], "i")) }

            function o(e, t) { this.ua = (e || "").substr(0, 500), this._cache = {}, this.maxPhoneWidth = t || 600 } return l.FALLBACK_PHONE = "UnknownPhone", l.FALLBACK_TABLET = "UnknownTablet", l.FALLBACK_MOBILE = "UnknownMobile", s = "isArray" in Array ? Array.isArray : function(e) { return "[object Array]" === Object.prototype.toString.call(e) },
                function() { var e, t, i, n, r, a, o = l.mobileDetectRules; for (e in o.props)
                        if (c.call(o.props, e)) { for (t = o.props[e], s(t) || (t = [t]), r = t.length, n = 0; n < r; ++n) 0 <= (a = (i = t[n]).indexOf("[VER]")) && (i = i.substring(0, a) + "([\\w._\\+]+)" + i.substring(a + 5)), t[n] = new RegExp(i, "i");
                            o.props[e] = t }
                    h(o.oss), h(o.phones), h(o.tablets), h(o.uas), h(o.utils), o.oss0 = { WindowsPhoneOS: o.oss.WindowsPhoneOS, WindowsMobileOS: o.oss.WindowsMobileOS } }(), l.findMatch = function(e, t) { for (var i in e)
                        if (c.call(e, i) && e[i].test(t)) return i;
                    return null }, l.findMatches = function(e, t) { var i = []; for (var n in e) c.call(e, n) && e[n].test(t) && i.push(n); return i }, l.getVersionStr = function(e, t) { var i, n, r, a, o = l.mobileDetectRules.props; if (c.call(o, e))
                        for (r = (i = o[e]).length, n = 0; n < r; ++n)
                            if (null !== (a = i[n].exec(t))) return a[1];
                    return null }, l.getVersion = function(e, t) { var i = l.getVersionStr(e, t); return i ? l.prepareVersionNo(i) : NaN }, l.prepareVersionNo = function(e) { var t; return 1 === (t = e.split(/[a-z._ \/\-]/i)).length && (e = t[0]), 1 < t.length && (e = t[0] + ".", t.shift(), e += t.join("")), Number(e) }, l.isMobileFallback = function(e) { return l.detectMobileBrowsers.fullPattern.test(e) || l.detectMobileBrowsers.shortPattern.test(e.substr(0, 4)) }, l.isTabletFallback = function(e) { return l.detectMobileBrowsers.tabletPattern.test(e) }, l.prepareDetectionCache = function(e, t, i) { if (e.mobile === u) { var n, r, a; if (r = l.findMatch(l.mobileDetectRules.tablets, t)) return e.mobile = e.tablet = r, void(e.phone = null); if (n = l.findMatch(l.mobileDetectRules.phones, t)) return e.mobile = e.phone = n, void(e.tablet = null);
                        l.isMobileFallback(t) ? (a = o.isPhoneSized(i)) === u ? (e.mobile = l.FALLBACK_MOBILE, e.tablet = e.phone = null) : a ? (e.mobile = e.phone = l.FALLBACK_PHONE, e.tablet = null) : (e.mobile = e.tablet = l.FALLBACK_TABLET, e.phone = null) : l.isTabletFallback(t) ? (e.mobile = e.tablet = l.FALLBACK_TABLET, e.phone = null) : e.mobile = e.tablet = e.phone = null } }, l.mobileGrade = function(e) { var t = null !== e.mobile(); return e.os("iOS") && 4.3 <= e.version("iPad") || e.os("iOS") && 3.1 <= e.version("iPhone") || e.os("iOS") && 3.1 <= e.version("iPod") || 2.1 < e.version("Android") && e.is("Webkit") || 7 <= e.version("Windows Phone OS") || e.is("BlackBerry") && 6 <= e.version("BlackBerry") || e.match("Playbook.*Tablet") || 1.4 <= e.version("webOS") && e.match("Palm|Pre|Pixi") || e.match("hp.*TouchPad") || e.is("Firefox") && 12 <= e.version("Firefox") || e.is("Chrome") && e.is("AndroidOS") && 4 <= e.version("Android") || e.is("Skyfire") && 4.1 <= e.version("Skyfire") && e.is("AndroidOS") && 2.3 <= e.version("Android") || e.is("Opera") && 11 < e.version("Opera Mobi") && e.is("AndroidOS") || e.is("MeeGoOS") || e.is("Tizen") || e.is("Dolfin") && 2 <= e.version("Bada") || (e.is("UC Browser") || e.is("Dolfin")) && 2.3 <= e.version("Android") || e.match("Kindle Fire") || e.is("Kindle") && 3 <= e.version("Kindle") || e.is("AndroidOS") && e.is("NookTablet") || 11 <= e.version("Chrome") && !t || 5 <= e.version("Safari") && !t || 4 <= e.version("Firefox") && !t || 7 <= e.version("MSIE") && !t || 10 <= e.version("Opera") && !t ? "A" : e.os("iOS") && e.version("iPad") < 4.3 || e.os("iOS") && e.version("iPhone") < 3.1 || e.os("iOS") && e.version("iPod") < 3.1 || e.is("Blackberry") && 5 <= e.version("BlackBerry") && e.version("BlackBerry") < 6 || 5 <= e.version("Opera Mini") && e.version("Opera Mini") <= 6.5 && (2.3 <= e.version("Android") || e.is("iOS")) || e.match("NokiaN8|NokiaC7|N97.*Series60|Symbian/3") || 11 <= e.version("Opera Mobi") && e.is("SymbianOS") ? "B" : (e.version("BlackBerry") < 5 || e.match("MSIEMobile|Windows CE.*Mobile") || e.version("Windows Mobile"), "C") }, l.detectOS = function(e) { return l.findMatch(l.mobileDetectRules.oss0, e) || l.findMatch(l.mobileDetectRules.oss, e) }, l.getDeviceSmallerSide = function() { return window.screen.width < window.screen.height ? window.screen.width : window.screen.height }, o.prototype = { constructor: o, mobile: function() { return l.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth), this._cache.mobile }, phone: function() { return l.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth), this._cache.phone }, tablet: function() { return l.prepareDetectionCache(this._cache, this.ua, this.maxPhoneWidth), this._cache.tablet }, userAgent: function() { return this._cache.userAgent === u && (this._cache.userAgent = l.findMatch(l.mobileDetectRules.uas, this.ua)), this._cache.userAgent }, userAgents: function() { return this._cache.userAgents === u && (this._cache.userAgents = l.findMatches(l.mobileDetectRules.uas, this.ua)), this._cache.userAgents }, os: function() { return this._cache.os === u && (this._cache.os = l.detectOS(this.ua)), this._cache.os }, version: function(e) { return l.getVersion(e, this.ua) }, versionStr: function(e) { return l.getVersionStr(e, this.ua) }, is: function(e) { return i(this.userAgents(), e) || t(e, this.os()) || t(e, this.phone()) || t(e, this.tablet()) || i(l.findMatches(l.mobileDetectRules.utils, this.ua), e) }, match: function(e) { return e instanceof RegExp || (e = new RegExp(e, "i")), e.test(this.ua) }, isPhoneSized: function(e) { return o.isPhoneSized(e || this.maxPhoneWidth) }, mobileGrade: function() { return this._cache.grade === u && (this._cache.grade = l.mobileGrade(this)), this._cache.grade } }, o.isPhoneSized = "undefined" != typeof window && window.screen ? function(e) { return e < 0 ? u : l.getDeviceSmallerSide() <= e } : function() {}, o._impl = l, o.version = "1.4.3 2018-09-08", o }) }, {}], 14: [function(e, t, i) { t.exports = function(q) {
            function e(e, t) { var i, n, r, a, o;
                this.object = e, this.domElement = void 0 !== t ? t : document, this.enabled = !0, this.target = new q.Vector3, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = .25, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.enableKeys = !0, this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }, this.mouseButtons = { ORBIT: q.MOUSE.LEFT, ZOOM: q.MOUSE.MIDDLE, PAN: q.MOUSE.RIGHT }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.getPolarAngle = function() { return f.phi }, this.getAzimuthalAngle = function() { return f.theta }, this.reset = function() { s.target.copy(s.target0), s.object.position.copy(s.position0), s.object.zoom = s.zoom0, s.object.updateProjectionMatrix(), s.dispatchEvent(l), s.update(), d = u.NONE }, this.update = (i = new q.Vector3, n = (new q.Quaternion).setFromUnitVectors(e.up, new q.Vector3(0, 1, 0)), r = n.clone().inverse(), a = new q.Vector3, o = new q.Quaternion, function() { var e = s.object.position; return i.copy(e).sub(s.target), i.applyQuaternion(n), f.setFromVector3(i), s.autoRotate && d === u.NONE && C(2 * Math.PI / 60 / 60 * s.autoRotateSpeed), f.theta += m.theta, f.phi += m.phi, f.theta = Math.max(s.minAzimuthAngle, Math.min(s.maxAzimuthAngle, f.theta)), f.phi = Math.max(s.minPolarAngle, Math.min(s.maxPolarAngle, f.phi)), f.makeSafe(), f.radius *= g, f.radius = Math.max(s.minDistance, Math.min(s.maxDistance, f.radius)), s.target.add(v), i.setFromSpherical(f), i.applyQuaternion(r), e.copy(s.target).add(i), s.object.lookAt(s.target), !0 === s.enableDamping ? (m.theta *= 1 - s.dampingFactor, m.phi *= 1 - s.dampingFactor) : m.set(0, 0, 0), g = 1, v.set(0, 0, 0), !(!(M || a.distanceToSquared(s.object.position) > p || 8 * (1 - o.dot(s.object.quaternion)) > p) || (s.dispatchEvent(l), a.copy(s.object.position), o.copy(s.object.quaternion), M = !1)) }), this.dispose = function() { s.domElement.removeEventListener("contextmenu", Y, !1), s.domElement.removeEventListener("mousedown", F, !1), s.domElement.removeEventListener("wheel", U, !1), s.domElement.removeEventListener("touchstart", j, !1), s.domElement.removeEventListener("touchend", X, !1), s.domElement.removeEventListener("touchmove", W, !1), document.removeEventListener("mousemove", z, !1), document.removeEventListener("mouseup", k, !1), window.removeEventListener("keydown", V, !1) }; var s = this,
                    l = { type: "change" },
                    c = { type: "start" },
                    h = { type: "end" },
                    u = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 },
                    d = u.NONE,
                    p = 1e-6,
                    f = new q.Spherical,
                    m = new q.Spherical,
                    g = 1,
                    v = new q.Vector3,
                    M = !1,
                    y = new q.Vector2,
                    b = new q.Vector2,
                    _ = new q.Vector2,
                    x = new q.Vector2,
                    T = new q.Vector2,
                    w = new q.Vector2,
                    S = new q.Vector2,
                    E = new q.Vector2,
                    P = new q.Vector2;

                function A() { return Math.pow(.95, s.zoomSpeed) }

                function C(e) { m.theta -= e }

                function L(e) { m.phi -= e } var R, H, O, G = (R = new q.Vector3, function(e, t) { R.setFromMatrixColumn(t, 0), R.multiplyScalar(-e), v.add(R) }),
                    D = (H = new q.Vector3, function(e, t) { H.setFromMatrixColumn(t, 1), H.multiplyScalar(e), v.add(H) }),
                    I = (O = new q.Vector3, function(e, t) { var i = s.domElement === document ? s.domElement.body : s.domElement; if (s.object instanceof q.PerspectiveCamera) { var n = s.object.position;
                            O.copy(n).sub(s.target); var r = O.length();
                            r *= Math.tan(s.object.fov / 2 * Math.PI / 180), G(2 * e * r / i.clientHeight, s.object.matrix), D(2 * t * r / i.clientHeight, s.object.matrix) } else s.object instanceof q.OrthographicCamera ? (G(e * (s.object.right - s.object.left) / s.object.zoom / i.clientWidth, s.object.matrix), D(t * (s.object.top - s.object.bottom) / s.object.zoom / i.clientHeight, s.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), s.enablePan = !1) });

                function B(e) { s.object instanceof q.PerspectiveCamera ? g /= e : s.object instanceof q.OrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom * e)), s.object.updateProjectionMatrix(), M = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1) }

                function N(e) { s.object instanceof q.PerspectiveCamera ? g *= e : s.object instanceof q.OrthographicCamera ? (s.object.zoom = Math.max(s.minZoom, Math.min(s.maxZoom, s.object.zoom / e)), s.object.updateProjectionMatrix(), M = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), s.enableZoom = !1) }

                function F(e) { if (!1 !== s.enabled) { if (e.preventDefault(), e.button === s.mouseButtons.ORBIT) { if (!1 === s.enableRotate) return;
                            n = e, y.set(n.clientX, n.clientY), d = u.ROTATE } else if (e.button === s.mouseButtons.ZOOM) { if (!1 === s.enableZoom) return;
                            i = e, S.set(i.clientX, i.clientY), d = u.DOLLY } else if (e.button === s.mouseButtons.PAN) { if (!1 === s.enablePan) return;
                            t = e, x.set(t.clientX, t.clientY), d = u.PAN } var t, i, n;
                        d !== u.NONE && (document.addEventListener("mousemove", z, !1), document.addEventListener("mouseup", k, !1), s.dispatchEvent(c)) } }

                function z(e) { var t, i; if (!1 !== s.enabled)
                        if (e.preventDefault(), d === u.ROTATE) { if (!1 === s.enableRotate) return;! function(e) { b.set(e.clientX, e.clientY), _.subVectors(b, y); var t = s.domElement === document ? s.domElement.body : s.domElement;
                                C(2 * Math.PI * _.x / t.clientWidth * s.rotateSpeed), L(2 * Math.PI * _.y / t.clientHeight * s.rotateSpeed), y.copy(b), s.update() }(e) } else if (d === u.DOLLY) { if (!1 === s.enableZoom) return;
                        i = e, E.set(i.clientX, i.clientY), P.subVectors(E, S), 0 < P.y ? B(A()) : P.y < 0 && N(A()), S.copy(E), s.update() } else if (d === u.PAN) { if (!1 === s.enablePan) return;
                        t = e, T.set(t.clientX, t.clientY), w.subVectors(T, x), I(w.x, w.y), x.copy(T), s.update() } }

                function k(e) {!1 !== s.enabled && (document.removeEventListener("mousemove", z, !1), document.removeEventListener("mouseup", k, !1), s.dispatchEvent(h), d = u.NONE) }

                function U(e) { var t;!1 === s.enabled || !1 === s.enableZoom || d !== u.NONE && d !== u.ROTATE || (e.preventDefault(), e.stopPropagation(), (t = e).deltaY < 0 ? N(A()) : 0 < t.deltaY && B(A()), s.update(), s.dispatchEvent(c), s.dispatchEvent(h)) }

                function V(e) {!1 !== s.enabled && !1 !== s.enableKeys && !1 !== s.enablePan && function(e) { switch (e.keyCode) {
                            case s.keys.UP:
                                I(0, s.keyPanSpeed), s.update(); break;
                            case s.keys.BOTTOM:
                                I(0, -s.keyPanSpeed), s.update(); break;
                            case s.keys.LEFT:
                                I(s.keyPanSpeed, 0), s.update(); break;
                            case s.keys.RIGHT:
                                I(-s.keyPanSpeed, 0), s.update() } }(e) }

                function j(e) { if (!1 !== s.enabled) { switch (e.touches.length) {
                            case 1:
                                if (!1 === s.enableRotate) return;
                                o = e, y.set(o.touches[0].pageX, o.touches[0].pageY), d = u.TOUCH_ROTATE; break;
                            case 2:
                                if (!1 === s.enableZoom) return;
                                n = (i = e).touches[0].pageX - i.touches[1].pageX, r = i.touches[0].pageY - i.touches[1].pageY, a = Math.sqrt(n * n + r * r), S.set(0, a), d = u.TOUCH_DOLLY; break;
                            case 3:
                                if (!1 === s.enablePan) return;
                                t = e, x.set(t.touches[0].pageX, t.touches[0].pageY), d = u.TOUCH_PAN; break;
                            default:
                                d = u.NONE } var t, i, n, r, a, o;
                        d !== u.NONE && s.dispatchEvent(c) } }

                function W(e) { var t, i, n, r, a; if (!1 !== s.enabled) switch (e.preventDefault(), e.stopPropagation(), e.touches.length) {
                        case 1:
                            if (!1 === s.enableRotate) return; if (d !== u.TOUCH_ROTATE) return;! function(e) { b.set(e.touches[0].pageX, e.touches[0].pageY), _.subVectors(b, y); var t = s.domElement === document ? s.domElement.body : s.domElement;
                                C(2 * Math.PI * _.x / t.clientWidth * s.rotateSpeed), L(2 * Math.PI * _.y / t.clientHeight * s.rotateSpeed), y.copy(b), s.update() }(e); break;
                        case 2:
                            if (!1 === s.enableZoom) return; if (d !== u.TOUCH_DOLLY) return;
                            n = (i = e).touches[0].pageX - i.touches[1].pageX, r = i.touches[0].pageY - i.touches[1].pageY, a = Math.sqrt(n * n + r * r), E.set(0, a), P.subVectors(E, S), 0 < P.y ? N(A()) : P.y < 0 && B(A()), S.copy(E), s.update(); break;
                        case 3:
                            if (!1 === s.enablePan) return; if (d !== u.TOUCH_PAN) return;
                            t = e, T.set(t.touches[0].pageX, t.touches[0].pageY), w.subVectors(T, x), I(w.x, w.y), x.copy(T), s.update(); break;
                        default:
                            d = u.NONE } }

                function X(e) {!1 !== s.enabled && (s.dispatchEvent(h), d = u.NONE) }

                function Y(e) { e.preventDefault() }
                s.domElement.addEventListener("contextmenu", Y, !1), s.domElement.addEventListener("mousedown", F, !1), s.domElement.addEventListener("wheel", U, !1), s.domElement.addEventListener("touchstart", j, !1), s.domElement.addEventListener("touchend", X, !1), s.domElement.addEventListener("touchmove", W, !1), window.addEventListener("keydown", V, !1), this.update() } return (e.prototype = Object.create(q.EventDispatcher.prototype)).constructor = e, Object.defineProperties(e.prototype, { center: { get: function() { return console.warn("THREE.OrbitControls: .center has been renamed to .target"), this.target } }, noZoom: { get: function() { return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), !this.enableZoom }, set: function(e) { console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."), this.enableZoom = !e } }, noRotate: { get: function() { return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), !this.enableRotate }, set: function(e) { console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."), this.enableRotate = !e } }, noPan: { get: function() { return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), !this.enablePan }, set: function(e) { console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."), this.enablePan = !e } }, noKeys: { get: function() { return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), !this.enableKeys }, set: function(e) { console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."), this.enableKeys = !e } }, staticMoving: { get: function() { return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), !this.enableDamping }, set: function(e) { console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."), this.enableDamping = !e } }, dynamicDampingFactor: { get: function() { return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor }, set: function(e) { console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."), this.dampingFactor = e } } }), e } }, {}], 15: [function(e, t, i) { var n, r;
        n = this, r = function(e) { "use strict";

            function t() {}
            void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(e) { return "number" == typeof e && isFinite(e) && Math.floor(e) === e }), void 0 === Math.sign && (Math.sign = function(e) { return e < 0 ? -1 : 0 < e ? 1 : +e }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", { get: function() { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function(e) { if (null == e) throw new TypeError("Cannot convert undefined or null to object"); for (var t = Object(e), i = 1; i < arguments.length; i++) { var n = arguments[i]; if (null != n)
                        for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }), Object.assign(t.prototype, { addEventListener: function(e, t) { void 0 === this._listeners && (this._listeners = {}); var i = this._listeners;
                    void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t) }, hasEventListener: function(e, t) { if (void 0 === this._listeners) return !1; var i = this._listeners; return void 0 !== i[e] && -1 !== i[e].indexOf(t) }, removeEventListener: function(e, t) { if (void 0 !== this._listeners) { var i = this._listeners[e]; if (void 0 !== i) { var n = i.indexOf(t); - 1 !== n && i.splice(n, 1) } } }, dispatchEvent: function(e) { if (void 0 !== this._listeners) { var t = this._listeners[e.type]; if (void 0 !== t) { e.target = this; for (var i = t.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, e) } } } }); var i, n, h, u, r, a, o, s, l, c, d, p, f, m, g, v, M, y, b, _, x, T, X = 0,
                Y = 1,
                q = 2,
                F = 1,
                z = 2,
                D = 0,
                xe = 1,
                ee = 2,
                w = 0,
                S = 2,
                Z = 0,
                J = 1,
                K = 2,
                Q = 3,
                $ = 4,
                te = 5,
                ie = 100,
                E = 101,
                P = 102,
                A = 103,
                C = 104,
                L = 200,
                R = 201,
                H = 202,
                O = 203,
                G = 204,
                I = 205,
                B = 206,
                N = 207,
                k = 208,
                U = 209,
                V = 210,
                ne = 0,
                re = 1,
                ae = 2,
                oe = 3,
                se = 4,
                le = 5,
                ce = 6,
                he = 7,
                j = 0,
                W = 1,
                ue = 2,
                de = 0,
                Te = 1,
                pe = 2,
                fe = 3,
                me = 4,
                ge = 5,
                ve = 301,
                Me = 302,
                ye = 303,
                be = 304,
                _e = 305,
                we = 306,
                Se = 307,
                Ee = 1e3,
                Pe = 1001,
                Ae = 1002,
                Ce = 1003,
                Le = 1004,
                Re = 1005,
                He = 1006,
                Oe = 1007,
                Ge = 1008,
                De = 1009,
                Ie = 1010,
                Be = 1011,
                Ne = 1012,
                Fe = 1013,
                ze = 1014,
                ke = 1015,
                Ue = 1016,
                Ve = 1017,
                je = 1018,
                We = 1019,
                Xe = 1020,
                Ye = 1021,
                qe = 1022,
                Ze = 1023,
                Je = 1024,
                Ke = 1025,
                Qe = Ze,
                $e = 1026,
                et = 1027,
                tt = 1028,
                it = 33776,
                nt = 33777,
                rt = 33778,
                at = 33779,
                ot = 35840,
                st = 35841,
                lt = 35842,
                ct = 35843,
                ht = 36196,
                ut = 37808,
                dt = 37809,
                pt = 37810,
                ft = 37811,
                mt = 37812,
                gt = 37813,
                vt = 37814,
                Mt = 37815,
                yt = 37816,
                bt = 37817,
                _t = 37818,
                xt = 37819,
                Tt = 37820,
                wt = 37821,
                St = 2300,
                Et = 2301,
                Pt = 2400,
                At = 2401,
                Ct = 2402,
                Lt = 0,
                Rt = 3e3,
                Ht = 3001,
                Ot = 3007,
                Gt = 3002,
                Dt = 3004,
                It = 3005,
                Bt = 3006,
                Nt = 3200,
                Ft = 3201,
                zt = 0,
                kt = 1,
                Ut = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function() { for (var r = [], e = 0; e < 256; e++) r[e] = (e < 16 ? "0" : "") + e.toString(16); return function() { var e = 4294967295 * Math.random() | 0,
                                t = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0; return (r[255 & e] + r[e >> 8 & 255] + r[e >> 16 & 255] + r[e >> 24 & 255] + "-" + r[255 & t] + r[t >> 8 & 255] + "-" + r[t >> 16 & 15 | 64] + r[t >> 24 & 255] + "-" + r[63 & i | 128] + r[i >> 8 & 255] + "-" + r[i >> 16 & 255] + r[i >> 24 & 255] + r[255 & n] + r[n >> 8 & 255] + r[n >> 16 & 255] + r[n >> 24 & 255]).toUpperCase() } }(), clamp: function(e, t, i) { return Math.max(t, Math.min(i, e)) }, euclideanModulo: function(e, t) { return (e % t + t) % t }, mapLinear: function(e, t, i, n, r) { return n + (e - t) * (r - n) / (i - t) }, lerp: function(e, t, i) { return (1 - i) * e + i * t }, smoothstep: function(e, t, i) { return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e) }, smootherstep: function(e, t, i) { return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10) }, randInt: function(e, t) { return e + Math.floor(Math.random() * (t - e + 1)) }, randFloat: function(e, t) { return e + Math.random() * (t - e) }, randFloatSpread: function(e) { return e * (.5 - Math.random()) }, degToRad: function(e) { return e * Ut.DEG2RAD }, radToDeg: function(e) { return e * Ut.RAD2DEG }, isPowerOfTwo: function(e) { return 0 == (e & e - 1) && 0 !== e }, ceilPowerOfTwo: function(e) { return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2)) }, floorPowerOfTwo: function(e) { return Math.pow(2, Math.floor(Math.log(e) / Math.LN2)) } };

            function Vt(e, t) { this.x = e || 0, this.y = t || 0 }

            function jt() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") }

            function Wt(e, t, i, n) { this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1 }

            function Xt(e, t, i) { this.x = e || 0, this.y = t || 0, this.z = i || 0 }

            function Yt() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") }
            Object.defineProperties(Vt.prototype, { width: { get: function() { return this.x }, set: function(e) { this.x = e } }, height: { get: function() { return this.y }, set: function(e) { this.y = e } } }), Object.assign(Vt.prototype, { isVector2: !0, set: function(e, t) { return this.x = e, this.y = t, this }, setScalar: function(e) { return this.x = e, this.y = e, this }, setX: function(e) { return this.x = e, this }, setY: function(e) { return this.y = e, this }, setComponent: function(e, t) { switch (e) {
                        case 0:
                            this.x = t; break;
                        case 1:
                            this.y = t; break;
                        default:
                            throw new Error("index is out of range: " + e) } return this }, getComponent: function(e) { switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e) } }, clone: function() { return new this.constructor(this.x, this.y) }, copy: function(e) { return this.x = e.x, this.y = e.y, this }, add: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this) }, addScalar: function(e) { return this.x += e, this.y += e, this }, addVectors: function(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this }, addScaledVector: function(e, t) { return this.x += e.x * t, this.y += e.y * t, this }, sub: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this) }, subScalar: function(e) { return this.x -= e, this.y -= e, this }, subVectors: function(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this }, multiply: function(e) { return this.x *= e.x, this.y *= e.y, this }, multiplyScalar: function(e) { return this.x *= e, this.y *= e, this }, divide: function(e) { return this.x /= e.x, this.y /= e.y, this }, divideScalar: function(e) { return this.multiplyScalar(1 / e) }, applyMatrix3: function(e) { var t = this.x,
                        i = this.y,
                        n = e.elements; return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this }, min: function(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this }, max: function(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this }, clamp: function(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this }, clampScalar: (i = new Vt, n = new Vt, function(e, t) { return i.set(e, e), n.set(t, t), this.clamp(i, n) }), clampLength: function(e, t) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) }, floor: function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function() { return this.x = -this.x, this.y = -this.y, this }, dot: function(e) { return this.x * e.x + this.y * e.y }, cross: function(e) { return this.x * e.y - this.y * e.x }, lengthSq: function() { return this.x * this.x + this.y * this.y }, length: function() { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function() { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function() { return this.divideScalar(this.length() || 1) }, angle: function() { var e = Math.atan2(this.y, this.x); return e < 0 && (e += 2 * Math.PI), e }, distanceTo: function(e) { return Math.sqrt(this.distanceToSquared(e)) }, distanceToSquared: function(e) { var t = this.x - e.x,
                        i = this.y - e.y; return t * t + i * i }, manhattanDistanceTo: function(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) }, setLength: function(e) { return this.normalize().multiplyScalar(e) }, lerp: function(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this }, lerpVectors: function(e, t, i) { return this.subVectors(t, e).multiplyScalar(i).add(e) }, equals: function(e) { return e.x === this.x && e.y === this.y }, fromArray: function(e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e }, fromBufferAttribute: function(e, t, i) { return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this }, rotateAround: function(e, t) { var i = Math.cos(t),
                        n = Math.sin(t),
                        r = this.x - e.x,
                        a = this.y - e.y; return this.x = r * i - a * n + e.x, this.y = r * n + a * i + e.y, this } }), Object.assign(jt.prototype, { isMatrix4: !0, set: function(e, t, i, n, r, a, o, s, l, c, h, u, d, p, f, m) { var g = this.elements; return g[0] = e, g[4] = t, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this }, identity: function() { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, clone: function() { return (new jt).fromArray(this.elements) }, copy: function(e) { var t = this.elements,
                        i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this }, copyPosition: function(e) { var t = this.elements,
                        i = e.elements; return t[12] = i[12], t[13] = i[13], t[14] = i[14], this }, extractBasis: function(e, t, i) { return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this }, makeBasis: function(e, t, i) { return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this }, extractRotation: (d = new Xt, function(e) { var t = this.elements,
                        i = e.elements,
                        n = 1 / d.setFromMatrixColumn(e, 0).length(),
                        r = 1 / d.setFromMatrixColumn(e, 1).length(),
                        a = 1 / d.setFromMatrixColumn(e, 2).length(); return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this }), makeRotationFromEuler: function(e) { e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var t = this.elements,
                        i = e.x,
                        n = e.y,
                        r = e.z,
                        a = Math.cos(i),
                        o = Math.sin(i),
                        s = Math.cos(n),
                        l = Math.sin(n),
                        c = Math.cos(r),
                        h = Math.sin(r); if ("XYZ" === e.order) { var u = a * c,
                            d = a * h,
                            p = o * c,
                            f = o * h;
                        t[0] = s * c, t[4] = -s * h, t[8] = l, t[1] = d + p * l, t[5] = u - f * l, t[9] = -o * s, t[2] = f - u * l, t[6] = p + d * l, t[10] = a * s } else if ("YXZ" === e.order) { var m = s * c,
                            g = s * h,
                            v = l * c,
                            M = l * h;
                        t[0] = m + M * o, t[4] = v * o - g, t[8] = a * l, t[1] = a * h, t[5] = a * c, t[9] = -o, t[2] = g * o - v, t[6] = M + m * o, t[10] = a * s } else if ("ZXY" === e.order) { m = s * c, g = s * h, v = l * c, M = l * h;
                        t[0] = m - M * o, t[4] = -a * h, t[8] = v + g * o, t[1] = g + v * o, t[5] = a * c, t[9] = M - m * o, t[2] = -a * l, t[6] = o, t[10] = a * s } else if ("ZYX" === e.order) { u = a * c, d = a * h, p = o * c, f = o * h;
                        t[0] = s * c, t[4] = p * l - d, t[8] = u * l + f, t[1] = s * h, t[5] = f * l + u, t[9] = d * l - p, t[2] = -l, t[6] = o * s, t[10] = a * s } else if ("YZX" === e.order) { var y = a * s,
                            b = a * l,
                            _ = o * s,
                            x = o * l;
                        t[0] = s * c, t[4] = x - y * h, t[8] = _ * h + b, t[1] = h, t[5] = a * c, t[9] = -o * c, t[2] = -l * c, t[6] = b * h + _, t[10] = y - x * h } else if ("XZY" === e.order) { y = a * s, b = a * l, _ = o * s, x = o * l;
                        t[0] = s * c, t[4] = -h, t[8] = l * c, t[1] = y * h + x, t[5] = a * c, t[9] = b * h - _, t[2] = _ * h - b, t[6] = o * c, t[10] = x * h + y } return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this }, makeRotationFromQuaternion: (l = new Xt(0, 0, 0), c = new Xt(1, 1, 1), function(e) { return this.compose(l, e, c) }), lookAt: (a = new Xt, o = new Xt, s = new Xt, function(e, t, i) { var n = this.elements; return s.subVectors(e, t), 0 === s.lengthSq() && (s.z = 1), s.normalize(), a.crossVectors(i, s), 0 === a.lengthSq() && (1 === Math.abs(i.z) ? s.x += 1e-4 : s.z += 1e-4, s.normalize(), a.crossVectors(i, s)), a.normalize(), o.crossVectors(s, a), n[0] = a.x, n[4] = o.x, n[8] = s.x, n[1] = a.y, n[5] = o.y, n[9] = s.y, n[2] = a.z, n[6] = o.z, n[10] = s.z, this }), multiply: function(e, t) { return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e) }, premultiply: function(e) { return this.multiplyMatrices(e, this) }, multiplyMatrices: function(e, t) { var i = e.elements,
                        n = t.elements,
                        r = this.elements,
                        a = i[0],
                        o = i[4],
                        s = i[8],
                        l = i[12],
                        c = i[1],
                        h = i[5],
                        u = i[9],
                        d = i[13],
                        p = i[2],
                        f = i[6],
                        m = i[10],
                        g = i[14],
                        v = i[3],
                        M = i[7],
                        y = i[11],
                        b = i[15],
                        _ = n[0],
                        x = n[4],
                        T = n[8],
                        w = n[12],
                        S = n[1],
                        E = n[5],
                        P = n[9],
                        A = n[13],
                        C = n[2],
                        L = n[6],
                        R = n[10],
                        H = n[14],
                        O = n[3],
                        G = n[7],
                        D = n[11],
                        I = n[15]; return r[0] = a * _ + o * S + s * C + l * O, r[4] = a * x + o * E + s * L + l * G, r[8] = a * T + o * P + s * R + l * D, r[12] = a * w + o * A + s * H + l * I, r[1] = c * _ + h * S + u * C + d * O, r[5] = c * x + h * E + u * L + d * G, r[9] = c * T + h * P + u * R + d * D, r[13] = c * w + h * A + u * H + d * I, r[2] = p * _ + f * S + m * C + g * O, r[6] = p * x + f * E + m * L + g * G, r[10] = p * T + f * P + m * R + g * D, r[14] = p * w + f * A + m * H + g * I, r[3] = v * _ + M * S + y * C + b * O, r[7] = v * x + M * E + y * L + b * G, r[11] = v * T + M * P + y * R + b * D, r[15] = v * w + M * A + y * H + b * I, this }, multiplyScalar: function(e) { var t = this.elements; return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this }, applyToBufferAttribute: (r = new Xt, function(e) { for (var t = 0, i = e.count; t < i; t++) r.x = e.getX(t), r.y = e.getY(t), r.z = e.getZ(t), r.applyMatrix4(this), e.setXYZ(t, r.x, r.y, r.z); return e }), determinant: function() { var e = this.elements,
                        t = e[0],
                        i = e[4],
                        n = e[8],
                        r = e[12],
                        a = e[1],
                        o = e[5],
                        s = e[9],
                        l = e[13],
                        c = e[2],
                        h = e[6],
                        u = e[10],
                        d = e[14]; return e[3] * (+r * s * h - n * l * h - r * o * u + i * l * u + n * o * d - i * s * d) + e[7] * (+t * s * d - t * l * u + r * a * u - n * a * d + n * l * c - r * s * c) + e[11] * (+t * l * h - t * o * d - r * a * h + i * a * d + r * o * c - i * l * c) + e[15] * (-n * o * c - t * s * h + t * o * u + n * a * h - i * a * u + i * s * c) }, transpose: function() { var e, t = this.elements; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this }, setPosition: function(e) { var t = this.elements; return t[12] = e.x, t[13] = e.y, t[14] = e.z, this }, getInverse: function(e, t) { var i = this.elements,
                        n = e.elements,
                        r = n[0],
                        a = n[1],
                        o = n[2],
                        s = n[3],
                        l = n[4],
                        c = n[5],
                        h = n[6],
                        u = n[7],
                        d = n[8],
                        p = n[9],
                        f = n[10],
                        m = n[11],
                        g = n[12],
                        v = n[13],
                        M = n[14],
                        y = n[15],
                        b = p * M * u - v * f * u + v * h * m - c * M * m - p * h * y + c * f * y,
                        _ = g * f * u - d * M * u - g * h * m + l * M * m + d * h * y - l * f * y,
                        x = d * v * u - g * p * u + g * c * m - l * v * m - d * c * y + l * p * y,
                        T = g * p * h - d * v * h - g * c * f + l * v * f + d * c * M - l * p * M,
                        w = r * b + a * _ + o * x + s * T; if (0 === w) { var S = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"; if (!0 === t) throw new Error(S); return console.warn(S), this.identity() } var E = 1 / w; return i[0] = b * E, i[1] = (v * f * s - p * M * s - v * o * m + a * M * m + p * o * y - a * f * y) * E, i[2] = (c * M * s - v * h * s + v * o * u - a * M * u - c * o * y + a * h * y) * E, i[3] = (p * h * s - c * f * s - p * o * u + a * f * u + c * o * m - a * h * m) * E, i[4] = _ * E, i[5] = (d * M * s - g * f * s + g * o * m - r * M * m - d * o * y + r * f * y) * E, i[6] = (g * h * s - l * M * s - g * o * u + r * M * u + l * o * y - r * h * y) * E, i[7] = (l * f * s - d * h * s + d * o * u - r * f * u - l * o * m + r * h * m) * E, i[8] = x * E, i[9] = (g * p * s - d * v * s - g * a * m + r * v * m + d * a * y - r * p * y) * E, i[10] = (l * v * s - g * c * s + g * a * u - r * v * u - l * a * y + r * c * y) * E, i[11] = (d * c * s - l * p * s - d * a * u + r * p * u + l * a * m - r * c * m) * E, i[12] = T * E, i[13] = (d * v * o - g * p * o + g * a * f - r * v * f - d * a * M + r * p * M) * E, i[14] = (g * c * o - l * v * o - g * a * h + r * v * h + l * a * M - r * c * M) * E, i[15] = (l * p * o - d * c * o + d * a * h - r * p * h - l * a * f + r * c * f) * E, this }, scale: function(e) { var t = this.elements,
                        i = e.x,
                        n = e.y,
                        r = e.z; return t[0] *= i, t[4] *= n, t[8] *= r, t[1] *= i, t[5] *= n, t[9] *= r, t[2] *= i, t[6] *= n, t[10] *= r, t[3] *= i, t[7] *= n, t[11] *= r, this }, getMaxScaleOnAxis: function() { var e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]; return Math.sqrt(Math.max(t, i, n)) }, makeTranslation: function(e, t, i) { return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this }, makeRotationX: function(e) { var t = Math.cos(e),
                        i = Math.sin(e); return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this }, makeRotationY: function(e) { var t = Math.cos(e),
                        i = Math.sin(e); return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this }, makeRotationZ: function(e) { var t = Math.cos(e),
                        i = Math.sin(e); return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function(e, t) { var i = Math.cos(t),
                        n = Math.sin(t),
                        r = 1 - i,
                        a = e.x,
                        o = e.y,
                        s = e.z,
                        l = r * a,
                        c = r * o; return this.set(l * a + i, l * o - n * s, l * s + n * o, 0, l * o + n * s, c * o + i, c * s - n * a, 0, l * s - n * o, c * s + n * a, r * s * s + i, 0, 0, 0, 0, 1), this }, makeScale: function(e, t, i) { return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this }, makeShear: function(e, t, i) { return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1), this }, compose: function(e, t, i) { var n = this.elements,
                        r = t._x,
                        a = t._y,
                        o = t._z,
                        s = t._w,
                        l = r + r,
                        c = a + a,
                        h = o + o,
                        u = r * l,
                        d = r * c,
                        p = r * h,
                        f = a * c,
                        m = a * h,
                        g = o * h,
                        v = s * l,
                        M = s * c,
                        y = s * h,
                        b = i.x,
                        _ = i.y,
                        x = i.z; return n[0] = (1 - (f + g)) * b, n[1] = (d + y) * b, n[2] = (p - M) * b, n[3] = 0, n[4] = (d - y) * _, n[5] = (1 - (u + g)) * _, n[6] = (m + v) * _, n[7] = 0, n[8] = (p + M) * x, n[9] = (m - v) * x, n[10] = (1 - (u + f)) * x, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this }, decompose: (h = new Xt, u = new jt, function(e, t, i) { var n = this.elements,
                        r = h.set(n[0], n[1], n[2]).length(),
                        a = h.set(n[4], n[5], n[6]).length(),
                        o = h.set(n[8], n[9], n[10]).length();
                    this.determinant() < 0 && (r = -r), e.x = n[12], e.y = n[13], e.z = n[14], u.copy(this); var s = 1 / r,
                        l = 1 / a,
                        c = 1 / o; return u.elements[0] *= s, u.elements[1] *= s, u.elements[2] *= s, u.elements[4] *= l, u.elements[5] *= l, u.elements[6] *= l, u.elements[8] *= c, u.elements[9] *= c, u.elements[10] *= c, t.setFromRotationMatrix(u), i.x = r, i.y = a, i.z = o, this }), makePerspective: function(e, t, i, n, r, a) { void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); var o = this.elements,
                        s = 2 * r / (t - e),
                        l = 2 * r / (i - n),
                        c = (t + e) / (t - e),
                        h = (i + n) / (i - n),
                        u = -(a + r) / (a - r),
                        d = -2 * a * r / (a - r); return o[0] = s, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = h, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = u, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this }, makeOrthographic: function(e, t, i, n, r, a) { var o = this.elements,
                        s = 1 / (t - e),
                        l = 1 / (i - n),
                        c = 1 / (a - r),
                        h = (t + e) * s,
                        u = (i + n) * l,
                        d = (a + r) * c; return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -h, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -u, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this }, equals: function(e) { for (var t = this.elements, i = e.elements, n = 0; n < 16; n++)
                        if (t[n] !== i[n]) return !1;
                    return !0 }, fromArray: function(e, t) { void 0 === t && (t = 0); for (var i = 0; i < 16; i++) this.elements[i] = e[i + t]; return this }, toArray: function(e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e } }), Object.assign(Wt, { slerp: function(e, t, i, n) { return i.copy(e).slerp(t, n) }, slerpFlat: function(e, t, i, n, r, a, o) { var s = i[n + 0],
                        l = i[n + 1],
                        c = i[n + 2],
                        h = i[n + 3],
                        u = r[a + 0],
                        d = r[a + 1],
                        p = r[a + 2],
                        f = r[a + 3]; if (h !== f || s !== u || l !== d || c !== p) { var m = 1 - o,
                            g = s * u + l * d + c * p + h * f,
                            v = 0 <= g ? 1 : -1,
                            M = 1 - g * g; if (M > Number.EPSILON) { var y = Math.sqrt(M),
                                b = Math.atan2(y, g * v);
                            m = Math.sin(m * b) / y, o = Math.sin(o * b) / y } var _ = o * v; if (s = s * m + u * _, l = l * m + d * _, c = c * m + p * _, h = h * m + f * _, m === 1 - o) { var x = 1 / Math.sqrt(s * s + l * l + c * c + h * h);
                            s *= x, l *= x, c *= x, h *= x } }
                    e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h } }), Object.defineProperties(Wt.prototype, { x: { get: function() { return this._x }, set: function(e) { this._x = e, this.onChangeCallback() } }, y: { get: function() { return this._y }, set: function(e) { this._y = e, this.onChangeCallback() } }, z: { get: function() { return this._z }, set: function(e) { this._z = e, this.onChangeCallback() } }, w: { get: function() { return this._w }, set: function(e) { this._w = e, this.onChangeCallback() } } }), Object.assign(Wt.prototype, { isQuaternion: !0, set: function(e, t, i, n) { return this._x = e, this._y = t, this._z = i, this._w = n, this.onChangeCallback(), this }, clone: function() { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function(e) { return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this }, setFromEuler: function(e, t) { if (!e || !e.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var i = e._x,
                        n = e._y,
                        r = e._z,
                        a = e.order,
                        o = Math.cos,
                        s = Math.sin,
                        l = o(i / 2),
                        c = o(n / 2),
                        h = o(r / 2),
                        u = s(i / 2),
                        d = s(n / 2),
                        p = s(r / 2); return "XYZ" === a ? (this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p) : "YXZ" === a ? (this._x = u * c * h + l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p) : "ZXY" === a ? (this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h - u * d * p) : "ZYX" === a ? (this._x = u * c * h - l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h + u * d * p) : "YZX" === a ? (this._x = u * c * h + l * d * p, this._y = l * d * h + u * c * p, this._z = l * c * p - u * d * h, this._w = l * c * h - u * d * p) : "XZY" === a && (this._x = u * c * h - l * d * p, this._y = l * d * h - u * c * p, this._z = l * c * p + u * d * h, this._w = l * c * h + u * d * p), !1 !== t && this.onChangeCallback(), this }, setFromAxisAngle: function(e, t) { var i = t / 2,
                        n = Math.sin(i); return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this.onChangeCallback(), this }, setFromRotationMatrix: function(e) { var t, i = e.elements,
                        n = i[0],
                        r = i[4],
                        a = i[8],
                        o = i[1],
                        s = i[5],
                        l = i[9],
                        c = i[2],
                        h = i[6],
                        u = i[10],
                        d = n + s + u; return this._z = 0 < d ? (t = .5 / Math.sqrt(d + 1), this._w = .25 / t, this._x = (h - l) * t, this._y = (a - c) * t, (o - r) * t) : s < n && u < n ? (t = 2 * Math.sqrt(1 + n - s - u), this._w = (h - l) / t, this._x = .25 * t, this._y = (r + o) / t, (a + c) / t) : u < s ? (t = 2 * Math.sqrt(1 + s - n - u), this._w = (a - c) / t, this._x = (r + o) / t, this._y = .25 * t, (l + h) / t) : (t = 2 * Math.sqrt(1 + u - n - s), this._w = (o - r) / t, this._x = (a + c) / t, this._y = (l + h) / t, .25 * t), this.onChangeCallback(), this }, setFromUnitVectors: (f = new Xt, function(e, t) { return void 0 === f && (f = new Xt), (p = e.dot(t) + 1) < 1e-6 ? (p = 0, Math.abs(e.x) > Math.abs(e.z) ? f.set(-e.y, e.x, 0) : f.set(0, -e.z, e.y)) : f.crossVectors(e, t), this._x = f.x, this._y = f.y, this._z = f.z, this._w = p, this.normalize() }), angleTo: function(e) { return 2 * Math.acos(Math.abs(Ut.clamp(this.dot(e), -1, 1))) }, rotateTowards: function(e, t) { var i = this.angleTo(e); if (0 === i) return this; var n = Math.min(1, t / i); return this.slerp(e, n), this }, inverse: function() { return this.conjugate() }, conjugate: function() { return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this }, dot: function(e) { return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w }, lengthSq: function() { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function() { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function() { var e = this.length(); return this._w = 0 === e ? (this._x = 0, this._y = 0, this._z = 0, 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w * e), this.onChangeCallback(), this }, multiply: function(e, t) { return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e) }, premultiply: function(e) { return this.multiplyQuaternions(e, this) }, multiplyQuaternions: function(e, t) { var i = e._x,
                        n = e._y,
                        r = e._z,
                        a = e._w,
                        o = t._x,
                        s = t._y,
                        l = t._z,
                        c = t._w; return this._x = i * c + a * o + n * l - r * s, this._y = n * c + a * s + r * o - i * l, this._z = r * c + a * l + i * s - n * o, this._w = a * c - i * o - n * s - r * l, this.onChangeCallback(), this }, slerp: function(e, t) { if (0 === t) return this; if (1 === t) return this.copy(e); var i = this._x,
                        n = this._y,
                        r = this._z,
                        a = this._w,
                        o = a * e._w + i * e._x + n * e._y + r * e._z; if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), 1 <= o) return this._w = a, this._x = i, this._y = n, this._z = r, this; var s = 1 - o * o; if (s <= Number.EPSILON) { var l = 1 - t; return this._w = l * a + t * this._w, this._x = l * i + t * this._x, this._y = l * n + t * this._y, this._z = l * r + t * this._z, this.normalize() } var c = Math.sqrt(s),
                        h = Math.atan2(c, o),
                        u = Math.sin((1 - t) * h) / c,
                        d = Math.sin(t * h) / c; return this._w = a * u + this._w * d, this._x = i * u + this._x * d, this._y = n * u + this._y * d, this._z = r * u + this._z * d, this.onChangeCallback(), this }, equals: function(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w }, fromArray: function(e, t) { return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e }, onChange: function(e) { return this.onChangeCallback = e, this }, onChangeCallback: function() {} }), Object.assign(Xt.prototype, { isVector3: !0, set: function(e, t, i) { return this.x = e, this.y = t, this.z = i, this }, setScalar: function(e) { return this.x = e, this.y = e, this.z = e, this }, setX: function(e) { return this.x = e, this }, setY: function(e) { return this.y = e, this }, setZ: function(e) { return this.z = e, this }, setComponent: function(e, t) { switch (e) {
                        case 0:
                            this.x = t; break;
                        case 1:
                            this.y = t; break;
                        case 2:
                            this.z = t; break;
                        default:
                            throw new Error("index is out of range: " + e) } return this }, getComponent: function(e) { switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e) } }, clone: function() { return new this.constructor(this.x, this.y, this.z) }, copy: function(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this }, add: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this) }, addScalar: function(e) { return this.x += e, this.y += e, this.z += e, this }, addVectors: function(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this }, addScaledVector: function(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this }, sub: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this) }, subScalar: function(e) { return this.x -= e, this.y -= e, this.z -= e, this }, subVectors: function(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this }, multiply: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this) }, multiplyScalar: function(e) { return this.x *= e, this.y *= e, this.z *= e, this }, multiplyVectors: function(e, t) { return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this }, applyEuler: (_ = new Wt, function(e) { return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(_.setFromEuler(e)) }), applyAxisAngle: (b = new Wt, function(e, t) { return this.applyQuaternion(b.setFromAxisAngle(e, t)) }), applyMatrix3: function(e) { var t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.elements; return this.x = r[0] * t + r[3] * i + r[6] * n, this.y = r[1] * t + r[4] * i + r[7] * n, this.z = r[2] * t + r[5] * i + r[8] * n, this }, applyMatrix4: function(e) { var t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.elements,
                        a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]); return this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a, this }, applyQuaternion: function(e) { var t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.x,
                        a = e.y,
                        o = e.z,
                        s = e.w,
                        l = s * t + a * n - o * i,
                        c = s * i + o * t - r * n,
                        h = s * n + r * i - a * t,
                        u = -r * t - a * i - o * n; return this.x = l * s + u * -r + c * -o - h * -a, this.y = c * s + u * -a + h * -r - l * -o, this.z = h * s + u * -o + l * -a - c * -r, this }, project: function(e) { return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix) }, unproject: (y = new jt, function(e) { return this.applyMatrix4(y.getInverse(e.projectionMatrix)).applyMatrix4(e.matrixWorld) }), transformDirection: function(e) { var t = this.x,
                        i = this.y,
                        n = this.z,
                        r = e.elements; return this.x = r[0] * t + r[4] * i + r[8] * n, this.y = r[1] * t + r[5] * i + r[9] * n, this.z = r[2] * t + r[6] * i + r[10] * n, this.normalize() }, divide: function(e) { return this.x /= e.x, this.y /= e.y, this.z /= e.z, this }, divideScalar: function(e) { return this.multiplyScalar(1 / e) }, min: function(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this }, max: function(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this }, clamp: function(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this }, clampScalar: (v = new Xt, M = new Xt, function(e, t) { return v.set(e, e, e), M.set(t, t, t), this.clamp(v, M) }), clampLength: function(e, t) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) }, floor: function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function(e) { return this.x * e.x + this.y * e.y + this.z * e.z }, lengthSq: function() { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function() { return this.divideScalar(this.length() || 1) }, setLength: function(e) { return this.normalize().multiplyScalar(e) }, lerp: function(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this }, lerpVectors: function(e, t, i) { return this.subVectors(t, e).multiplyScalar(i).add(e) }, cross: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t)) : this.crossVectors(this, e) }, crossVectors: function(e, t) { var i = e.x,
                        n = e.y,
                        r = e.z,
                        a = t.x,
                        o = t.y,
                        s = t.z; return this.x = n * s - r * o, this.y = r * a - i * s, this.z = i * o - n * a, this }, projectOnVector: function(e) { var t = e.dot(this) / e.lengthSq(); return this.copy(e).multiplyScalar(t) }, projectOnPlane: (g = new Xt, function(e) { return g.copy(this).projectOnVector(e), this.sub(g) }), reflect: (m = new Xt, function(e) { return this.sub(m.copy(e).multiplyScalar(2 * this.dot(e))) }), angleTo: function(e) { var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()); return Math.acos(Ut.clamp(t, -1, 1)) }, distanceTo: function(e) { return Math.sqrt(this.distanceToSquared(e)) }, distanceToSquared: function(e) { var t = this.x - e.x,
                        i = this.y - e.y,
                        n = this.z - e.z; return t * t + i * i + n * n }, manhattanDistanceTo: function(e) { return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z) }, setFromSpherical: function(e) { return this.setFromSphericalCoords(e.radius, e.phi, e.theta) }, setFromSphericalCoords: function(e, t, i) { var n = Math.sin(t) * e; return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this }, setFromCylindrical: function(e) { return this.setFromCylindricalCoords(e.radius, e.theta, e.y) }, setFromCylindricalCoords: function(e, t, i) { return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this }, setFromMatrixPosition: function(e) { var t = e.elements; return this.x = t[12], this.y = t[13], this.z = t[14], this }, setFromMatrixScale: function(e) { var t = this.setFromMatrixColumn(e, 0).length(),
                        i = this.setFromMatrixColumn(e, 1).length(),
                        n = this.setFromMatrixColumn(e, 2).length(); return this.x = t, this.y = i, this.z = n, this }, setFromMatrixColumn: function(e, t) { return this.fromArray(e.elements, 4 * t) }, equals: function(e) { return e.x === this.x && e.y === this.y && e.z === this.z }, fromArray: function(e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e }, fromBufferAttribute: function(e, t, i) { return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this } }), Object.assign(Yt.prototype, { isMatrix3: !0, set: function(e, t, i, n, r, a, o, s, l) { var c = this.elements; return c[0] = e, c[1] = n, c[2] = o, c[3] = t, c[4] = r, c[5] = s, c[6] = i, c[7] = a, c[8] = l, this }, identity: function() { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function() { return (new this.constructor).fromArray(this.elements) }, copy: function(e) { var t = this.elements,
                        i = e.elements; return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this }, setFromMatrix4: function(e) { var t = e.elements; return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this }, applyToBufferAttribute: (x = new Xt, function(e) { for (var t = 0, i = e.count; t < i; t++) x.x = e.getX(t), x.y = e.getY(t), x.z = e.getZ(t), x.applyMatrix3(this), e.setXYZ(t, x.x, x.y, x.z); return e }), multiply: function(e) { return this.multiplyMatrices(this, e) }, premultiply: function(e) { return this.multiplyMatrices(e, this) }, multiplyMatrices: function(e, t) { var i = e.elements,
                        n = t.elements,
                        r = this.elements,
                        a = i[0],
                        o = i[3],
                        s = i[6],
                        l = i[1],
                        c = i[4],
                        h = i[7],
                        u = i[2],
                        d = i[5],
                        p = i[8],
                        f = n[0],
                        m = n[3],
                        g = n[6],
                        v = n[1],
                        M = n[4],
                        y = n[7],
                        b = n[2],
                        _ = n[5],
                        x = n[8]; return r[0] = a * f + o * v + s * b, r[3] = a * m + o * M + s * _, r[6] = a * g + o * y + s * x, r[1] = l * f + c * v + h * b, r[4] = l * m + c * M + h * _, r[7] = l * g + c * y + h * x, r[2] = u * f + d * v + p * b, r[5] = u * m + d * M + p * _, r[8] = u * g + d * y + p * x, this }, multiplyScalar: function(e) { var t = this.elements; return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this }, determinant: function() { var e = this.elements,
                        t = e[0],
                        i = e[1],
                        n = e[2],
                        r = e[3],
                        a = e[4],
                        o = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8]; return t * a * c - t * o * l - i * r * c + i * o * s + n * r * l - n * a * s }, getInverse: function(e, t) { e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."); var i = e.elements,
                        n = this.elements,
                        r = i[0],
                        a = i[1],
                        o = i[2],
                        s = i[3],
                        l = i[4],
                        c = i[5],
                        h = i[6],
                        u = i[7],
                        d = i[8],
                        p = d * l - c * u,
                        f = c * h - d * s,
                        m = u * s - l * h,
                        g = r * p + a * f + o * m; if (0 === g) { var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"; if (!0 === t) throw new Error(v); return console.warn(v), this.identity() } var M = 1 / g; return n[0] = p * M, n[1] = (o * u - d * a) * M, n[2] = (c * a - o * l) * M, n[3] = f * M, n[4] = (d * r - o * h) * M, n[5] = (o * s - c * r) * M, n[6] = m * M, n[7] = (a * h - u * r) * M, n[8] = (l * r - a * s) * M, this }, transpose: function() { var e, t = this.elements; return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this }, getNormalMatrix: function(e) { return this.setFromMatrix4(e).getInverse(this).transpose() }, transposeIntoArray: function(e) { var t = this.elements; return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this }, setUvTransform: function(e, t, i, n, r, a, o) { var s = Math.cos(r),
                        l = Math.sin(r);
                    this.set(i * s, i * l, -i * (s * a + l * o) + a + e, -n * l, n * s, -n * (-l * a + s * o) + o + t, 0, 0, 1) }, scale: function(e, t) { var i = this.elements; return i[0] *= e, i[3] *= e, i[6] *= e, i[1] *= t, i[4] *= t, i[7] *= t, this }, rotate: function(e) { var t = Math.cos(e),
                        i = Math.sin(e),
                        n = this.elements,
                        r = n[0],
                        a = n[3],
                        o = n[6],
                        s = n[1],
                        l = n[4],
                        c = n[7]; return n[0] = t * r + i * s, n[3] = t * a + i * l, n[6] = t * o + i * c, n[1] = -i * r + t * s, n[4] = -i * a + t * l, n[7] = -i * o + t * c, this }, translate: function(e, t) { var i = this.elements; return i[0] += e * i[2], i[3] += e * i[5], i[6] += e * i[8], i[1] += t * i[2], i[4] += t * i[5], i[7] += t * i[8], this }, equals: function(e) { for (var t = this.elements, i = e.elements, n = 0; n < 9; n++)
                        if (t[n] !== i[n]) return !1;
                    return !0 }, fromArray: function(e, t) { void 0 === t && (t = 0); for (var i = 0; i < 9; i++) this.elements[i] = e[i + t]; return this }, toArray: function(e, t) { void 0 === e && (e = []), void 0 === t && (t = 0); var i = this.elements; return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e } }); var qt, Zt, Jt, Kt, Qt, $t, ei, ti, ii, ni, ri, ai, oi, si, li, ci, hi = { getDataURL: function(e) { var t; if ("undefined" == typeof HTMLCanvasElement) return e.src; if (e instanceof HTMLCanvasElement) t = e;
                        else { void 0 === T && (T = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), T.width = e.width, T.height = e.height; var i = T.getContext("2d");
                            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = T } return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png") } },
                ui = 0;

            function di(e, t, i, n, r, a, o, s, l, c) { Object.defineProperty(this, "id", { value: ui++ }), this.uuid = Ut.generateUUID(), this.name = "", this.image = void 0 !== e ? e : di.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : di.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : Pe, this.wrapT = void 0 !== n ? n : Pe, this.magFilter = void 0 !== r ? r : He, this.minFilter = void 0 !== a ? a : Ge, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== o ? o : Ze, this.type = void 0 !== s ? s : De, this.offset = new Vt(0, 0), this.repeat = new Vt(1, 1), this.center = new Vt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Yt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== c ? c : Rt, this.version = 0, this.onUpdate = null }

            function pi(e, t, i, n) { this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1 }

            function fi(e, t, i) { this.width = e, this.height = t, this.scissor = new pi(0, 0, e, t), this.scissorTest = !1, this.viewport = new pi(0, 0, e, t), i = i || {}, this.texture = new di(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : He, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null }

            function mi(e, t, i) { fi.call(this, e, t, i), this.samples = 4 }

            function gi(e, t, i) { fi.call(this, e, t, i) }

            function vi(e, t, i, n, r, a, o, s, l, c, h, u) { di.call(this, null, a, o, s, l, c, n, r, h, u), this.image = { data: e, width: t, height: i }, this.magFilter = void 0 !== l ? l : Ce, this.minFilter = void 0 !== c ? c : Ce, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 }

            function Mi(e, t) { this.min = void 0 !== e ? e : new Xt(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Xt(-1 / 0, -1 / 0, -1 / 0) }

            function yi(e, t) { this.center = void 0 !== e ? e : new Xt, this.radius = void 0 !== t ? t : 0 }

            function bi(e, t) { this.normal = void 0 !== e ? e : new Xt(1, 0, 0), this.constant = void 0 !== t ? t : 0 }

            function _i(e, t, i, n, r, a) { this.planes = [void 0 !== e ? e : new bi, void 0 !== t ? t : new bi, void 0 !== i ? i : new bi, void 0 !== n ? n : new bi, void 0 !== r ? r : new bi, void 0 !== a ? a : new bi] }
            di.DEFAULT_IMAGE = void 0, di.DEFAULT_MAPPING = 300, di.prototype = Object.assign(Object.create(t.prototype), { constructor: di, isTexture: !0, updateMatrix: function() { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.name = e.name, this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this }, toJSON: function(e) { var t = void 0 === e || "string" == typeof e; if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid]; var i = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { var n = this.image; if (void 0 === n.uuid && (n.uuid = Ut.generateUUID()), !t && void 0 === e.images[n.uuid]) { var r; if (Array.isArray(n)) { r = []; for (var a = 0, o = n.length; a < o; a++) r.push(hi.getDataURL(n[a])) } else r = hi.getDataURL(n);
                            e.images[n.uuid] = { uuid: n.uuid, url: r } }
                        i.image = n.uuid } return t || (e.textures[this.uuid] = i), i }, dispose: function() { this.dispatchEvent({ type: "dispose" }) }, transformUv: function(e) { if (300 !== this.mapping) return e; if (e.applyMatrix3(this.matrix), e.x < 0 || 1 < e.x) switch (this.wrapS) {
                        case Ee:
                            e.x = e.x - Math.floor(e.x); break;
                        case Pe:
                            e.x = e.x < 0 ? 0 : 1; break;
                        case Ae:
                            1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x) }
                    if (e.y < 0 || 1 < e.y) switch (this.wrapT) {
                        case Ee:
                            e.y = e.y - Math.floor(e.y); break;
                        case Pe:
                            e.y = e.y < 0 ? 0 : 1; break;
                        case Ae:
                            1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y) }
                    return this.flipY && (e.y = 1 - e.y), e } }), Object.defineProperty(di.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), Object.assign(pi.prototype, { isVector4: !0, set: function(e, t, i, n) { return this.x = e, this.y = t, this.z = i, this.w = n, this }, setScalar: function(e) { return this.x = e, this.y = e, this.z = e, this.w = e, this }, setX: function(e) { return this.x = e, this }, setY: function(e) { return this.y = e, this }, setZ: function(e) { return this.z = e, this }, setW: function(e) { return this.w = e, this }, setComponent: function(e, t) { switch (e) {
                        case 0:
                            this.x = t; break;
                        case 1:
                            this.y = t; break;
                        case 2:
                            this.z = t; break;
                        case 3:
                            this.w = t; break;
                        default:
                            throw new Error("index is out of range: " + e) } return this }, getComponent: function(e) { switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e) } }, clone: function() { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function(e) { return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this }, add: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this) }, addScalar: function(e) { return this.x += e, this.y += e, this.z += e, this.w += e, this }, addVectors: function(e, t) { return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this }, addScaledVector: function(e, t) { return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this }, sub: function(e, t) { return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this) }, subScalar: function(e) { return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this }, subVectors: function(e, t) { return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this }, multiplyScalar: function(e) { return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this }, applyMatrix4: function(e) { var t = this.x,
                        i = this.y,
                        n = this.z,
                        r = this.w,
                        a = e.elements; return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r, this }, divideScalar: function(e) { return this.multiplyScalar(1 / e) }, setAxisAngleFromQuaternion: function(e) { this.w = 2 * Math.acos(e.w); var t = Math.sqrt(1 - e.w * e.w); return this.z = t < 1e-4 ? (this.x = 1, this.y = 0) : (this.x = e.x / t, this.y = e.y / t, e.z / t), this }, setAxisAngleFromRotationMatrix: function(e) { var t, i, n, r, a = e.elements,
                        o = a[0],
                        s = a[4],
                        l = a[8],
                        c = a[1],
                        h = a[5],
                        u = a[9],
                        d = a[2],
                        p = a[6],
                        f = a[10]; if (Math.abs(s - c) < .01 && Math.abs(l - d) < .01 && Math.abs(u - p) < .01) { if (Math.abs(s + c) < .1 && Math.abs(l + d) < .1 && Math.abs(u + p) < .1 && Math.abs(o + h + f - 3) < .1) return this.set(1, 0, 0, 0), this;
                        t = Math.PI; var m = (o + 1) / 2,
                            g = (h + 1) / 2,
                            v = (f + 1) / 2,
                            M = (s + c) / 4,
                            y = (l + d) / 4,
                            b = (u + p) / 4; return g < m && v < m ? r = m < .01 ? (i = 0, n = .707106781) : (n = M / (i = Math.sqrt(m)), y / i) : v < g ? r = g < .01 ? (n = 0, i = .707106781) : (i = M / (n = Math.sqrt(g)), b / n) : v < .01 ? (n = i = .707106781, r = 0) : (i = y / (r = Math.sqrt(v)), n = b / r), this.set(i, n, r, t), this } var _ = Math.sqrt((p - u) * (p - u) + (l - d) * (l - d) + (c - s) * (c - s)); return Math.abs(_) < .001 && (_ = 1), this.x = (p - u) / _, this.y = (l - d) / _, this.z = (c - s) / _, this.w = Math.acos((o + h + f - 1) / 2), this }, min: function(e) { return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this }, max: function(e) { return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this }, clamp: function(e, t) { return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this }, clampScalar: function(e, t) { return void 0 === qt && (qt = new pi, Zt = new pi), qt.set(e, e, e, e), Zt.set(t, t, t, t), this.clamp(qt, Zt) }, clampLength: function(e, t) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i))) }, floor: function() { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function() { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function() { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function() { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function(e) { return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w }, lengthSq: function() { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function() { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function() { return this.divideScalar(this.length() || 1) }, setLength: function(e) { return this.normalize().multiplyScalar(e) }, lerp: function(e, t) { return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this }, lerpVectors: function(e, t, i) { return this.subVectors(t, e).multiplyScalar(i).add(e) }, equals: function(e) { return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w }, fromArray: function(e, t) { return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e }, fromBufferAttribute: function(e, t, i) { return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this } }), fi.prototype = Object.assign(Object.create(t.prototype), { constructor: fi, isWebGLRenderTarget: !0, setSize: function(e, t) { this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t) }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.depthTexture = e.depthTexture, this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }), mi.prototype = Object.assign(Object.create(fi.prototype), { constructor: mi, isWebGLMultisampleRenderTarget: !0, copy: function(e) { return fi.prototype.copy.call(this, e), this.samples = e.samples, this } }), ((gi.prototype = Object.create(fi.prototype)).constructor = gi).prototype.isWebGLRenderTargetCube = !0, ((vi.prototype = Object.create(di.prototype)).constructor = vi).prototype.isDataTexture = !0, Object.assign(Mi.prototype, { isBox3: !0, set: function(e, t) { return this.min.copy(e), this.max.copy(t), this }, setFromArray: function(e) { for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.length; s < l; s += 3) { var c = e[s],
                            h = e[s + 1],
                            u = e[s + 2];
                        c < t && (t = c), h < i && (i = h), u < n && (n = u), r < c && (r = c), a < h && (a = h), o < u && (o = u) } return this.min.set(t, i, n), this.max.set(r, a, o), this }, setFromBufferAttribute: function(e) { for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, l = e.count; s < l; s++) { var c = e.getX(s),
                            h = e.getY(s),
                            u = e.getZ(s);
                        c < t && (t = c), h < i && (i = h), u < n && (n = u), r < c && (r = c), a < h && (a = h), o < u && (o = u) } return this.min.set(t, i, n), this.max.set(r, a, o), this }, setFromPoints: function(e) { this.makeEmpty(); for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]); return this }, setFromCenterAndSize: (ei = new Xt, function(e, t) { var i = ei.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this }), setFromObject: function(e) { return this.makeEmpty(), this.expandByObject(e) }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.min.copy(e.min), this.max.copy(e.max), this }, makeEmpty: function() { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function() { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function(e) { return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"), e = new Xt), this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function(e) { return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"), e = new Xt), this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min) }, expandByPoint: function(e) { return this.min.min(e), this.max.max(e), this }, expandByVector: function(e) { return this.min.sub(e), this.max.add(e), this }, expandByScalar: function(e) { return this.min.addScalar(-e), this.max.addScalar(e), this }, expandByObject: function() { var r, a, o, s = new Xt;

                    function t(e) { var t = e.geometry; if (void 0 !== t)
                            if (t.isGeometry) { var i = t.vertices; for (a = 0, o = i.length; a < o; a++) s.copy(i[a]), s.applyMatrix4(e.matrixWorld), r.expandByPoint(s) } else if (t.isBufferGeometry) { var n = t.attributes.position; if (void 0 !== n)
                                for (a = 0, o = n.count; a < o; a++) s.fromBufferAttribute(n, a).applyMatrix4(e.matrixWorld), r.expandByPoint(s) } } return function(e) { return r = this, e.updateMatrixWorld(!0), e.traverse(t), this } }(), containsPoint: function(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z) }, containsBox: function(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z }, getParameter: function(e, t) { return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"), t = new Xt), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z) }, intersectsSphere: ($t = new Xt, function(e) { return this.clampPoint(e.center, $t), $t.distanceToSquared(e.center) <= e.radius * e.radius }), intersectsPlane: function(e) { var t, i; return i = 0 < e.normal.x ? (t = e.normal.x * this.min.x, e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, e.normal.x * this.min.x), 0 < e.normal.y ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), 0 < e.normal.z ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant }, intersectsTriangle: function() { var s = new Xt,
                        l = new Xt,
                        c = new Xt,
                        i = new Xt,
                        n = new Xt,
                        r = new Xt,
                        h = new Xt,
                        a = new Xt,
                        u = new Xt,
                        o = new Xt;

                    function d(e) { var t, i; for (t = 0, i = e.length - 3; t <= i; t += 3) { h.fromArray(e, t); var n = u.x * Math.abs(h.x) + u.y * Math.abs(h.y) + u.z * Math.abs(h.z),
                                r = s.dot(h),
                                a = l.dot(h),
                                o = c.dot(h); if (Math.max(-Math.max(r, a, o), Math.min(r, a, o)) > n) return !1 } return !0 } return function(e) { if (this.isEmpty()) return !1;
                        this.getCenter(a), u.subVectors(this.max, a), s.subVectors(e.a, a), l.subVectors(e.b, a), c.subVectors(e.c, a), i.subVectors(l, s), n.subVectors(c, l), r.subVectors(s, c); var t = [0, -i.z, i.y, 0, -n.z, n.y, 0, -r.z, r.y, i.z, 0, -i.x, n.z, 0, -n.x, r.z, 0, -r.x, -i.y, i.x, 0, -n.y, n.x, 0, -r.y, r.x, 0]; return !!d(t) && (!!d(t = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (o.crossVectors(i, n), d(t = [o.x, o.y, o.z]))) } }(), clampPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"), t = new Xt), t.copy(e).clamp(this.min, this.max) }, distanceToPoint: (Qt = new Xt, function(e) { return Qt.copy(e).clamp(this.min, this.max).sub(e).length() }), getBoundingSphere: (Kt = new Xt, function(e) { return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new yi), this.getCenter(e.center), e.radius = .5 * this.getSize(Kt).length(), e }), intersect: function(e) { return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this }, union: function(e) { return this.min.min(e.min), this.max.max(e.max), this }, applyMatrix4: (Jt = [new Xt, new Xt, new Xt, new Xt, new Xt, new Xt, new Xt, new Xt], function(e) { return this.isEmpty() || (Jt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Jt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Jt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Jt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Jt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Jt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Jt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Jt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Jt)), this }), translate: function(e) { return this.min.add(e), this.max.add(e), this }, equals: function(e) { return e.min.equals(this.min) && e.max.equals(this.max) } }), Object.assign(yi.prototype, { set: function(e, t) { return this.center.copy(e), this.radius = t, this }, setFromPoints: (ti = new Mi, function(e, t) { var i = this.center;
                    void 0 !== t ? i.copy(t) : ti.setFromPoints(e).getCenter(i); for (var n = 0, r = 0, a = e.length; r < a; r++) n = Math.max(n, i.distanceToSquared(e[r])); return this.radius = Math.sqrt(n), this }), clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.center.copy(e.center), this.radius = e.radius, this }, empty: function() { return this.radius <= 0 }, containsPoint: function(e) { return e.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function(e) { return e.distanceTo(this.center) - this.radius }, intersectsSphere: function(e) { var t = this.radius + e.radius; return e.center.distanceToSquared(this.center) <= t * t }, intersectsBox: function(e) { return e.intersectsSphere(this) }, intersectsPlane: function(e) { return Math.abs(e.distanceToPoint(this.center)) <= this.radius }, clampPoint: function(e, t) { var i = this.center.distanceToSquared(e); return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"), t = new Xt), t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t }, getBoundingBox: function(e) { return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), e = new Mi), e.set(this.center, this.center), e.expandByScalar(this.radius), e }, applyMatrix4: function(e) { return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this }, translate: function(e) { return this.center.add(e), this }, equals: function(e) { return e.center.equals(this.center) && e.radius === this.radius } }), Object.assign(bi.prototype, { set: function(e, t) { return this.normal.copy(e), this.constant = t, this }, setComponents: function(e, t, i, n) { return this.normal.set(e, t, i), this.constant = n, this }, setFromNormalAndCoplanarPoint: function(e, t) { return this.normal.copy(e), this.constant = -t.dot(this.normal), this }, setFromCoplanarPoints: (ai = new Xt, oi = new Xt, function(e, t, i) { var n = ai.subVectors(i, t).cross(oi.subVectors(e, t)).normalize(); return this.setFromNormalAndCoplanarPoint(n, e), this }), clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.normal.copy(e.normal), this.constant = e.constant, this }, normalize: function() { var e = 1 / this.normal.length(); return this.normal.multiplyScalar(e), this.constant *= e, this }, negate: function() { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function(e) { return this.normal.dot(e) + this.constant }, distanceToSphere: function(e) { return this.distanceToPoint(e.center) - e.radius }, projectPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"), t = new Xt), t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e) }, intersectLine: (ri = new Xt, function(e, t) { void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"), t = new Xt); var i = e.delta(ri),
                        n = this.normal.dot(i); if (0 === n) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : void 0; var r = -(e.start.dot(this.normal) + this.constant) / n; return r < 0 || 1 < r ? void 0 : t.copy(i).multiplyScalar(r).add(e.start) }), intersectsLine: function(e) { var t = this.distanceToPoint(e.start),
                        i = this.distanceToPoint(e.end); return t < 0 && 0 < i || i < 0 && 0 < t }, intersectsBox: function(e) { return e.intersectsPlane(this) }, intersectsSphere: function(e) { return e.intersectsPlane(this) }, coplanarPoint: function(e) { return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), e = new Xt), e.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: (ii = new Xt, ni = new Yt, function(e, t) { var i = t || ni.getNormalMatrix(e),
                        n = this.coplanarPoint(ii).applyMatrix4(e),
                        r = this.normal.applyMatrix3(i).normalize(); return this.constant = -n.dot(r), this }), translate: function(e) { return this.constant -= e.dot(this.normal), this }, equals: function(e) { return e.normal.equals(this.normal) && e.constant === this.constant } }), Object.assign(_i.prototype, { set: function(e, t, i, n, r, a) { var o = this.planes; return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5].copy(a), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { for (var t = this.planes, i = 0; i < 6; i++) t[i].copy(e.planes[i]); return this }, setFromMatrix: function(e) { var t = this.planes,
                        i = e.elements,
                        n = i[0],
                        r = i[1],
                        a = i[2],
                        o = i[3],
                        s = i[4],
                        l = i[5],
                        c = i[6],
                        h = i[7],
                        u = i[8],
                        d = i[9],
                        p = i[10],
                        f = i[11],
                        m = i[12],
                        g = i[13],
                        v = i[14],
                        M = i[15]; return t[0].setComponents(o - n, h - s, f - u, M - m).normalize(), t[1].setComponents(o + n, h + s, f + u, M + m).normalize(), t[2].setComponents(o + r, h + l, f + d, M + g).normalize(), t[3].setComponents(o - r, h - l, f - d, M - g).normalize(), t[4].setComponents(o - a, h - c, f - p, M - v).normalize(), t[5].setComponents(o + a, h + c, f + p, M + v).normalize(), this }, intersectsObject: (ci = new yi, function(e) { var t = e.geometry; return null === t.boundingSphere && t.computeBoundingSphere(), ci.copy(t.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(ci) }), intersectsSprite: (li = new yi, function(e) { return li.center.set(0, 0, 0), li.radius = .7071067811865476, li.applyMatrix4(e.matrixWorld), this.intersectsSphere(li) }), intersectsSphere: function(e) { for (var t = this.planes, i = e.center, n = -e.radius, r = 0; r < 6; r++) { if (t[r].distanceToPoint(i) < n) return !1 } return !0 }, intersectsBox: (si = new Xt, function(e) { for (var t = this.planes, i = 0; i < 6; i++) { var n = t[i]; if (si.x = 0 < n.normal.x ? e.max.x : e.min.x, si.y = 0 < n.normal.y ? e.max.y : e.min.y, si.z = 0 < n.normal.z ? e.max.z : e.min.z, n.distanceToPoint(si) < 0) return !1 } return !0 }), containsPoint: function(e) { for (var t = this.planes, i = 0; i < 6; i++)
                        if (t[i].distanceToPoint(e) < 0) return !1;
                    return !0 } }); var xi = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif", lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif", normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}", uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" };

            function Ti(e) { var t = {}; for (var i in e)
                    for (var n in t[i] = {}, e[i]) { var r = e[i][n];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? t[i][n] = r.clone() : Array.isArray(r) ? t[i][n] = r.slice() : t[i][n] = r }
                return t }

            function wi(e) { for (var t = {}, i = 0; i < e.length; i++) { var n = Ti(e[i]); for (var r in n) t[r] = n[r] } return t } var Si, Ei, Pi, Ai = { clone: Ti, merge: wi },
                Ci = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };

            function Li(e, t, i) { return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i) }
            Object.assign(Li.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function(e) { return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this }, setScalar: function(e) { return this.r = e, this.g = e, this.b = e, this }, setHex: function(e) { return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this }, setRGB: function(e, t, i) { return this.r = e, this.g = t, this.b = i, this }, setHSL: function() {
                    function a(e, t, i) { return i < 0 && (i += 1), 1 < i && (i -= 1), i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e } return function(e, t, i) { if (e = Ut.euclideanModulo(e, 1), t = Ut.clamp(t, 0, 1), i = Ut.clamp(i, 0, 1), 0 === t) this.r = this.g = this.b = i;
                        else { var n = i <= .5 ? i * (1 + t) : i + t - i * t,
                                r = 2 * i - n;
                            this.r = a(r, n, e + 1 / 3), this.g = a(r, n, e), this.b = a(r, n, e - 1 / 3) } return this } }(), setStyle: function(t) {
                    function e(e) { void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } var i; if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) { var n, r = i[1],
                            a = i[2]; switch (r) {
                            case "rgb":
                            case "rgba":
                                if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, e(n[5]), this; if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, e(n[5]), this; break;
                            case "hsl":
                            case "hsla":
                                if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) { var o = parseFloat(n[1]) / 360,
                                        s = parseInt(n[2], 10) / 100,
                                        l = parseInt(n[3], 10) / 100; return e(n[5]), this.setHSL(o, s, l) } } } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(t)) { var c, h = (c = i[1]).length; if (3 === h) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this; if (6 === h) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this }
                    t && 0 < t.length && (void 0 !== (c = Ci[t]) ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + t)); return this }, clone: function() { return new this.constructor(this.r, this.g, this.b) }, copy: function(e) { return this.r = e.r, this.g = e.g, this.b = e.b, this }, copyGammaToLinear: function(e, t) { return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this }, copyLinearToGamma: function(e, t) { void 0 === t && (t = 2); var i = 0 < t ? 1 / t : 1; return this.r = Math.pow(e.r, i), this.g = Math.pow(e.g, i), this.b = Math.pow(e.b, i), this }, convertGammaToLinear: function(e) { return this.copyGammaToLinear(this, e), this }, convertLinearToGamma: function(e) { return this.copyLinearToGamma(this, e), this }, copySRGBToLinear: function() {
                    function t(e) { return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4) } return function(e) { return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this } }(), copyLinearToSRGB: function() {
                    function t(e) { return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055 } return function(e) { return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this } }(), convertSRGBToLinear: function() { return this.copySRGBToLinear(this), this }, convertLinearToSRGB: function() { return this.copyLinearToSRGB(this), this }, getHex: function() { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function() { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function(e) { void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"), e = { h: 0, s: 0, l: 0 }); var t, i, n = this.r,
                        r = this.g,
                        a = this.b,
                        o = Math.max(n, r, a),
                        s = Math.min(n, r, a),
                        l = (s + o) / 2; if (s === o) i = t = 0;
                    else { var c = o - s; switch (i = l <= .5 ? c / (o + s) : c / (2 - o - s), o) {
                            case n:
                                t = (r - a) / c + (r < a ? 6 : 0); break;
                            case r:
                                t = (a - n) / c + 2; break;
                            case a:
                                t = (n - r) / c + 4 }
                        t /= 6 } return e.h = t, e.s = i, e.l = l, e }, getStyle: function() { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: (Pi = {}, function(e, t, i) { return this.getHSL(Pi), Pi.h += e, Pi.s += t, Pi.l += i, this.setHSL(Pi.h, Pi.s, Pi.l), this }), add: function(e) { return this.r += e.r, this.g += e.g, this.b += e.b, this }, addColors: function(e, t) { return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this }, addScalar: function(e) { return this.r += e, this.g += e, this.b += e, this }, sub: function(e) { return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this }, multiply: function(e) { return this.r *= e.r, this.g *= e.g, this.b *= e.b, this }, multiplyScalar: function(e) { return this.r *= e, this.g *= e, this.b *= e, this }, lerp: function(e, t) { return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this }, lerpHSL: (Si = { h: 0, s: 0, l: 0 }, Ei = { h: 0, s: 0, l: 0 }, function(e, t) { this.getHSL(Si), e.getHSL(Ei); var i = Ut.lerp(Si.h, Ei.h, t),
                        n = Ut.lerp(Si.s, Ei.s, t),
                        r = Ut.lerp(Si.l, Ei.l, t); return this.setHSL(i, n, r), this }), equals: function(e) { return e.r === this.r && e.g === this.g && e.b === this.b }, fromArray: function(e, t) { return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e }, toJSON: function() { return this.getHex() } }); var Ri, Hi, Oi = { common: { diffuse: { value: new Li(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Yt }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Vt(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Li(16777215) } }, lights: { ambientLightColor: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new Li(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new Yt } }, sprite: { diffuse: { value: new Li(15658734) }, opacity: { value: 1 }, center: { value: new Vt(.5, .5) }, rotation: { value: 0 }, map: { value: null }, uvTransform: { value: new Yt } } },
                Gi = { basic: { uniforms: wi([Oi.common, Oi.specularmap, Oi.envmap, Oi.aomap, Oi.lightmap, Oi.fog]), vertexShader: xi.meshbasic_vert, fragmentShader: xi.meshbasic_frag }, lambert: { uniforms: wi([Oi.common, Oi.specularmap, Oi.envmap, Oi.aomap, Oi.lightmap, Oi.emissivemap, Oi.fog, Oi.lights, { emissive: { value: new Li(0) } }]), vertexShader: xi.meshlambert_vert, fragmentShader: xi.meshlambert_frag }, phong: { uniforms: wi([Oi.common, Oi.specularmap, Oi.envmap, Oi.aomap, Oi.lightmap, Oi.emissivemap, Oi.bumpmap, Oi.normalmap, Oi.displacementmap, Oi.gradientmap, Oi.fog, Oi.lights, { emissive: { value: new Li(0) }, specular: { value: new Li(1118481) }, shininess: { value: 30 } }]), vertexShader: xi.meshphong_vert, fragmentShader: xi.meshphong_frag }, standard: { uniforms: wi([Oi.common, Oi.envmap, Oi.aomap, Oi.lightmap, Oi.emissivemap, Oi.bumpmap, Oi.normalmap, Oi.displacementmap, Oi.roughnessmap, Oi.metalnessmap, Oi.fog, Oi.lights, { emissive: { value: new Li(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]), vertexShader: xi.meshphysical_vert, fragmentShader: xi.meshphysical_frag }, matcap: { uniforms: wi([Oi.common, Oi.bumpmap, Oi.normalmap, Oi.displacementmap, Oi.fog, { matcap: { value: null } }]), vertexShader: xi.meshmatcap_vert, fragmentShader: xi.meshmatcap_frag }, points: { uniforms: wi([Oi.points, Oi.fog]), vertexShader: xi.points_vert, fragmentShader: xi.points_frag }, dashed: { uniforms: wi([Oi.common, Oi.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: xi.linedashed_vert, fragmentShader: xi.linedashed_frag }, depth: { uniforms: wi([Oi.common, Oi.displacementmap]), vertexShader: xi.depth_vert, fragmentShader: xi.depth_frag }, normal: { uniforms: wi([Oi.common, Oi.bumpmap, Oi.normalmap, Oi.displacementmap, { opacity: { value: 1 } }]), vertexShader: xi.normal_vert, fragmentShader: xi.normal_frag }, sprite: { uniforms: wi([Oi.sprite, Oi.fog]), vertexShader: xi.sprite_vert, fragmentShader: xi.sprite_frag }, background: { uniforms: { uvTransform: { value: new Yt }, t2D: { value: null } }, vertexShader: xi.background_vert, fragmentShader: xi.background_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: xi.cube_vert, fragmentShader: xi.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: xi.equirect_vert, fragmentShader: xi.equirect_frag }, distanceRGBA: { uniforms: wi([Oi.common, Oi.displacementmap, { referencePosition: { value: new Xt }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: xi.distanceRGBA_vert, fragmentShader: xi.distanceRGBA_frag }, shadow: { uniforms: wi([Oi.lights, Oi.fog, { color: { value: new Li(0) }, opacity: { value: 1 } }]), vertexShader: xi.shadow_vert, fragmentShader: xi.shadow_frag } };

            function Di() { var i = null,
                    n = !1,
                    r = null;

                function a(e, t) {!1 !== n && (r(e, t), i.requestAnimationFrame(a)) } return { start: function() {!0 !== n && null !== r && (i.requestAnimationFrame(a), n = !0) }, stop: function() { n = !1 }, setAnimationLoop: function(e) { r = e }, setContext: function(e) { i = e } } }

            function Ii(l) { var c = new WeakMap; return { get: function(e) { return e.isInterleavedBufferAttribute && (e = e.data), c.get(e) }, remove: function(e) { e.isInterleavedBufferAttribute && (e = e.data); var t = c.get(e);
                        t && (l.deleteBuffer(t.buffer), c.delete(e)) }, update: function(e, t) { e.isInterleavedBufferAttribute && (e = e.data); var i, n, r, a, o, s = c.get(e);
                        void 0 === s ? c.set(e, function(e, t) { var i = e.array,
                                n = e.dynamic ? 35048 : 35044,
                                r = l.createBuffer();
                            l.bindBuffer(t, r), l.bufferData(t, i, n), e.onUploadCallback(); var a = 5126; return i instanceof Float32Array ? a = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? a = 5123 : i instanceof Int16Array ? a = 5122 : i instanceof Uint32Array ? a = 5125 : i instanceof Int32Array ? a = 5124 : i instanceof Int8Array ? a = 5120 : i instanceof Uint8Array && (a = 5121), { buffer: r, type: a, bytesPerElement: i.BYTES_PER_ELEMENT, version: e.version } }(e, t)) : s.version < e.version && (i = s.buffer, r = t, a = (n = e).array, o = n.updateRange, l.bindBuffer(r, i), !1 === n.dynamic ? l.bufferData(r, a, 35044) : -1 === o.count ? l.bufferSubData(r, 0, a) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (l.bufferSubData(r, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1), s.version = e.version) } } }

            function Bi(e, t, i, n, r, a) { this.a = e, this.b = t, this.c = i, this.normal = n && n.isVector3 ? n : new Xt, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new Li, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== a ? a : 0 }

            function Ni(e, t, i, n) { this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || Ni.DefaultOrder }

            function Fi() { this.mask = 1 }
            Gi.physical = { uniforms: wi([Gi.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: xi.meshphysical_vert, fragmentShader: xi.meshphysical_frag }, Object.assign(Bi.prototype, { clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex; for (var t = 0, i = e.vertexNormals.length; t < i; t++) this.vertexNormals[t] = e.vertexNormals[t].clone(); for (t = 0, i = e.vertexColors.length; t < i; t++) this.vertexColors[t] = e.vertexColors[t].clone(); return this } }), Ni.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Ni.DefaultOrder = "XYZ", Object.defineProperties(Ni.prototype, { x: { get: function() { return this._x }, set: function(e) { this._x = e, this.onChangeCallback() } }, y: { get: function() { return this._y }, set: function(e) { this._y = e, this.onChangeCallback() } }, z: { get: function() { return this._z }, set: function(e) { this._z = e, this.onChangeCallback() } }, order: { get: function() { return this._order }, set: function(e) { this._order = e, this.onChangeCallback() } } }), Object.assign(Ni.prototype, { isEuler: !0, set: function(e, t, i, n) { return this._x = e, this._y = t, this._z = i, this._order = n || this._order, this.onChangeCallback(), this }, clone: function() { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function(e) { return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this }, setFromRotationMatrix: function(e, t, i) { var n = Ut.clamp,
                        r = e.elements,
                        a = r[0],
                        o = r[4],
                        s = r[8],
                        l = r[1],
                        c = r[5],
                        h = r[9],
                        u = r[2],
                        d = r[6],
                        p = r[10]; return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-h, p), this._z = Math.atan2(-o, a)) : (this._x = Math.atan2(d, c), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(h, -1, 1)), Math.abs(h) < .99999 ? (this._y = Math.atan2(s, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, a), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(d, -1, 1)), Math.abs(d) < .99999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, a))) : "ZYX" === t ? (this._y = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-o, c))) : "YZX" === t ? (this._z = Math.asin(n(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-u, a)) : (this._x = 0, this._y = Math.atan2(s, p))) : "XZY" === t ? (this._z = Math.asin(-n(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(s, a)) : (this._x = Math.atan2(-h, p), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, !1 !== i && this.onChangeCallback(), this }, setFromQuaternion: (Hi = new jt, function(e, t, i) { return Hi.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Hi, t, i) }), setFromVector3: function(e, t) { return this.set(e.x, e.y, e.z, t || this._order) }, reorder: (Ri = new Wt, function(e) { return Ri.setFromEuler(this), this.setFromQuaternion(Ri, e) }), equals: function(e) { return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order }, fromArray: function(e) { return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this }, toArray: function(e, t) { return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e }, toVector3: function(e) { return e ? e.set(this._x, this._y, this._z) : new Xt(this._x, this._y, this._z) }, onChange: function(e) { return this.onChangeCallback = e, this }, onChangeCallback: function() {} }), Object.assign(Fi.prototype, { set: function(e) { this.mask = 1 << e | 0 }, enable: function(e) { this.mask |= 1 << e | 0 }, toggle: function(e) { this.mask ^= 1 << e | 0 }, disable: function(e) { this.mask &= ~(1 << e | 0) }, test: function(e) { return 0 != (this.mask & e.mask) } }); var zi, ki, Ui, Vi, ji, Wi, Xi, Yi, qi, Zi, Ji, Ki, Qi, $i, en, tn, nn, rn, an = 0;

            function on() { Object.defineProperty(this, "id", { value: an++ }), this.uuid = Ut.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = on.DefaultUp.clone(); var e = new Xt,
                    t = new Ni,
                    i = new Wt,
                    n = new Xt(1, 1, 1);
                t.onChange(function() { i.setFromEuler(t, !1) }), i.onChange(function() { t.setFromQuaternion(i, void 0, !1) }), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: e }, rotation: { configurable: !0, enumerable: !0, value: t }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: n }, modelViewMatrix: { value: new jt }, normalMatrix: { value: new Yt } }), this.matrix = new jt, this.matrixWorld = new jt, this.matrixAutoUpdate = on.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Fi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} }
            on.DefaultUp = new Xt(0, 1, 0), on.DefaultMatrixAutoUpdate = !0, on.prototype = Object.assign(Object.create(t.prototype), { constructor: on, isObject3D: !0, onBeforeRender: function() {}, onAfterRender: function() {}, applyMatrix: function(e) { this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function(e) { return this.quaternion.premultiply(e), this }, setRotationFromAxisAngle: function(e, t) { this.quaternion.setFromAxisAngle(e, t) }, setRotationFromEuler: function(e) { this.quaternion.setFromEuler(e, !0) }, setRotationFromMatrix: function(e) { this.quaternion.setFromRotationMatrix(e) }, setRotationFromQuaternion: function(e) { this.quaternion.copy(e) }, rotateOnAxis: (rn = new Wt, function(e, t) { return rn.setFromAxisAngle(e, t), this.quaternion.multiply(rn), this }), rotateOnWorldAxis: (nn = new Wt, function(e, t) { return nn.setFromAxisAngle(e, t), this.quaternion.premultiply(nn), this }), rotateX: (tn = new Xt(1, 0, 0), function(e) { return this.rotateOnAxis(tn, e) }), rotateY: (en = new Xt(0, 1, 0), function(e) { return this.rotateOnAxis(en, e) }), rotateZ: ($i = new Xt(0, 0, 1), function(e) { return this.rotateOnAxis($i, e) }), translateOnAxis: (Qi = new Xt, function(e, t) { return Qi.copy(e).applyQuaternion(this.quaternion), this.position.add(Qi.multiplyScalar(t)), this }), translateX: (Ki = new Xt(1, 0, 0), function(e) { return this.translateOnAxis(Ki, e) }), translateY: (Ji = new Xt(0, 1, 0), function(e) { return this.translateOnAxis(Ji, e) }), translateZ: (Zi = new Xt(0, 0, 1), function(e) { return this.translateOnAxis(Zi, e) }), localToWorld: function(e) { return e.applyMatrix4(this.matrixWorld) }, worldToLocal: (qi = new jt, function(e) { return e.applyMatrix4(qi.getInverse(this.matrixWorld)) }), lookAt: (ji = new Wt, Wi = new jt, Xi = new Xt, Yi = new Xt, function(e, t, i) { e.isVector3 ? Xi.copy(e) : Xi.set(e, t, i); var n = this.parent;
                    this.updateWorldMatrix(!0, !1), Yi.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Wi.lookAt(Yi, Xi, this.up) : Wi.lookAt(Xi, Yi, this.up), this.quaternion.setFromRotationMatrix(Wi), n && (Wi.extractRotation(n.matrixWorld), ji.setFromRotationMatrix(Wi), this.quaternion.premultiply(ji.inverse())) }), add: function(e) { if (1 < arguments.length) { for (var t = 0; t < arguments.length; t++) this.add(arguments[t]); return this } return e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({ type: "added" }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this }, remove: function(e) { if (1 < arguments.length) { for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]); return this } var i = this.children.indexOf(e); return -1 !== i && (e.parent = null, e.dispatchEvent({ type: "removed" }), this.children.splice(i, 1)), this }, getObjectById: function(e) { return this.getObjectByProperty("id", e) }, getObjectByName: function(e) { return this.getObjectByProperty("name", e) }, getObjectByProperty: function(e, t) { if (this[e] === t) return this; for (var i = 0, n = this.children.length; i < n; i++) { var r = this.children[i].getObjectByProperty(e, t); if (void 0 !== r) return r } }, getWorldPosition: function(e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), e = new Xt), this.updateMatrixWorld(!0), e.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: (Ui = new Xt, Vi = new Xt, function(e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), e = new Wt), this.updateMatrixWorld(!0), this.matrixWorld.decompose(Ui, e, Vi), e }), getWorldScale: (zi = new Xt, ki = new Wt, function(e) { return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), e = new Xt), this.updateMatrixWorld(!0), this.matrixWorld.decompose(zi, ki, e), e }), getWorldDirection: function(e) { void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), e = new Xt), this.updateMatrixWorld(!0); var t = this.matrixWorld.elements; return e.set(t[8], t[9], t[10]).normalize() }, raycast: function() {}, traverse: function(e) { e(this); for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverse(e) }, traverseVisible: function(e) { if (!1 !== this.visible) { e(this); for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e) } }, traverseAncestors: function(e) { var t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e)) }, updateMatrix: function() { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function(e) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e = !(this.matrixWorldNeedsUpdate = !1)); for (var t = this.children, i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e) }, updateWorldMatrix: function(e, t) { var i = this.parent; if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                        for (var n = this.children, r = 0, a = n.length; r < a; r++) n[r].updateWorldMatrix(!1, !0) }, toJSON: function(i) { var e = void 0 === i || "string" == typeof i,
                        t = {};
                    e && (i = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, t.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var n = {};

                    function r(e, t) { return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(i)), t.uuid } if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), !0 === this.castShadow && (n.castShadow = !0), !0 === this.receiveShadow && (n.receiveShadow = !0), !1 === this.visible && (n.visible = !1), !1 === this.frustumCulled && (n.frustumCulled = !1), 0 !== this.renderOrder && (n.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1), this.isMesh && this.drawMode !== Lt && (n.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) { n.geometry = r(i.geometries, this.geometry); var a = this.geometry.parameters; if (void 0 !== a && void 0 !== a.shapes) { var o = a.shapes; if (Array.isArray(o))
                                for (var s = 0, l = o.length; s < l; s++) { var c = o[s];
                                    r(i.shapes, c) } else r(i.shapes, o) } } if (void 0 !== this.material)
                        if (Array.isArray(this.material)) { var h = []; for (s = 0, l = this.material.length; s < l; s++) h.push(r(i.materials, this.material[s]));
                            n.material = h } else n.material = r(i.materials, this.material);
                    if (0 < this.children.length) { n.children = []; for (s = 0; s < this.children.length; s++) n.children.push(this.children[s].toJSON(i).object) } if (e) { var u = m(i.geometries),
                            d = m(i.materials),
                            p = m(i.textures),
                            f = m(i.images);
                        o = m(i.shapes);
                        0 < u.length && (t.geometries = u), 0 < d.length && (t.materials = d), 0 < p.length && (t.textures = p), 0 < f.length && (t.images = f), 0 < o.length && (t.shapes = o) } return t.object = n, t;

                    function m(e) { var t = []; for (var i in e) { var n = e[i];
                            delete n.metadata, t.push(n) } return t } }, clone: function(e) { return (new this.constructor).copy(this, e) }, copy: function(e, t) { if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                        for (var i = 0; i < e.children.length; i++) { var n = e.children[i];
                            this.add(n.clone()) }
                    return this } }); var sn, ln, cn, hn, un, dn, pn, fn = 0;

            function mn() { Object.defineProperty(this, "id", { value: fn += 2 }), this.uuid = Ut.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 }

            function gn(e, t, i) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 }

            function vn(e, t, i) { gn.call(this, new Int8Array(e), t, i) }

            function Mn(e, t, i) { gn.call(this, new Uint8Array(e), t, i) }

            function yn(e, t, i) { gn.call(this, new Uint8ClampedArray(e), t, i) }

            function bn(e, t, i) { gn.call(this, new Int16Array(e), t, i) }

            function _n(e, t, i) { gn.call(this, new Uint16Array(e), t, i) }

            function xn(e, t, i) { gn.call(this, new Int32Array(e), t, i) }

            function Tn(e, t, i) { gn.call(this, new Uint32Array(e), t, i) }

            function wn(e, t, i) { gn.call(this, new Float32Array(e), t, i) }

            function Sn(e, t, i) { gn.call(this, new Float64Array(e), t, i) }

            function En() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 }

            function Pn(e) { if (0 === e.length) return -1 / 0; for (var t = e[0], i = 1, n = e.length; i < n; ++i) e[i] > t && (t = e[i]); return t }
            mn.prototype = Object.assign(Object.create(t.prototype), { constructor: mn, isGeometry: !0, applyMatrix: function(e) { for (var t = (new Yt).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++) { this.vertices[i].applyMatrix4(e) } for (i = 0, n = this.faces.length; i < n; i++) { var r = this.faces[i];
                        r.normal.applyMatrix3(t).normalize(); for (var a = 0, o = r.vertexNormals.length; a < o; a++) r.vertexNormals[a].applyMatrix3(t).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this }, rotateX: (pn = new jt, function(e) { return pn.makeRotationX(e), this.applyMatrix(pn), this }), rotateY: (dn = new jt, function(e) { return dn.makeRotationY(e), this.applyMatrix(dn), this }), rotateZ: (un = new jt, function(e) { return un.makeRotationZ(e), this.applyMatrix(un), this }), translate: (hn = new jt, function(e, t, i) { return hn.makeTranslation(e, t, i), this.applyMatrix(hn), this }), scale: (cn = new jt, function(e, t, i) { return cn.makeScale(e, t, i), this.applyMatrix(cn), this }), lookAt: (ln = new on, function(e) { ln.lookAt(e), ln.updateMatrix(), this.applyMatrix(ln.matrix) }), fromBufferGeometry: function(e) { var o = this,
                        t = null !== e.index ? e.index.array : void 0,
                        i = e.attributes,
                        n = i.position.array,
                        s = void 0 !== i.normal ? i.normal.array : void 0,
                        l = void 0 !== i.color ? i.color.array : void 0,
                        c = void 0 !== i.uv ? i.uv.array : void 0,
                        h = void 0 !== i.uv2 ? i.uv2.array : void 0;
                    void 0 !== h && (this.faceVertexUvs[1] = []); for (var r = 0, a = 0; r < n.length; r += 3, a += 2) o.vertices.push((new Xt).fromArray(n, r)), void 0 !== l && o.colors.push((new Li).fromArray(l, r));

                    function u(e, t, i, n) { var r = void 0 === l ? [] : [o.colors[e].clone(), o.colors[t].clone(), o.colors[i].clone()],
                            a = new Bi(e, t, i, void 0 === s ? [] : [(new Xt).fromArray(s, 3 * e), (new Xt).fromArray(s, 3 * t), (new Xt).fromArray(s, 3 * i)], r, n);
                        o.faces.push(a), void 0 !== c && o.faceVertexUvs[0].push([(new Vt).fromArray(c, 2 * e), (new Vt).fromArray(c, 2 * t), (new Vt).fromArray(c, 2 * i)]), void 0 !== h && o.faceVertexUvs[1].push([(new Vt).fromArray(h, 2 * e), (new Vt).fromArray(h, 2 * t), (new Vt).fromArray(h, 2 * i)]) } var d = e.groups; if (0 < d.length)
                        for (r = 0; r < d.length; r++)
                            for (var p = d[r], f = p.start, m = (a = f, f + p.count); a < m; a += 3) void 0 !== t ? u(t[a], t[a + 1], t[a + 2], p.materialIndex) : u(a, a + 1, a + 2, p.materialIndex);
                    else if (void 0 !== t)
                        for (r = 0; r < t.length; r += 3) u(t[r], t[r + 1], t[r + 2]);
                    else
                        for (r = 0; r < n.length / 3; r += 3) u(r, r + 1, r + 2); return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this }, center: (sn = new Xt, function() { return this.computeBoundingBox(), this.boundingBox.getCenter(sn).negate(), this.translate(sn.x, sn.y, sn.z), this }), normalize: function() { this.computeBoundingSphere(); var e = this.boundingSphere.center,
                        t = this.boundingSphere.radius,
                        i = 0 === t ? 1 : 1 / t,
                        n = new jt; return n.set(i, 0, 0, -i * e.x, 0, i, 0, -i * e.y, 0, 0, i, -i * e.z, 0, 0, 0, 1), this.applyMatrix(n), this }, computeFaceNormals: function() { for (var e = new Xt, t = new Xt, i = 0, n = this.faces.length; i < n; i++) { var r = this.faces[i],
                            a = this.vertices[r.a],
                            o = this.vertices[r.b],
                            s = this.vertices[r.c];
                        e.subVectors(s, o), t.subVectors(a, o), e.cross(t), e.normalize(), r.normal.copy(e) } }, computeVertexNormals: function(e) { var t, i, n, r, a, o; for (void 0 === e && (e = !0), o = new Array(this.vertices.length), t = 0, i = this.vertices.length; t < i; t++) o[t] = new Xt; if (e) { var s, l, c, h = new Xt,
                            u = new Xt; for (n = 0, r = this.faces.length; n < r; n++) a = this.faces[n], s = this.vertices[a.a], l = this.vertices[a.b], c = this.vertices[a.c], h.subVectors(c, l), u.subVectors(s, l), h.cross(u), o[a.a].add(h), o[a.b].add(h), o[a.c].add(h) } else
                        for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++) o[(a = this.faces[n]).a].add(a.normal), o[a.b].add(a.normal), o[a.c].add(a.normal); for (t = 0, i = this.vertices.length; t < i; t++) o[t].normalize(); for (n = 0, r = this.faces.length; n < r; n++) { var d = (a = this.faces[n]).vertexNormals;
                        3 === d.length ? (d[0].copy(o[a.a]), d[1].copy(o[a.b]), d[2].copy(o[a.c])) : (d[0] = o[a.a].clone(), d[1] = o[a.b].clone(), d[2] = o[a.c].clone()) }
                    0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function() { var e, t, i; for (this.computeFaceNormals(), e = 0, t = this.faces.length; e < t; e++) { var n = (i = this.faces[e]).vertexNormals;
                        3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone()) }
                    0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function() { var e, t, i, n, r; for (i = 0, n = this.faces.length; i < n; i++)
                        for ((r = this.faces[i]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []), e = 0, t = r.vertexNormals.length; e < t; e++) r.__originalVertexNormals[e] ? r.__originalVertexNormals[e].copy(r.vertexNormals[e]) : r.__originalVertexNormals[e] = r.vertexNormals[e].clone(); var a = new mn; for (a.faces = this.faces, e = 0, t = this.morphTargets.length; e < t; e++) { if (!this.morphNormals[e]) { this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = []; var o = this.morphNormals[e].faceNormals,
                                s = this.morphNormals[e].vertexNormals; for (i = 0, n = this.faces.length; i < n; i++) l = new Xt, c = { a: new Xt, b: new Xt, c: new Xt }, o.push(l), s.push(c) } var l, c, h = this.morphNormals[e]; for (a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, n = this.faces.length; i < n; i++) r = this.faces[i], l = h.faceNormals[i], c = h.vertexNormals[i], l.copy(r.normal), c.a.copy(r.vertexNormals[0]), c.b.copy(r.vertexNormals[1]), c.c.copy(r.vertexNormals[2]) } for (i = 0, n = this.faces.length; i < n; i++)(r = this.faces[i]).normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals }, computeBoundingBox: function() { null === this.boundingBox && (this.boundingBox = new Mi), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function() { null === this.boundingSphere && (this.boundingSphere = new yi), this.boundingSphere.setFromPoints(this.vertices) }, merge: function(e, t, i) { if (e && e.isGeometry) { var n, r = this.vertices.length,
                            a = this.vertices,
                            o = e.vertices,
                            s = this.faces,
                            l = e.faces,
                            c = this.faceVertexUvs[0],
                            h = e.faceVertexUvs[0],
                            u = this.colors,
                            d = e.colors;
                        void 0 === i && (i = 0), void 0 !== t && (n = (new Yt).getNormalMatrix(t)); for (var p = 0, f = o.length; p < f; p++) { var m = o[p].clone();
                            void 0 !== t && m.applyMatrix4(t), a.push(m) } for (p = 0, f = d.length; p < f; p++) u.push(d[p].clone()); for (p = 0, f = l.length; p < f; p++) { var g, v, M, y = l[p],
                                b = y.vertexNormals,
                                _ = y.vertexColors;
                            (g = new Bi(y.a + r, y.b + r, y.c + r)).normal.copy(y.normal), void 0 !== n && g.normal.applyMatrix3(n).normalize(); for (var x = 0, T = b.length; x < T; x++) v = b[x].clone(), void 0 !== n && v.applyMatrix3(n).normalize(), g.vertexNormals.push(v);
                            g.color.copy(y.color); for (x = 0, T = _.length; x < T; x++) M = _[x], g.vertexColors.push(M.clone());
                            g.materialIndex = y.materialIndex + i, s.push(g) } for (p = 0, f = h.length; p < f; p++) { var w = h[p],
                                S = []; if (void 0 !== w) { for (x = 0, T = w.length; x < T; x++) S.push(w[x].clone());
                                c.push(S) } } } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e) }, mergeMesh: function(e) { e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e) }, mergeVertices: function() { var e, t, i, n, r, a, o, s, l = {},
                        c = [],
                        h = [],
                        u = Math.pow(10, 4); for (i = 0, n = this.vertices.length; i < n; i++) e = this.vertices[i], void 0 === l[t = Math.round(e.x * u) + "_" + Math.round(e.y * u) + "_" + Math.round(e.z * u)] ? (l[t] = i, c.push(this.vertices[i]), h[i] = c.length - 1) : h[i] = h[l[t]]; var d = []; for (i = 0, n = this.faces.length; i < n; i++) {
                        (r = this.faces[i]).a = h[r.a], r.b = h[r.b], r.c = h[r.c], a = [r.a, r.b, r.c]; for (var p = 0; p < 3; p++)
                            if (a[p] === a[(p + 1) % 3]) { d.push(i); break } } for (i = d.length - 1; 0 <= i; i--) { var f = d[i]; for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(f, 1) } var m = this.vertices.length - c.length; return this.vertices = c, m }, setFromPoints: function(e) { this.vertices = []; for (var t = 0, i = e.length; t < i; t++) { var n = e[t];
                        this.vertices.push(new Xt(n.x, n.y, n.z || 0)) } return this }, sortFacesByMaterialIndex: function() { for (var e = this.faces, t = e.length, i = 0; i < t; i++) e[i]._id = i;
                    e.sort(function(e, t) { return e.materialIndex - t.materialIndex }); var n, r, a = this.faceVertexUvs[0],
                        o = this.faceVertexUvs[1];
                    a && a.length === t && (n = []), o && o.length === t && (r = []); for (i = 0; i < t; i++) { var s = e[i]._id;
                        n && n.push(a[s]), r && r.push(o[s]) }
                    n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r) }, toJSON: function() { var e = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) { var t = this.parameters; for (var i in t) void 0 !== t[i] && (e[i] = t[i]); return e } for (var n = [], r = 0; r < this.vertices.length; r++) { var a = this.vertices[r];
                        n.push(a.x, a.y, a.z) } var o = [],
                        s = [],
                        l = {},
                        c = [],
                        h = {},
                        u = [],
                        d = {}; for (r = 0; r < this.faces.length; r++) { var p = this.faces[r],
                            f = void 0 !== this.faceVertexUvs[0][r],
                            m = 0 < p.normal.length(),
                            g = 0 < p.vertexNormals.length,
                            v = 1 !== p.color.r || 1 !== p.color.g || 1 !== p.color.b,
                            M = 0 < p.vertexColors.length,
                            y = 0; if (y = T(y = T(y = T(y = T(y = T(y = T(y = T(y = T(y, 0, 0), 1, !0), 2, !1), 3, f), 4, m), 5, g), 6, v), 7, M), o.push(y), o.push(p.a, p.b, p.c), o.push(p.materialIndex), f) { var b = this.faceVertexUvs[0][r];
                            o.push(E(b[0]), E(b[1]), E(b[2])) } if (m && o.push(w(p.normal)), g) { var _ = p.vertexNormals;
                            o.push(w(_[0]), w(_[1]), w(_[2])) } if (v && o.push(S(p.color)), M) { var x = p.vertexColors;
                            o.push(S(x[0]), S(x[1]), S(x[2])) } }

                    function T(e, t, i) { return i ? e | 1 << t : e & ~(1 << t) }

                    function w(e) { var t = e.x.toString() + e.y.toString() + e.z.toString(); return void 0 !== l[t] || (l[t] = s.length / 3, s.push(e.x, e.y, e.z)), l[t] }

                    function S(e) { var t = e.r.toString() + e.g.toString() + e.b.toString(); return void 0 !== h[t] || (h[t] = c.length, c.push(e.getHex())), h[t] }

                    function E(e) { var t = e.x.toString() + e.y.toString(); return void 0 !== d[t] || (d[t] = u.length / 2, u.push(e.x, e.y)), d[t] } return e.data = {}, e.data.vertices = n, e.data.normals = s, 0 < c.length && (e.data.colors = c), 0 < u.length && (e.data.uvs = [u]), e.data.faces = o, e }, clone: function() { return (new mn).copy(this) }, copy: function(e) { var t, i, n, r, a, o;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name; var s = e.vertices; for (t = 0, i = s.length; t < i; t++) this.vertices.push(s[t].clone()); var l = e.colors; for (t = 0, i = l.length; t < i; t++) this.colors.push(l[t].clone()); var c = e.faces; for (t = 0, i = c.length; t < i; t++) this.faces.push(c[t].clone()); for (t = 0, i = e.faceVertexUvs.length; t < i; t++) { var h = e.faceVertexUvs[t]; for (void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []), n = 0, r = h.length; n < r; n++) { var u = h[n],
                                d = []; for (a = 0, o = u.length; a < o; a++) { var p = u[a];
                                d.push(p.clone()) }
                            this.faceVertexUvs[t].push(d) } } var f = e.morphTargets; for (t = 0, i = f.length; t < i; t++) { var m = {}; if (m.name = f[t].name, void 0 !== f[t].vertices)
                            for (m.vertices = [], n = 0, r = f[t].vertices.length; n < r; n++) m.vertices.push(f[t].vertices[n].clone()); if (void 0 !== f[t].normals)
                            for (m.normals = [], n = 0, r = f[t].normals.length; n < r; n++) m.normals.push(f[t].normals[n].clone());
                        this.morphTargets.push(m) } var g = e.morphNormals; for (t = 0, i = g.length; t < i; t++) { var v = {}; if (void 0 !== g[t].vertexNormals)
                            for (v.vertexNormals = [], n = 0, r = g[t].vertexNormals.length; n < r; n++) { var M = g[t].vertexNormals[n],
                                    y = {};
                                y.a = M.a.clone(), y.b = M.b.clone(), y.c = M.c.clone(), v.vertexNormals.push(y) }
                        if (void 0 !== g[t].faceNormals)
                            for (v.faceNormals = [], n = 0, r = g[t].faceNormals.length; n < r; n++) v.faceNormals.push(g[t].faceNormals[n].clone());
                        this.morphNormals.push(v) } var b = e.skinWeights; for (t = 0, i = b.length; t < i; t++) this.skinWeights.push(b[t].clone()); var _ = e.skinIndices; for (t = 0, i = _.length; t < i; t++) this.skinIndices.push(_[t].clone()); var x = e.lineDistances; for (t = 0, i = x.length; t < i; t++) this.lineDistances.push(x[t]); var T = e.boundingBox;
                    null !== T && (this.boundingBox = T.clone()); var w = e.boundingSphere; return null !== w && (this.boundingSphere = w.clone()), this.elementsNeedUpdate = e.elementsNeedUpdate, this.verticesNeedUpdate = e.verticesNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(gn.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), Object.assign(gn.prototype, { isBufferAttribute: !0, onUploadCallback: function() {}, setArray: function(e) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== e ? e.length / this.itemSize : 0, this.array = e, this }, setDynamic: function(e) { return this.dynamic = e, this }, copy: function(e) { return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.dynamic = e.dynamic, this }, copyAt: function(e, t, i) { e *= this.itemSize, i *= t.itemSize; for (var n = 0, r = this.itemSize; n < r; n++) this.array[e + n] = t.array[i + n]; return this }, copyArray: function(e) { return this.array.set(e), this }, copyColorsArray: function(e) { for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) { var a = e[n];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), a = new Li), t[i++] = a.r, t[i++] = a.g, t[i++] = a.b } return this }, copyVector2sArray: function(e) { for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) { var a = e[n];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), a = new Vt), t[i++] = a.x, t[i++] = a.y } return this }, copyVector3sArray: function(e) { for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) { var a = e[n];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new Xt), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z } return this }, copyVector4sArray: function(e) { for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) { var a = e[n];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), a = new pi), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z, t[i++] = a.w } return this }, set: function(e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this }, getX: function(e) { return this.array[e * this.itemSize] }, setX: function(e, t) { return this.array[e * this.itemSize] = t, this }, getY: function(e) { return this.array[e * this.itemSize + 1] }, setY: function(e, t) { return this.array[e * this.itemSize + 1] = t, this }, getZ: function(e) { return this.array[e * this.itemSize + 2] }, setZ: function(e, t) { return this.array[e * this.itemSize + 2] = t, this }, getW: function(e) { return this.array[e * this.itemSize + 3] }, setW: function(e, t) { return this.array[e * this.itemSize + 3] = t, this }, setXY: function(e, t, i) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this }, setXYZ: function(e, t, i, n) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this }, setXYZW: function(e, t, i, n, r) { return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = r, this }, onUpload: function(e) { return this.onUploadCallback = e, this }, clone: function() { return new this.constructor(this.array, this.itemSize).copy(this) } }), (vn.prototype = Object.create(gn.prototype)).constructor = vn, (Mn.prototype = Object.create(gn.prototype)).constructor = Mn, (yn.prototype = Object.create(gn.prototype)).constructor = yn, (bn.prototype = Object.create(gn.prototype)).constructor = bn, (_n.prototype = Object.create(gn.prototype)).constructor = _n, (xn.prototype = Object.create(gn.prototype)).constructor = xn, (Tn.prototype = Object.create(gn.prototype)).constructor = Tn, (wn.prototype = Object.create(gn.prototype)).constructor = wn, (Sn.prototype = Object.create(gn.prototype)).constructor = Sn, Object.assign(En.prototype, { computeGroups: function(e) { for (var t, i = [], n = void 0, r = e.faces, a = 0; a < r.length; a++) { var o = r[a];
                        o.materialIndex !== n && (n = o.materialIndex, void 0 !== t && (t.count = 3 * a - t.start, i.push(t)), t = { start: 3 * a, materialIndex: n }) }
                    void 0 !== t && (t.count = 3 * a - t.start, i.push(t)), this.groups = i }, fromGeometry: function(e) { var t, i = e.faces,
                        n = e.vertices,
                        r = e.faceVertexUvs,
                        a = r[0] && 0 < r[0].length,
                        o = r[1] && 0 < r[1].length,
                        s = e.morphTargets,
                        l = s.length; if (0 < l) { t = []; for (var c = 0; c < l; c++) t[c] = { name: s[c].name, data: [] };
                        this.morphTargets.position = t } var h, u = e.morphNormals,
                        d = u.length; if (0 < d) { h = []; for (c = 0; c < d; c++) h[c] = { name: u[c].name, data: [] };
                        this.morphTargets.normal = h } var p = e.skinIndices,
                        f = e.skinWeights,
                        m = p.length === n.length,
                        g = f.length === n.length;
                    0 < n.length && 0 === i.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (c = 0; c < i.length; c++) { var v = i[c];
                        this.vertices.push(n[v.a], n[v.b], n[v.c]); var M = v.vertexNormals; if (3 === M.length) this.normals.push(M[0], M[1], M[2]);
                        else { var y = v.normal;
                            this.normals.push(y, y, y) } var b, _ = v.vertexColors; if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
                        else { var x = v.color;
                            this.colors.push(x, x, x) } if (!0 === a) void 0 !== (b = r[0][c]) ? this.uvs.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", c), this.uvs.push(new Vt, new Vt, new Vt)); if (!0 === o) void 0 !== (b = r[1][c]) ? this.uvs2.push(b[0], b[1], b[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", c), this.uvs2.push(new Vt, new Vt, new Vt)); for (var T = 0; T < l; T++) { var w = s[T].vertices;
                            t[T].data.push(w[v.a], w[v.b], w[v.c]) } for (T = 0; T < d; T++) { var S = u[T].vertexNormals[c];
                            h[T].data.push(S.a, S.b, S.c) }
                        m && this.skinIndices.push(p[v.a], p[v.b], p[v.c]), g && this.skinWeights.push(f[v.a], f[v.b], f[v.c]) } return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this } }); var An, Cn, Ln, Rn, Hn, On, Gn, Dn, In, Bn, Nn = 1;

            function Fn() { Object.defineProperty(this, "id", { value: Nn += 2 }), this.uuid = Ut.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} }

            function zn(e, t, i, n, r, a) { mn.call(this), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: n, heightSegments: r, depthSegments: a }, this.fromBufferGeometry(new kn(e, t, i, n, r, a)), this.mergeVertices() }

            function kn(e, t, i, n, r, a) { Fn.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: n, heightSegments: r, depthSegments: a }; var C = this;
                e = e || 1, t = t || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, a = Math.floor(a) || 1; var L = [],
                    R = [],
                    H = [],
                    O = [],
                    G = 0,
                    D = 0;

                function o(e, t, i, n, r, a, o, s, l, c, h) { var u, d, p = a / l,
                        f = o / c,
                        m = a / 2,
                        g = o / 2,
                        v = s / 2,
                        M = l + 1,
                        y = c + 1,
                        b = 0,
                        _ = 0,
                        x = new Xt; for (d = 0; d < y; d++) { var T = d * f - g; for (u = 0; u < M; u++) { var w = u * p - m;
                            x[e] = w * n, x[t] = T * r, x[i] = v, R.push(x.x, x.y, x.z), x[e] = 0, x[t] = 0, x[i] = 0 < s ? 1 : -1, H.push(x.x, x.y, x.z), O.push(u / l), O.push(1 - d / c), b += 1 } } for (d = 0; d < c; d++)
                        for (u = 0; u < l; u++) { var S = G + u + M * d,
                                E = G + u + M * (d + 1),
                                P = G + (u + 1) + M * (d + 1),
                                A = G + (u + 1) + M * d;
                            L.push(S, E, A), L.push(E, P, A), _ += 6 }
                    C.addGroup(D, _, h), D += _, G += b }
                o("z", "y", "x", -1, -1, i, t, e, a, r, 0), o("z", "y", "x", 1, -1, i, t, -e, a, r, 1), o("x", "z", "y", 1, 1, e, i, t, n, a, 2), o("x", "z", "y", 1, -1, e, i, -t, n, a, 3), o("x", "y", "z", 1, -1, e, t, i, n, r, 4), o("x", "y", "z", -1, -1, e, t, -i, n, r, 5), this.setIndex(L), this.addAttribute("position", new wn(R, 3)), this.addAttribute("normal", new wn(H, 3)), this.addAttribute("uv", new wn(O, 2)) }

            function Un(e, t, i, n) { mn.call(this), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: n }, this.fromBufferGeometry(new Vn(e, t, i, n)), this.mergeVertices() }

            function Vn(e, t, i, n) { Fn.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: n }; var r, a, o = (e = e || 1) / 2,
                    s = (t = t || 1) / 2,
                    l = Math.floor(i) || 1,
                    c = Math.floor(n) || 1,
                    h = l + 1,
                    u = c + 1,
                    d = e / l,
                    p = t / c,
                    f = [],
                    m = [],
                    g = [],
                    v = []; for (a = 0; a < u; a++) { var M = a * p - s; for (r = 0; r < h; r++) { var y = r * d - o;
                        m.push(y, -M, 0), g.push(0, 0, 1), v.push(r / l), v.push(1 - a / c) } } for (a = 0; a < c; a++)
                    for (r = 0; r < l; r++) { var b = r + h * a,
                            _ = r + h * (a + 1),
                            x = r + 1 + h * (a + 1),
                            T = r + 1 + h * a;
                        f.push(b, _, T), f.push(_, x, T) }
                this.setIndex(f), this.addAttribute("position", new wn(m, 3)), this.addAttribute("normal", new wn(g, 3)), this.addAttribute("uv", new wn(v, 2)) }
            Fn.prototype = Object.assign(Object.create(t.prototype), { constructor: Fn, isBufferGeometry: !0, getIndex: function() { return this.index }, setIndex: function(e) { Array.isArray(e) ? this.index = new(65535 < Pn(e) ? Tn : _n)(e, 1) : this.index = e }, addAttribute: function(e, t) { return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? ("index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t)) : this.attributes[e] = t, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(e, new gn(t, arguments[2]))) }, getAttribute: function(e) { return this.attributes[e] }, removeAttribute: function(e) { return delete this.attributes[e], this }, addGroup: function(e, t, i) { this.groups.push({ start: e, count: t, materialIndex: void 0 !== i ? i : 0 }) }, clearGroups: function() { this.groups = [] }, setDrawRange: function(e, t) { this.drawRange.start = e, this.drawRange.count = t }, applyMatrix: function(e) { var t = this.attributes.position;
                    void 0 !== t && (e.applyToBufferAttribute(t), t.needsUpdate = !0); var i = this.attributes.normal;
                    void 0 !== i && ((new Yt).getNormalMatrix(e).applyToBufferAttribute(i), i.needsUpdate = !0); var n = this.attributes.tangent;
                    void 0 !== n && ((new Yt).getNormalMatrix(e).applyToBufferAttribute(n), n.needsUpdate = !0); return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: (Bn = new jt, function(e) { return Bn.makeRotationX(e), this.applyMatrix(Bn), this }), rotateY: (In = new jt, function(e) { return In.makeRotationY(e), this.applyMatrix(In), this }), rotateZ: (Dn = new jt, function(e) { return Dn.makeRotationZ(e), this.applyMatrix(Dn), this }), translate: (Gn = new jt, function(e, t, i) { return Gn.makeTranslation(e, t, i), this.applyMatrix(Gn), this }), scale: (On = new jt, function(e, t, i) { return On.makeScale(e, t, i), this.applyMatrix(On), this }), lookAt: (Hn = new on, function(e) { Hn.lookAt(e), Hn.updateMatrix(), this.applyMatrix(Hn.matrix) }), center: (Rn = new Xt, function() { return this.computeBoundingBox(), this.boundingBox.getCenter(Rn).negate(), this.translate(Rn.x, Rn.y, Rn.z), this }), setFromObject: function(e) { var t = e.geometry; if (e.isPoints || e.isLine) { var i = new wn(3 * t.vertices.length, 3),
                            n = new wn(3 * t.colors.length, 3); if (this.addAttribute("position", i.copyVector3sArray(t.vertices)), this.addAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) { var r = new wn(t.lineDistances.length, 1);
                            this.addAttribute("lineDistance", r.copyArray(t.lineDistances)) }
                        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()) } else e.isMesh && t && t.isGeometry && this.fromGeometry(t); return this }, setFromPoints: function(e) { for (var t = [], i = 0, n = e.length; i < n; i++) { var r = e[i];
                        t.push(r.x, r.y, r.z || 0) } return this.addAttribute("position", new wn(t, 3)), this }, updateFromObject: function(e) { var t, i = e.geometry; if (e.isMesh) { var n = i.__directGeometry; if (!0 === i.elementsNeedUpdate && (n = void 0, i.elementsNeedUpdate = !1), void 0 === n) return this.fromGeometry(i);
                        n.verticesNeedUpdate = i.verticesNeedUpdate, n.normalsNeedUpdate = i.normalsNeedUpdate, n.colorsNeedUpdate = i.colorsNeedUpdate, n.uvsNeedUpdate = i.uvsNeedUpdate, n.groupsNeedUpdate = i.groupsNeedUpdate, i.verticesNeedUpdate = !1, i.normalsNeedUpdate = !1, i.colorsNeedUpdate = !1, i.uvsNeedUpdate = !1, i.groupsNeedUpdate = !1, i = n } return !0 === i.verticesNeedUpdate && (void 0 !== (t = this.attributes.position) && (t.copyVector3sArray(i.vertices), t.needsUpdate = !0), i.verticesNeedUpdate = !1), !0 === i.normalsNeedUpdate && (void 0 !== (t = this.attributes.normal) && (t.copyVector3sArray(i.normals), t.needsUpdate = !0), i.normalsNeedUpdate = !1), !0 === i.colorsNeedUpdate && (void 0 !== (t = this.attributes.color) && (t.copyColorsArray(i.colors), t.needsUpdate = !0), i.colorsNeedUpdate = !1), i.uvsNeedUpdate && (void 0 !== (t = this.attributes.uv) && (t.copyVector2sArray(i.uvs), t.needsUpdate = !0), i.uvsNeedUpdate = !1), i.lineDistancesNeedUpdate && (void 0 !== (t = this.attributes.lineDistance) && (t.copyArray(i.lineDistances), t.needsUpdate = !0), i.lineDistancesNeedUpdate = !1), i.groupsNeedUpdate && (i.computeGroups(e.geometry), this.groups = i.groups, i.groupsNeedUpdate = !1), this }, fromGeometry: function(e) { return e.__directGeometry = (new En).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry) }, fromDirectGeometry: function(e) { var t = new Float32Array(3 * e.vertices.length); if (this.addAttribute("position", new gn(t, 3).copyVector3sArray(e.vertices)), 0 < e.normals.length) { var i = new Float32Array(3 * e.normals.length);
                        this.addAttribute("normal", new gn(i, 3).copyVector3sArray(e.normals)) } if (0 < e.colors.length) { var n = new Float32Array(3 * e.colors.length);
                        this.addAttribute("color", new gn(n, 3).copyColorsArray(e.colors)) } if (0 < e.uvs.length) { var r = new Float32Array(2 * e.uvs.length);
                        this.addAttribute("uv", new gn(r, 2).copyVector2sArray(e.uvs)) } if (0 < e.uvs2.length) { var a = new Float32Array(2 * e.uvs2.length);
                        this.addAttribute("uv2", new gn(a, 2).copyVector2sArray(e.uvs2)) } for (var o in this.groups = e.groups, e.morphTargets) { for (var s = [], l = e.morphTargets[o], c = 0, h = l.length; c < h; c++) { var u = l[c],
                                d = new wn(3 * u.data.length, 3);
                            d.name = u.name, s.push(d.copyVector3sArray(u.data)) }
                        this.morphAttributes[o] = s } if (0 < e.skinIndices.length) { var p = new wn(4 * e.skinIndices.length, 4);
                        this.addAttribute("skinIndex", p.copyVector4sArray(e.skinIndices)) } if (0 < e.skinWeights.length) { var f = new wn(4 * e.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(e.skinWeights)) } return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this }, computeBoundingBox: function() { null === this.boundingBox && (this.boundingBox = new Mi); var e = this.attributes.position;
                    void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) }, computeBoundingSphere: (Cn = new Mi, Ln = new Xt, function() { null === this.boundingSphere && (this.boundingSphere = new yi); var e = this.attributes.position; if (e) { var t = this.boundingSphere.center;
                        Cn.setFromBufferAttribute(e), Cn.getCenter(t); for (var i = 0, n = 0, r = e.count; n < r; n++) Ln.x = e.getX(n), Ln.y = e.getY(n), Ln.z = e.getZ(n), i = Math.max(i, t.distanceToSquared(Ln));
                        this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } }), computeFaceNormals: function() {}, computeVertexNormals: function() { var e = this.index,
                        t = this.attributes; if (t.position) { var i = t.position.array; if (void 0 === t.normal) this.addAttribute("normal", new gn(new Float32Array(i.length), 3));
                        else
                            for (var n = t.normal.array, r = 0, a = n.length; r < a; r++) n[r] = 0; var o, s, l, c = t.normal.array,
                            h = new Xt,
                            u = new Xt,
                            d = new Xt,
                            p = new Xt,
                            f = new Xt; if (e) { var m = e.array; for (r = 0, a = e.count; r < a; r += 3) o = 3 * m[r + 0], s = 3 * m[r + 1], l = 3 * m[r + 2], h.fromArray(i, o), u.fromArray(i, s), d.fromArray(i, l), p.subVectors(d, u), f.subVectors(h, u), p.cross(f), c[o] += p.x, c[o + 1] += p.y, c[o + 2] += p.z, c[s] += p.x, c[s + 1] += p.y, c[s + 2] += p.z, c[l] += p.x, c[l + 1] += p.y, c[l + 2] += p.z } else
                            for (r = 0, a = i.length; r < a; r += 9) h.fromArray(i, r), u.fromArray(i, r + 3), d.fromArray(i, r + 6), p.subVectors(d, u), f.subVectors(h, u), p.cross(f), c[r] = p.x, c[r + 1] = p.y, c[r + 2] = p.z, c[r + 3] = p.x, c[r + 4] = p.y, c[r + 5] = p.z, c[r + 6] = p.x, c[r + 7] = p.y, c[r + 8] = p.z;
                        this.normalizeNormals(), t.normal.needsUpdate = !0 } }, merge: function(e, t) { if (e && e.isBufferGeometry) { void 0 === t && (t = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var i = this.attributes; for (var n in i)
                            if (void 0 !== e.attributes[n])
                                for (var r = i[n].array, a = e.attributes[n], o = a.array, s = 0, l = a.itemSize * t; s < o.length; s++, l++) r[l] = o[s];
                        return this }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e) }, normalizeNormals: (An = new Xt, function() { for (var e = this.attributes.normal, t = 0, i = e.count; t < i; t++) An.x = e.getX(t), An.y = e.getY(t), An.z = e.getZ(t), An.normalize(), e.setXYZ(t, An.x, An.y, An.z) }), toNonIndexed: function() {
                    function e(e, t) { for (var i = e.array, n = e.itemSize, r = new i.constructor(t.length * n), a = 0, o = 0, s = 0, l = t.length; s < l; s++) { a = t[s] * n; for (var c = 0; c < n; c++) r[o++] = i[a++] } return new gn(r, n) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var t = new Fn,
                        i = this.index.array,
                        n = this.attributes; for (var r in n) { var a = e(n[r], i);
                        t.addAttribute(r, a) } var o = this.morphAttributes; for (r in o) { for (var s = [], l = o[r], c = 0, h = l.length; c < h; c++) { a = e(l[c], i);
                            s.push(a) }
                        t.morphAttributes[r] = s } for (var u = this.groups, d = (c = 0, u.length); c < d; c++) { var p = u[c];
                        t.addGroup(p.start, p.count, p.materialIndex) } return t }, toJSON: function() { var e = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), 0 < Object.keys(this.userData).length && (e.userData = this.userData), void 0 !== this.parameters) { var t = this.parameters; for (var i in t) void 0 !== t[i] && (e[i] = t[i]); return e }
                    e.data = { attributes: {} }; var n = this.index;
                    null !== n && (e.data.index = { type: n.array.constructor.name, array: Array.prototype.slice.call(n.array) }); var r = this.attributes; for (var i in r) { var a = { itemSize: (d = r[i]).itemSize, type: d.array.constructor.name, array: Array.prototype.slice.call(d.array), normalized: d.normalized }; "" !== d.name && (a.name = d.name), e.data.attributes[i] = a } var o = {},
                        s = !1; for (var i in this.morphAttributes) { for (var l = this.morphAttributes[i], c = [], h = 0, u = l.length; h < u; h++) { var d;
                            a = { itemSize: (d = l[h]).itemSize, type: d.array.constructor.name, array: Array.prototype.slice.call(d.array), normalized: d.normalized }; "" !== d.name && (a.name = d.name), c.push(a) }
                        0 < c.length && (o[i] = c, s = !0) }
                    s && (e.data.morphAttributes = o); var p = this.groups;
                    0 < p.length && (e.data.groups = JSON.parse(JSON.stringify(p))); var f = this.boundingSphere; return null !== f && (e.data.boundingSphere = { center: f.center.toArray(), radius: f.radius }), e }, clone: function() { return (new Fn).copy(this) }, copy: function(e) { var t, i, n;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = e.name; var r = e.index;
                    null !== r && this.setIndex(r.clone()); var a = e.attributes; for (t in a) { var o = a[t];
                        this.addAttribute(t, o.clone()) } var s = e.morphAttributes; for (t in s) { var l = [],
                            c = s[t]; for (i = 0, n = c.length; i < n; i++) l.push(c[i].clone());
                        this.morphAttributes[t] = l } var h = e.groups; for (i = 0, n = h.length; i < n; i++) { var u = h[i];
                        this.addGroup(u.start, u.count, u.materialIndex) } var d = e.boundingBox;
                    null !== d && (this.boundingBox = d.clone()); var p = e.boundingSphere; return null !== p && (this.boundingSphere = p.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }), (zn.prototype = Object.create(mn.prototype)).constructor = zn, (kn.prototype = Object.create(Fn.prototype)).constructor = kn, (Un.prototype = Object.create(mn.prototype)).constructor = Un, (Vn.prototype = Object.create(Fn.prototype)).constructor = Vn; var jn = 0;

            function Wn() { Object.defineProperty(this, "id", { value: jn++ }), this.uuid = Ut.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = J, this.side = D, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = w, this.opacity = 1, this.transparent = !1, this.blendSrc = G, this.blendDst = I, this.blendEquation = ie, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = oe, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0 }
            Wn.prototype = Object.assign(Object.create(t.prototype), { constructor: Wn, isMaterial: !0, onBeforeCompile: function() {}, setValues: function(e) { if (void 0 !== e)
                        for (var t in e) { var i = e[t]; if (void 0 !== i)
                                if ("shading" !== t) { var n = this[t];
                                    void 0 !== n ? n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i;
                            else console.warn("THREE.Material: '" + t + "' parameter is undefined.") } }, toJSON: function(e) { var t = void 0 === e || "string" == typeof e;
                    t && (e = { textures: {}, images: {} }); var i = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };

                    function n(e) { var t = []; for (var i in e) { var n = e[i];
                            delete n.metadata, t.push(n) } return t } if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), void 0 !== this.roughness && (i.roughness = this.roughness), void 0 !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), void 0 !== this.shininess && (i.shininess = this.shininess), void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, i.reflectivity = this.reflectivity, void 0 !== this.combine && (i.combine = this.combine), void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.size && (i.size = this.size), void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== J && (i.blending = this.blending), !0 === this.flatShading && (i.flatShading = this.flatShading), this.side !== D && (i.side = this.side), this.vertexColors !== w && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), !0 === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, 0 !== this.rotation && (i.rotation = this.rotation), !0 === this.polygonOffset && (i.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (i.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (i.linewidth = this.linewidth), void 0 !== this.dashSize && (i.dashSize = this.dashSize), void 0 !== this.gapSize && (i.gapSize = this.gapSize), void 0 !== this.scale && (i.scale = this.scale), !0 === this.dithering && (i.dithering = !0), 0 < this.alphaTest && (i.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (i.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (i.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (i.morphTargets = !0), !0 === this.skinning && (i.skinning = !0), !1 === this.visible && (i.visible = !1), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), t) { var r = n(e.textures),
                            a = n(e.images);
                        0 < r.length && (i.textures = r), 0 < a.length && (i.images = a) } return i }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { this.name = e.name, this.fog = e.fog, this.lights = e.lights, this.blending = e.blending, this.side = e.side, this.flatShading = e.flatShading, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.visible = e.visible, this.userData = JSON.parse(JSON.stringify(e.userData)), this.clipShadows = e.clipShadows, this.clipIntersection = e.clipIntersection; var t = e.clippingPlanes,
                        i = null; if (null !== t) { var n = t.length;
                        i = new Array(n); for (var r = 0; r !== n; ++r) i[r] = t[r].clone() } return this.clippingPlanes = i, this.shadowSide = e.shadowSide, this }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }); var Xn, Yn, qn, Zn, Jn, Kn, Qn, $n, er, tr, ir, nr, rr, ar, or, sr, lr, cr, hr, ur, dr, pr, fr, mr, gr, vr = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                Mr = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

            function yr(e) { Wn.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = vr, this.fragmentShader = Mr, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e)) }

            function br(e, t) { this.origin = void 0 !== e ? e : new Xt, this.direction = void 0 !== t ? t : new Xt }

            function _r(e, t, i) { this.a = void 0 !== e ? e : new Xt, this.b = void 0 !== t ? t : new Xt, this.c = void 0 !== i ? i : new Xt }

            function xr(e) { Wn.call(this), this.type = "MeshBasicMaterial", this.color = new Li(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = j, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(e) }

            function Tr(e, t) { on.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new Fn, this.material = void 0 !== t ? t : new xr({ color: 16777215 * Math.random() }), this.drawMode = Lt, this.updateMorphTargets() }

            function wr(o, i, s, n) { var l, c, h = new Li(0),
                    u = 0,
                    d = null,
                    p = 0;

                function f(e, t) { i.buffers.color.setClear(e.r, e.g, e.b, t, n) } return { getClearColor: function() { return h }, setClearColor: function(e, t) { h.set(e), f(h, u = void 0 !== t ? t : 1) }, getClearAlpha: function() { return u }, setClearAlpha: function(e) { f(h, u = e) }, render: function(e, t, i, n) { var r = t.background; if (null === r ? (f(h, u), d = null, p = 0) : r && r.isColor && (f(r, 1), n = !0, d = null, p = 0), (o.autoClear || n) && o.clear(o.autoClearColor, o.autoClearDepth, o.autoClearStencil), r && (r.isCubeTexture || r.isWebGLRenderTargetCube)) { void 0 === c && ((c = new Tr(new kn(1, 1, 1), new yr({ type: "BackgroundCubeMaterial", uniforms: Ti(Gi.cube.uniforms), vertexShader: Gi.cube.vertexShader, fragmentShader: Gi.cube.fragmentShader, side: xe, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), c.geometry.removeAttribute("uv"), c.onBeforeRender = function(e, t, i) { this.matrixWorld.copyPosition(i.matrixWorld) }, Object.defineProperty(c.material, "map", { get: function() { return this.uniforms.tCube.value } }), s.update(c)); var a = r.isWebGLRenderTargetCube ? r.texture : r;
                            c.material.uniforms.tCube.value = a, c.material.uniforms.tFlip.value = r.isWebGLRenderTargetCube ? 1 : -1, d === r && p === a.version || (c.material.needsUpdate = !0, d = r, p = a.version), e.unshift(c, c.geometry, c.material, 0, 0, null) } else r && r.isTexture && (void 0 === l && ((l = new Tr(new Vn(2, 2), new yr({ type: "BackgroundMaterial", uniforms: Ti(Gi.background.uniforms), vertexShader: Gi.background.vertexShader, fragmentShader: Gi.background.fragmentShader, side: D, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), Object.defineProperty(l.material, "map", { get: function() { return this.uniforms.t2D.value } }), s.update(l)), !0 === (l.material.uniforms.t2D.value = r).matrixAutoUpdate && r.updateMatrix(), l.material.uniforms.uvTransform.value.copy(r.matrix), d === r && p === r.version || (l.material.needsUpdate = !0, p = (d = r).version), e.unshift(l, l.geometry, l.material, 0, 0, null)) } } }

            function Sr(r, a, o, s) { var l;
                this.setMode = function(e) { l = e }, this.render = function(e, t) { r.drawArrays(l, e, t), o.update(t, l) }, this.renderInstances = function(e, t, i) { var n; if (s.isWebGL2) n = r;
                    else if (null === (n = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    n[s.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](l, t, i, e.maxInstancedCount), o.update(i, l, e.maxInstancedCount) } }

            function Er(t, i, e) { var n;

                function r(e) { if ("highp" === e) { if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                        e = "mediump" } return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp" } var a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                    o = void 0 !== e.precision ? e.precision : "highp",
                    s = r(o);
                s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s); var l = !0 === e.logarithmicDepthBuffer,
                    c = t.getParameter(34930),
                    h = t.getParameter(35660),
                    u = t.getParameter(3379),
                    d = t.getParameter(34076),
                    p = t.getParameter(34921),
                    f = t.getParameter(36347),
                    m = t.getParameter(36348),
                    g = t.getParameter(36349),
                    v = 0 < h,
                    M = a || !!i.get("OES_texture_float"); return { isWebGL2: a, getMaxAnisotropy: function() { if (void 0 !== n) return n; var e = i.get("EXT_texture_filter_anisotropic"); return n = null !== e ? t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: r, precision: o, logarithmicDepthBuffer: l, maxTextures: c, maxVertexTextures: h, maxTextureSize: u, maxCubemapSize: d, maxAttributes: p, maxVertexUniforms: f, maxVaryings: m, maxFragmentUniforms: g, vertexTextures: v, floatFragmentTextures: M, floatVertexTextures: v && M, maxSamples: a ? t.getParameter(36183) : 0 } }

            function Pr() { var h = this,
                    u = null,
                    d = 0,
                    p = !1,
                    f = !1,
                    m = new bi,
                    g = new Yt,
                    v = { value: null, needsUpdate: !1 };

                function M() { v.value !== u && (v.value = u, v.needsUpdate = 0 < d), h.numPlanes = d, h.numIntersection = 0 }

                function y(e, t, i, n) { var r = null !== e ? e.length : 0,
                        a = null; if (0 !== r) { if (a = v.value, !0 !== n || null === a) { var o = i + 4 * r,
                                s = t.matrixWorldInverse;
                            g.getNormalMatrix(s), (null === a || a.length < o) && (a = new Float32Array(o)); for (var l = 0, c = i; l !== r; ++l, c += 4) m.copy(e[l]).applyMatrix4(s, g), m.normal.toArray(a, c), a[c + 3] = m.constant }
                        v.value = a, v.needsUpdate = !0 } return h.numPlanes = r, a }
                this.uniform = v, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t, i) { var n = 0 !== e.length || t || 0 !== d || p; return p = t, u = y(e, i, 0), d = e.length, n }, this.beginShadows = function() { f = !0, y(null) }, this.endShadows = function() { f = !1, M() }, this.setState = function(e, t, i, n, r, a) { if (!p || null === e || 0 === e.length || f && !i) f ? y(null) : M();
                    else { var o = f ? 0 : d,
                            s = 4 * o,
                            l = r.clippingState || null;
                        v.value = l, l = y(e, n, s, a); for (var c = 0; c !== s; ++c) l[c] = u[c];
                        r.clippingState = l, this.numIntersection = t ? this.numPlanes : 0, this.numPlanes += o } } }

            function Ar(i) { var n = {}; return { get: function(e) { if (void 0 !== n[e]) return n[e]; var t; switch (e) {
                            case "WEBGL_depth_texture":
                                t = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture"); break;
                            case "EXT_texture_filter_anisotropic":
                                t = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break;
                            case "WEBGL_compressed_texture_s3tc":
                                t = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break;
                            case "WEBGL_compressed_texture_pvrtc":
                                t = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break;
                            default:
                                t = i.getExtension(e) } return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), n[e] = t } } }

            function Cr(e, u, a) { var o = {},
                    d = {};

                function s(e) { var t = e.target,
                        i = o[t.id]; for (var n in null !== i.index && u.remove(i.index), i.attributes) u.remove(i.attributes[n]);
                    t.removeEventListener("dispose", s), delete o[t.id]; var r = d[i.id];
                    r && (u.remove(r), delete d[i.id]), a.memory.geometries-- } return { get: function(e, t) { var i = o[t.id]; return i || (t.addEventListener("dispose", s), t.isBufferGeometry ? i = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new Fn).setFromObject(e)), i = t._bufferGeometry), o[t.id] = i, a.memory.geometries++, i) }, update: function(e) { var t = e.index,
                            i = e.attributes; for (var n in null !== t && u.update(t, 34963), i) u.update(i[n], 34962); var r = e.morphAttributes; for (var n in r)
                            for (var a = r[n], o = 0, s = a.length; o < s; o++) u.update(a[o], 34962) }, getWireframeAttribute: function(e) { var t = d[e.id]; if (t) return t; var i, n = [],
                            r = e.index,
                            a = e.attributes; if (null !== r)
                            for (var o = 0, s = (i = r.array).length; o < s; o += 3) { var l = i[o + 0],
                                    c = i[o + 1],
                                    h = i[o + 2];
                                n.push(l, c, c, h, h, l) } else
                                for (o = 0, s = (i = a.position.array).length / 3 - 1; o < s; o += 3) l = o + 0, c = o + 1, h = o + 2, n.push(l, c, c, h, h, l); return t = new(65535 < Pn(n) ? Tn : _n)(n, 1), u.update(t, 34963), d[e.id] = t } } }

            function Lr(r, a, o, s) { var l, c, h;
                this.setMode = function(e) { l = e }, this.setIndex = function(e) { c = e.type, h = e.bytesPerElement }, this.render = function(e, t) { r.drawElements(l, t, c, e * h), o.update(t, l) }, this.renderInstances = function(e, t, i) { var n; if (s.isWebGL2) n = r;
                    else if (null === (n = a.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    n[s.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](l, i, c, t * h, e.maxInstancedCount), o.update(i, l, e.maxInstancedCount) } }

            function Rr(e) { var n = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: n, programs: null, autoReset: !0, reset: function() { n.frame++, n.calls = 0, n.triangles = 0, n.points = 0, n.lines = 0 }, update: function(e, t, i) { switch (i = i || 1, n.calls++, t) {
                            case 4:
                                n.triangles += i * (e / 3); break;
                            case 5:
                            case 6:
                                n.triangles += i * (e - 2); break;
                            case 1:
                                n.lines += i * (e / 2); break;
                            case 3:
                                n.lines += i * (e - 1); break;
                            case 2:
                                n.lines += i * e; break;
                            case 0:
                                n.points += i * e; break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", t) } } } }

            function Hr(e, t) { return Math.abs(t[1]) - Math.abs(e[1]) }

            function Or(p) { var f = {},
                    m = new Float32Array(8); return { update: function(e, t, i, n) { var r = e.morphTargetInfluences,
                            a = r.length,
                            o = f[t.id]; if (void 0 === o) { o = []; for (var s = 0; s < a; s++) o[s] = [s, 0];
                            f[t.id] = o } var l = i.morphTargets && t.morphAttributes.position,
                            c = i.morphNormals && t.morphAttributes.normal; for (s = 0; s < a; s++) 0 !== (h = o[s])[1] && (l && t.removeAttribute("morphTarget" + s), c && t.removeAttribute("morphNormal" + s)); for (s = 0; s < a; s++)(h = o[s])[0] = s, h[1] = r[s]; for (o.sort(Hr), s = 0; s < 8; s++) { var h; if (h = o[s]) { var u = h[0],
                                    d = h[1]; if (d) { l && t.addAttribute("morphTarget" + s, l[u]), c && t.addAttribute("morphNormal" + s, c[u]), m[s] = d; continue } }
                            m[s] = 0 }
                        n.getUniforms().setValue(p, "morphTargetInfluences", m) } } }

            function Gr(r, a) { var o = {}; return { update: function(e) { var t = a.render.frame,
                            i = e.geometry,
                            n = r.get(e, i); return o[n.id] !== t && (i.isGeometry && n.updateFromObject(e), r.update(n), o[n.id] = t), n }, dispose: function() { o = {} } } }

            function Dr(e, t, i, n, r, a, o, s, l, c) { di.call(this, e = void 0 !== e ? e : [], t = void 0 !== t ? t : ve, i, n, r, a, o = void 0 !== o ? o : qe, s, l, c), this.flipY = !1 }

            function Ir(e, t, i, n) { di.call(this, null), this.image = { data: e, width: t, height: i, depth: n }, this.magFilter = Ce, this.minFilter = Ce, this.wrapR = Pe, this.generateMipmaps = !1, this.flipY = !1 }((yr.prototype = Object.create(Wn.prototype)).constructor = yr).prototype.isShaderMaterial = !0, yr.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Ti(e.uniforms), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.lights = e.lights, this.clipping = e.clipping, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this }, yr.prototype.toJSON = function(e) { var t = Wn.prototype.toJSON.call(this, e); for (var i in t.uniforms = {}, this.uniforms) { var n = this.uniforms[i].value;
                    n && n.isTexture ? t.uniforms[i] = { type: "t", value: n.toJSON(e).uuid } : n && n.isColor ? t.uniforms[i] = { type: "c", value: n.getHex() } : n && n.isVector2 ? t.uniforms[i] = { type: "v2", value: n.toArray() } : n && n.isVector3 ? t.uniforms[i] = { type: "v3", value: n.toArray() } : n && n.isVector4 ? t.uniforms[i] = { type: "v4", value: n.toArray() } : n && n.isMatrix3 ? t.uniforms[i] = { type: "m3", value: n.toArray() } : n && n.isMatrix4 ? t.uniforms[i] = { type: "m4", value: n.toArray() } : t.uniforms[i] = { value: n } }
                0 < Object.keys(this.defines).length && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader; var r = {}; for (var a in this.extensions) !0 === this.extensions[a] && (r[a] = !0); return 0 < Object.keys(r).length && (t.extensions = r), t }, Object.assign(br.prototype, { set: function(e, t) { return this.origin.copy(e), this.direction.copy(t), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.origin.copy(e.origin), this.direction.copy(e.direction), this }, at: function(e, t) { return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"), t = new Xt), t.copy(this.direction).multiplyScalar(e).add(this.origin) }, lookAt: function(e) { return this.direction.copy(e).sub(this.origin).normalize(), this }, recast: (ir = new Xt, function(e) { return this.origin.copy(this.at(e, ir)), this }), closestPointToPoint: function(e, t) { void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), t = new Xt), t.subVectors(e, this.origin); var i = t.dot(this.direction); return i < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(i).add(this.origin) }, distanceToPoint: function(e) { return Math.sqrt(this.distanceSqToPoint(e)) }, distanceSqToPoint: (tr = new Xt, function(e) { var t = tr.subVectors(e, this.origin).dot(this.direction); return t < 0 ? this.origin.distanceToSquared(e) : (tr.copy(this.direction).multiplyScalar(t).add(this.origin), tr.distanceToSquared(e)) }), distanceSqToSegment: (Qn = new Xt, $n = new Xt, er = new Xt, function(e, t, i, n) { Qn.copy(e).add(t).multiplyScalar(.5), $n.copy(t).sub(e).normalize(), er.copy(this.origin).sub(Qn); var r, a, o, s, l = .5 * e.distanceTo(t),
                        c = -this.direction.dot($n),
                        h = er.dot(this.direction),
                        u = -er.dot($n),
                        d = er.lengthSq(),
                        p = Math.abs(1 - c * c); if (0 < p)
                        if (a = c * h - u, s = l * p, 0 <= (r = c * u - h))
                            if (-s <= a)
                                if (a <= s) { var f = 1 / p;
                                    o = (r *= f) * (r + c * (a *= f) + 2 * h) + a * (c * r + a + 2 * u) + d } else a = l, o = -(r = Math.max(0, -(c * a + h))) * r + a * (a + 2 * u) + d;
                    else a = -l, o = -(r = Math.max(0, -(c * a + h))) * r + a * (a + 2 * u) + d;
                    else o = a <= -s ? -(r = Math.max(0, -(-c * l + h))) * r + (a = 0 < r ? -l : Math.min(Math.max(-l, -u), l)) * (a + 2 * u) + d : a <= s ? (r = 0, (a = Math.min(Math.max(-l, -u), l)) * (a + 2 * u) + d) : -(r = Math.max(0, -(c * l + h))) * r + (a = 0 < r ? l : Math.min(Math.max(-l, -u), l)) * (a + 2 * u) + d;
                    else a = 0 < c ? -l : l, o = -(r = Math.max(0, -(c * a + h))) * r + a * (a + 2 * u) + d; return i && i.copy(this.direction).multiplyScalar(r).add(this.origin), n && n.copy($n).multiplyScalar(a).add(Qn), o }), intersectSphere: (Kn = new Xt, function(e, t) { Kn.subVectors(e.center, this.origin); var i = Kn.dot(this.direction),
                        n = Kn.dot(Kn) - i * i,
                        r = e.radius * e.radius; if (r < n) return null; var a = Math.sqrt(r - n),
                        o = i - a,
                        s = i + a; return o < 0 && s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t) }), intersectsSphere: function(e) { return this.distanceSqToPoint(e.center) <= e.radius * e.radius }, distanceToPlane: function(e) { var t = e.normal.dot(this.direction); if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null; var i = -(this.origin.dot(e.normal) + e.constant) / t; return 0 <= i ? i : null }, intersectPlane: function(e, t) { var i = this.distanceToPlane(e); return null === i ? null : this.at(i, t) }, intersectsPlane: function(e) { var t = e.distanceToPoint(this.origin); return 0 === t || e.normal.dot(this.direction) * t < 0 }, intersectBox: function(e, t) { var i, n, r, a, o, s, l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin; return n = 0 <= l ? (i = (e.min.x - u.x) * l, (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l, (e.min.x - u.x) * l), (a = 0 <= c ? (r = (e.min.y - u.y) * c, (e.max.y - u.y) * c) : (r = (e.max.y - u.y) * c, (e.min.y - u.y) * c)) < i || n < r ? null : ((i < r || i != i) && (i = r), (a < n || n != n) && (n = a), (s = 0 <= h ? (o = (e.min.z - u.z) * h, (e.max.z - u.z) * h) : (o = (e.max.z - u.z) * h, (e.min.z - u.z) * h)) < i || n < o ? null : ((i < o || i != i) && (i = o), (s < n || n != n) && (n = s), n < 0 ? null : this.at(0 <= i ? i : n, t))) }, intersectsBox: (Jn = new Xt, function(e) { return null !== this.intersectBox(e, Jn) }), intersectTriangle: (Xn = new Xt, Yn = new Xt, qn = new Xt, Zn = new Xt, function(e, t, i, n, r) { Yn.subVectors(t, e), qn.subVectors(i, e), Zn.crossVectors(Yn, qn); var a, o = this.direction.dot(Zn); if (0 < o) { if (n) return null;
                        a = 1 } else { if (!(o < 0)) return null;
                        a = -1, o = -o }
                    Xn.subVectors(this.origin, e); var s = a * this.direction.dot(qn.crossVectors(Xn, qn)); if (s < 0) return null; var l = a * this.direction.dot(Yn.cross(Xn)); if (l < 0) return null; if (o < s + l) return null; var c = -a * Xn.dot(Zn); return c < 0 ? null : this.at(c / o, r) }), applyMatrix4: function(e) { return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this }, equals: function(e) { return e.origin.equals(this.origin) && e.direction.equals(this.direction) } }), Object.assign(_r, { getNormal: (lr = new Xt, function(e, t, i, n) { void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"), n = new Xt), n.subVectors(i, t), lr.subVectors(e, t), n.cross(lr); var r = n.lengthSq(); return 0 < r ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0) }), getBarycoord: (ar = new Xt, or = new Xt, sr = new Xt, function(e, t, i, n, r) { ar.subVectors(n, t), or.subVectors(i, t), sr.subVectors(e, t); var a = ar.dot(ar),
                        o = ar.dot(or),
                        s = ar.dot(sr),
                        l = or.dot(or),
                        c = or.dot(sr),
                        h = a * l - o * o; if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new Xt), 0 === h) return r.set(-2, -1, -1); var u = 1 / h,
                        d = (l * s - o * c) * u,
                        p = (a * c - o * s) * u; return r.set(1 - d - p, p, d) }), containsPoint: (rr = new Xt, function(e, t, i, n) { return _r.getBarycoord(e, t, i, n, rr), 0 <= rr.x && 0 <= rr.y && rr.x + rr.y <= 1 }), getUV: (nr = new Xt, function(e, t, i, n, r, a, o, s) { return this.getBarycoord(e, t, i, n, nr), s.set(0, 0), s.addScaledVector(r, nr.x), s.addScaledVector(a, nr.y), s.addScaledVector(o, nr.z), s }) }), Object.assign(_r.prototype, { set: function(e, t, i) { return this.a.copy(e), this.b.copy(t), this.c.copy(i), this }, setFromPointsAndIndices: function(e, t, i, n) { return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this }, getArea: (mr = new Xt, gr = new Xt, function() { return mr.subVectors(this.c, this.b), gr.subVectors(this.a, this.b), .5 * mr.cross(gr).length() }), getMidpoint: function(e) { return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), e = new Xt), e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, getNormal: function(e) { return _r.getNormal(this.a, this.b, this.c, e) }, getPlane: function(e) { return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"), e = new Xt), e.setFromCoplanarPoints(this.a, this.b, this.c) }, getBarycoord: function(e, t) { return _r.getBarycoord(e, this.a, this.b, this.c, t) }, containsPoint: function(e) { return _r.containsPoint(e, this.a, this.b, this.c) }, getUV: function(e, t, i, n, r) { return _r.getUV(e, this.a, this.b, this.c, t, i, n, r) }, intersectsBox: function(e) { return e.intersectsTriangle(this) }, closestPointToPoint: (cr = new Xt, hr = new Xt, ur = new Xt, dr = new Xt, pr = new Xt, fr = new Xt, function(e, t) { void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), t = new Xt); var i, n, r = this.a,
                        a = this.b,
                        o = this.c;
                    cr.subVectors(a, r), hr.subVectors(o, r), dr.subVectors(e, r); var s = cr.dot(dr),
                        l = hr.dot(dr); if (s <= 0 && l <= 0) return t.copy(r);
                    pr.subVectors(e, a); var c = cr.dot(pr),
                        h = hr.dot(pr); if (0 <= c && h <= c) return t.copy(a); var u = s * h - c * l; if (u <= 0 && 0 <= s && c <= 0) return i = s / (s - c), t.copy(r).addScaledVector(cr, i);
                    fr.subVectors(e, o); var d = cr.dot(fr),
                        p = hr.dot(fr); if (0 <= p && d <= p) return t.copy(o); var f = d * l - s * p; if (f <= 0 && 0 <= l && p <= 0) return n = l / (l - p), t.copy(r).addScaledVector(hr, n); var m = c * p - d * h; if (m <= 0 && 0 <= h - c && 0 <= d - p) return ur.subVectors(o, a), n = (h - c) / (h - c + (d - p)), t.copy(a).addScaledVector(ur, n); var g = 1 / (m + f + u); return i = f * g, n = u * g, t.copy(r).addScaledVector(cr, i).addScaledVector(hr, n) }), equals: function(e) { return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c) } }), ((xr.prototype = Object.create(Wn.prototype)).constructor = xr).prototype.isMeshBasicMaterial = !0, xr.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this }, Tr.prototype = Object.assign(Object.create(on.prototype), { constructor: Tr, isMesh: !0, setDrawMode: function(e) { this.drawMode = e }, copy: function(e) { return on.prototype.copy.call(this, e), this.drawMode = e.drawMode, void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this }, updateMorphTargets: function() { var e, t, i, n = this.geometry; if (n.isBufferGeometry) { var r = n.morphAttributes,
                            a = Object.keys(r); if (0 < a.length) { var o = r[a[0]]; if (void 0 !== o)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, e = 0, t = o.length; e < t; e++) i = o[e].name || String(e), this.morphTargetInfluences.push(0), this.morphTargetDictionary[i] = e } } else { var s = n.morphTargets;
                        void 0 !== s && 0 < s.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") } }, raycast: function() { var F = new jt,
                        z = new br,
                        k = new yi,
                        U = new Xt,
                        V = new Xt,
                        j = new Xt,
                        W = new Xt,
                        X = new Xt,
                        Y = new Xt,
                        q = new Vt,
                        Z = new Vt,
                        J = new Vt,
                        K = new Xt,
                        c = new Xt;

                    function Q(e, t, i, n, r, a, o, s) { if (null === (t.side === xe ? n.intersectTriangle(o, a, r, !0, s) : n.intersectTriangle(r, a, o, t.side !== ee, s))) return null;
                        c.copy(s), c.applyMatrix4(e.matrixWorld); var l = i.ray.origin.distanceTo(c); return l < i.near || l > i.far ? null : { distance: l, point: c.clone(), object: e } }

                    function $(e, t, i, n, r, a, o, s, l) { U.fromBufferAttribute(r, o), V.fromBufferAttribute(r, s), j.fromBufferAttribute(r, l); var c = Q(e, t, i, n, U, V, j, K); if (c) { a && (q.fromBufferAttribute(a, o), Z.fromBufferAttribute(a, s), J.fromBufferAttribute(a, l), c.uv = _r.getUV(K, U, V, j, q, Z, J, new Vt)); var h = new Bi(o, s, l);
                            _r.getNormal(U, V, j, h.normal), c.face = h } return c } return function(e, t) { var i, n = this.geometry,
                            r = this.material,
                            a = this.matrixWorld; if (void 0 !== r && (null === n.boundingSphere && n.computeBoundingSphere(), k.copy(n.boundingSphere), k.applyMatrix4(a), !1 !== e.ray.intersectsSphere(k) && (F.getInverse(a), z.copy(e.ray).applyMatrix4(F), null === n.boundingBox || !1 !== z.intersectsBox(n.boundingBox))))
                            if (n.isBufferGeometry) { var o, s, l, c, h, u, d, p, f, m = n.index,
                                    g = n.attributes.position,
                                    v = n.attributes.uv,
                                    M = n.groups,
                                    y = n.drawRange; if (null !== m)
                                    if (Array.isArray(r))
                                        for (c = 0, u = M.length; c < u; c++)
                                            for (f = r[(p = M[c]).materialIndex], h = Math.max(p.start, y.start), d = Math.min(p.start + p.count, y.start + y.count); h < d; h += 3) o = m.getX(h), s = m.getX(h + 1), l = m.getX(h + 2), (i = $(this, f, e, z, g, v, o, s, l)) && (i.faceIndex = Math.floor(h / 3), i.face.materialIndex = p.materialIndex, t.push(i));
                                    else
                                        for (c = Math.max(0, y.start), u = Math.min(m.count, y.start + y.count); c < u; c += 3) o = m.getX(c), s = m.getX(c + 1), l = m.getX(c + 2), (i = $(this, r, e, z, g, v, o, s, l)) && (i.faceIndex = Math.floor(c / 3), t.push(i));
                                else if (void 0 !== g)
                                    if (Array.isArray(r))
                                        for (c = 0, u = M.length; c < u; c++)
                                            for (f = r[(p = M[c]).materialIndex], h = Math.max(p.start, y.start), d = Math.min(p.start + p.count, y.start + y.count); h < d; h += 3)(i = $(this, f, e, z, g, v, o = h, s = h + 1, l = h + 2)) && (i.faceIndex = Math.floor(h / 3), i.face.materialIndex = p.materialIndex, t.push(i));
                                    else
                                        for (c = Math.max(0, y.start), u = Math.min(g.count, y.start + y.count); c < u; c += 3)(i = $(this, r, e, z, g, v, o = c, s = c + 1, l = c + 2)) && (i.faceIndex = Math.floor(c / 3), t.push(i)) } else if (n.isGeometry) { var b, _, x, T, w = Array.isArray(r),
                                S = n.vertices,
                                E = n.faces,
                                P = n.faceVertexUvs[0];
                            0 < P.length && (T = P); for (var A = 0, C = E.length; A < C; A++) { var L = E[A],
                                    R = w ? r[L.materialIndex] : r; if (void 0 !== R) { if (b = S[L.a], _ = S[L.b], x = S[L.c], !0 === R.morphTargets) { var H = n.morphTargets,
                                            O = this.morphTargetInfluences;
                                        U.set(0, 0, 0), V.set(0, 0, 0), j.set(0, 0, 0); for (var G = 0, D = H.length; G < D; G++) { var I = O[G]; if (0 !== I) { var B = H[G].vertices;
                                                U.addScaledVector(W.subVectors(B[L.a], b), I), V.addScaledVector(X.subVectors(B[L.b], _), I), j.addScaledVector(Y.subVectors(B[L.c], x), I) } }
                                        U.add(b), V.add(_), j.add(x), b = U, _ = V, x = j } if (i = Q(this, R, e, z, b, _, x, K)) { if (T && T[A]) { var N = T[A];
                                            q.copy(N[0]), Z.copy(N[1]), J.copy(N[2]), i.uv = _r.getUV(K, b, _, x, q, Z, J, new Vt) }
                                        i.face = L, i.faceIndex = A, t.push(i) } } } } } }(), clone: function() { return new this.constructor(this.geometry, this.material).copy(this) } }), ((Dr.prototype = Object.create(di.prototype)).constructor = Dr).prototype.isCubeTexture = !0, Object.defineProperty(Dr.prototype, "images", { get: function() { return this.image }, set: function(e) { this.image = e } }), ((Ir.prototype = Object.create(di.prototype)).constructor = Ir).prototype.isDataTexture3D = !0; var Br = new di,
                Nr = new Ir,
                Fr = new Dr;

            function zr() { this.seq = [], this.map = {} } var kr = [],
                Ur = [],
                Vr = new Float32Array(16),
                jr = new Float32Array(9),
                Wr = new Float32Array(4);

            function Xr(e, t, i) { var n = e[0]; if (n <= 0 || 0 < n) return e; var r = t * i,
                    a = kr[r]; if (void 0 === a && (a = new Float32Array(r), kr[r] = a), 0 !== t) { n.toArray(a, 0); for (var o = 1, s = 0; o !== t; ++o) s += i, e[o].toArray(a, s) } return a }

            function Yr(e, t) { if (e.length !== t.length) return !1; for (var i = 0, n = e.length; i < n; i++)
                    if (e[i] !== t[i]) return !1;
                return !0 }

            function qr(e, t) { for (var i = 0, n = t.length; i < n; i++) e[i] = t[i] }

            function Zr(e, t) { var i = Ur[t];
                void 0 === i && (i = new Int32Array(t), Ur[t] = i); for (var n = 0; n !== t; ++n) i[n] = e.allocTextureUnit(); return i }

            function Jr(e, t) { var i = this.cache;
                i[0] !== t && (e.uniform1f(this.addr, t), i[0] = t) }

            function Kr(e, t) { var i = this.cache;
                i[0] !== t && (e.uniform1i(this.addr, t), i[0] = t) }

            function Qr(e, t) { var i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), i[0] = t.x, i[1] = t.y);
                else { if (Yr(i, t)) return;
                    e.uniform2fv(this.addr, t), qr(i, t) } }

            function $r(e, t) { var i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), i[0] = t.x, i[1] = t.y, i[2] = t.z);
                else if (void 0 !== t.r) i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), i[0] = t.r, i[1] = t.g, i[2] = t.b);
                else { if (Yr(i, t)) return;
                    e.uniform3fv(this.addr, t), qr(i, t) } }

            function ea(e, t) { var i = this.cache; if (void 0 !== t.x) i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), i[0] = t.x, i[1] = t.y, i[2] = t.z, i[3] = t.w);
                else { if (Yr(i, t)) return;
                    e.uniform4fv(this.addr, t), qr(i, t) } }

            function ta(e, t) { var i = this.cache,
                    n = t.elements; if (void 0 === n) { if (Yr(i, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), qr(i, t) } else { if (Yr(i, n)) return;
                    Wr.set(n), e.uniformMatrix2fv(this.addr, !1, Wr), qr(i, n) } }

            function ia(e, t) { var i = this.cache,
                    n = t.elements; if (void 0 === n) { if (Yr(i, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), qr(i, t) } else { if (Yr(i, n)) return;
                    jr.set(n), e.uniformMatrix3fv(this.addr, !1, jr), qr(i, n) } }

            function na(e, t) { var i = this.cache,
                    n = t.elements; if (void 0 === n) { if (Yr(i, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), qr(i, t) } else { if (Yr(i, n)) return;
                    Vr.set(n), e.uniformMatrix4fv(this.addr, !1, Vr), qr(i, n) } }

            function ra(e, t, i) { var n = this.cache,
                    r = i.allocTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(t || Br, r) }

            function aa(e, t, i) { var n = this.cache,
                    r = i.allocTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(t || Nr, r) }

            function oa(e, t, i) { var n = this.cache,
                    r = i.allocTextureUnit();
                n[0] !== r && (e.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(t || Fr, r) }

            function sa(e, t) { var i = this.cache;
                Yr(i, t) || (e.uniform2iv(this.addr, t), qr(i, t)) }

            function la(e, t) { var i = this.cache;
                Yr(i, t) || (e.uniform3iv(this.addr, t), qr(i, t)) }

            function ca(e, t) { var i = this.cache;
                Yr(i, t) || (e.uniform4iv(this.addr, t), qr(i, t)) }

            function ha(e, t) { var i = this.cache;
                Yr(i, t) || (e.uniform1fv(this.addr, t), qr(i, t)) }

            function ua(e, t) { var i = this.cache;
                Yr(i, t) || (e.uniform1iv(this.addr, t), qr(i, t)) }

            function da(e, t) { var i = this.cache,
                    n = Xr(t, this.size, 2);
                Yr(i, n) || (e.uniform2fv(this.addr, n), this.updateCache(n)) }

            function pa(e, t) { var i = this.cache,
                    n = Xr(t, this.size, 3);
                Yr(i, n) || (e.uniform3fv(this.addr, n), this.updateCache(n)) }

            function fa(e, t) { var i = this.cache,
                    n = Xr(t, this.size, 4);
                Yr(i, n) || (e.uniform4fv(this.addr, n), this.updateCache(n)) }

            function ma(e, t) { var i = this.cache,
                    n = Xr(t, this.size, 4);
                Yr(i, n) || (e.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n)) }

            function ga(e, t) { var i = this.cache,
                    n = Xr(t, this.size, 9);
                Yr(i, n) || (e.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n)) }

            function va(e, t) { var i = this.cache,
                    n = Xr(t, this.size, 16);
                Yr(i, n) || (e.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n)) }

            function Ma(e, t, i) { var n = this.cache,
                    r = t.length,
                    a = Zr(i, r);!1 === Yr(n, a) && (e.uniform1iv(this.addr, a), qr(n, a)); for (var o = 0; o !== r; ++o) i.setTexture2D(t[o] || Br, a[o]) }

            function ya(e, t, i) { var n = this.cache,
                    r = t.length,
                    a = Zr(i, r);!1 === Yr(n, a) && (e.uniform1iv(this.addr, a), qr(n, a)); for (var o = 0; o !== r; ++o) i.setTextureCube(t[o] || Fr, a[o]) }

            function ba(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.setValue = function(e) { switch (e) {
                        case 5126:
                            return Jr;
                        case 35664:
                            return Qr;
                        case 35665:
                            return $r;
                        case 35666:
                            return ea;
                        case 35674:
                            return ta;
                        case 35675:
                            return ia;
                        case 35676:
                            return na;
                        case 35678:
                        case 36198:
                            return ra;
                        case 35679:
                            return aa;
                        case 35680:
                            return oa;
                        case 5124:
                        case 35670:
                            return Kr;
                        case 35667:
                        case 35671:
                            return sa;
                        case 35668:
                        case 35672:
                            return la;
                        case 35669:
                        case 35673:
                            return ca } }(t.type) }

            function _a(e, t, i) { this.id = e, this.addr = i, this.cache = [], this.size = t.size, this.setValue = function(e) { switch (e) {
                        case 5126:
                            return ha;
                        case 35664:
                            return da;
                        case 35665:
                            return pa;
                        case 35666:
                            return fa;
                        case 35674:
                            return ma;
                        case 35675:
                            return ga;
                        case 35676:
                            return va;
                        case 35678:
                            return Ma;
                        case 35680:
                            return ya;
                        case 5124:
                        case 35670:
                            return ua;
                        case 35667:
                        case 35671:
                            return sa;
                        case 35668:
                        case 35672:
                            return la;
                        case 35669:
                        case 35673:
                            return ca } }(t.type) }

            function xa(e) { this.id = e, zr.call(this) }
            _a.prototype.updateCache = function(e) { var t = this.cache;
                e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)), qr(t, e) }, xa.prototype.setValue = function(e, t, i) { for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) { var o = n[r];
                    o.setValue(e, t[o.id], i) } }; var Ta = /([\w\d_]+)(\])?(\[|\.)?/g;

            function wa(e, t) { e.seq.push(t), e.map[t.id] = t }

            function Sa(e, t, i) { var n = e.name,
                    r = n.length; for (Ta.lastIndex = 0;;) { var a = Ta.exec(n),
                        o = Ta.lastIndex,
                        s = a[1],
                        l = "]" === a[2],
                        c = a[3]; if (l && (s |= 0), void 0 === c || "[" === c && o + 2 === r) { wa(i, void 0 === c ? new ba(s, e, t) : new _a(s, e, t)); break } var h = i.map[s];
                    void 0 === h && wa(i, h = new xa(s)), i = h } }

            function Ea(e, t, i) { zr.call(this), this.renderer = i; for (var n = e.getProgramParameter(t, 35718), r = 0; r < n; ++r) { var a = e.getActiveUniform(t, r);
                    Sa(a, e.getUniformLocation(t, a.name), this) } }

            function Pa(e, t, i) { var n = e.createShader(t); return e.shaderSource(n, i), e.compileShader(n), !1 === e.getShaderParameter(n, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== e.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(n), function(e) { for (var t = e.split("\n"), i = 0; i < t.length; i++) t[i] = i + 1 + ": " + t[i]; return t.join("\n") }(i)), n }
            Ea.prototype.setValue = function(e, t, i) { var n = this.map[t];
                void 0 !== n && n.setValue(e, i, this.renderer) }, Ea.prototype.setOptional = function(e, t, i) { var n = t[i];
                void 0 !== n && this.setValue(e, i, n) }, Ea.upload = function(e, t, i, n) { for (var r = 0, a = t.length; r !== a; ++r) { var o = t[r],
                        s = i[o.id];!1 !== s.needsUpdate && o.setValue(e, s.value, n) } }, Ea.seqWithValue = function(e, t) { for (var i = [], n = 0, r = e.length; n !== r; ++n) { var a = e[n];
                    a.id in t && i.push(a) } return i }; var Aa = 0;

            function Ca(e) { switch (e) {
                    case Rt:
                        return ["Linear", "( value )"];
                    case Ht:
                        return ["sRGB", "( value )"];
                    case Gt:
                        return ["RGBE", "( value )"];
                    case Dt:
                        return ["RGBM", "( value, 7.0 )"];
                    case It:
                        return ["RGBM", "( value, 16.0 )"];
                    case Bt:
                        return ["RGBD", "( value, 256.0 )"];
                    case Ot:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + e) } }

            function La(e, t) { var i = Ca(t); return "vec4 " + e + "( vec4 value ) { return " + i[0] + "ToLinear" + i[1] + "; }" }

            function Ra(e) { return "" !== e }

            function Ha(e, t) { return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights) }

            function Oa(e, t) { return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) }

            function Ga(e) { return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e, t) { var i = xi[t]; if (void 0 === i) throw new Error("Can not resolve #include <" + t + ">"); return Ga(i) }) }

            function Da(e) { return e.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(e, t, i, n) { for (var r = "", a = parseInt(t); a < parseInt(i); a++) r += n.replace(/\[ i \]/g, "[ " + a + " ]"); return r }) }

            function Ia(e, t, i, n, r, a, o) { var s = e.context,
                    l = n.defines,
                    c = r.vertexShader,
                    h = r.fragmentShader,
                    u = "SHADOWMAP_TYPE_BASIC";
                a.shadowMapType === F ? u = "SHADOWMAP_TYPE_PCF" : a.shadowMapType === z && (u = "SHADOWMAP_TYPE_PCF_SOFT"); var d = "ENVMAP_TYPE_CUBE",
                    p = "ENVMAP_MODE_REFLECTION",
                    f = "ENVMAP_BLENDING_MULTIPLY"; if (a.envMap) { switch (n.envMap.mapping) {
                        case ve:
                        case Me:
                            d = "ENVMAP_TYPE_CUBE"; break;
                        case we:
                        case Se:
                            d = "ENVMAP_TYPE_CUBE_UV"; break;
                        case ye:
                        case be:
                            d = "ENVMAP_TYPE_EQUIREC"; break;
                        case _e:
                            d = "ENVMAP_TYPE_SPHERE" } switch (n.envMap.mapping) {
                        case Me:
                        case be:
                            p = "ENVMAP_MODE_REFRACTION" } switch (n.combine) {
                        case j:
                            f = "ENVMAP_BLENDING_MULTIPLY"; break;
                        case W:
                            f = "ENVMAP_BLENDING_MIX"; break;
                        case ue:
                            f = "ENVMAP_BLENDING_ADD" } } var m, g, v, M, y, b, _, x, T = 0 < e.gammaFactor ? e.gammaFactor : 1,
                    w = o.isWebGL2 ? "" : (m = n.extensions, g = a, v = t, [(m = m || {}).derivatives || g.envMapCubeUV || g.bumpMap || g.normalMap && !g.objectSpaceNormalMap || g.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (m.fragDepth || g.logarithmicDepthBuffer) && v.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", m.drawBuffers && v.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (m.shaderTextureLOD || g.envMap) && v.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ra).join("\n")),
                    S = function(e) { var t = []; for (var i in e) { var n = e[i];!1 !== n && t.push("#define " + i + " " + n) } return t.join("\n") }(l),
                    E = s.createProgram(); if (n.isRawShaderMaterial ? (0 < (M = [S].filter(Ra).join("\n")).length && (M += "\n"), 0 < (y = [w, S].filter(Ra).join("\n")).length && (y += "\n")) : (M = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, S, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + T, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + p : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ra).join("\n"), y = [w, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, S, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + T, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + p : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexTangents ? "#define USE_TANGENT" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", a.toneMapping !== de ? "#define TONE_MAPPING" : "", a.toneMapping !== de ? xi.tonemapping_pars_fragment : "", a.toneMapping !== de ? function(e, t) { var i; switch (t) {
                            case Te:
                                i = "Linear"; break;
                            case pe:
                                i = "Reinhard"; break;
                            case fe:
                                i = "Uncharted2"; break;
                            case me:
                                i = "OptimizedCineon"; break;
                            case ge:
                                i = "ACESFilmic"; break;
                            default:
                                throw new Error("unsupported toneMapping: " + t) } return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }" }("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? xi.encodings_pars_fragment : "", a.mapEncoding ? La("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? La("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? La("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? La("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? (b = "linearToOutputTexel", _ = a.outputEncoding, x = Ca(_), "vec4 " + b + "( vec4 value ) { return LinearTo" + x[0] + x[1] + "; }") : "", a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ra).join("\n")), c = Oa(c = Ha(c = Ga(c), a), a), h = Oa(h = Ha(h = Ga(h), a), a), c = Da(c), h = Da(h), o.isWebGL2 && !n.isRawShaderMaterial) { var P = !1,
                        A = /^\s*#version\s+300\s+es\s*\n/;
                    n.isShaderMaterial && null !== c.match(A) && null !== h.match(A) && (P = !0, c = c.replace(A, ""), h = h.replace(A, "")), M = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + M, y = ["#version 300 es\n", "#define varying in", P ? "" : "out highp vec4 pc_fragColor;", P ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y } var C = y + h,
                    L = Pa(s, 35633, M + c),
                    R = Pa(s, 35632, C);
                s.attachShader(E, L), s.attachShader(E, R), void 0 !== n.index0AttributeName ? s.bindAttribLocation(E, 0, n.index0AttributeName) : !0 === a.morphTargets && s.bindAttribLocation(E, 0, "position"), s.linkProgram(E); var H, O, G = s.getProgramInfoLog(E).trim(),
                    D = s.getShaderInfoLog(L).trim(),
                    I = s.getShaderInfoLog(R).trim(),
                    B = !0,
                    N = !0; return !1 === s.getProgramParameter(E, 35714) ? (B = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(E, 35715), "gl.getProgramInfoLog", G, D, I)) : "" !== G ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", G) : "" !== D && "" !== I || (N = !1), N && (this.diagnostics = { runnable: B, material: n, programLog: G, vertexShader: { log: D, prefix: M }, fragmentShader: { log: I, prefix: y } }), s.deleteShader(L), s.deleteShader(R), this.getUniforms = function() { return void 0 === H && (H = new Ea(s, E, e)), H }, this.getAttributes = function() { return void 0 === O && (O = function(e, t) { for (var i = {}, n = e.getProgramParameter(t, 35721), r = 0; r < n; r++) { var a = e.getActiveAttrib(t, r).name;
                            i[a] = e.getAttribLocation(t, a) } return i }(s, E)), O }, this.destroy = function() { s.deleteProgram(E), this.program = void 0 }, Object.defineProperties(this, { uniforms: { get: function() { return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms() } }, attributes: { get: function() { return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes() } } }), this.name = r.name, this.id = Aa++, this.code = i, this.usedTimes = 1, this.program = E, this.vertexShader = L, this.fragmentShader = R, this }

            function Ba(u, l, d) { var c = [],
                    p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" },
                    a = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

                function f(e, t) { var i; return e ? e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = e.texture.encoding) : i = Rt, i === Rt && t && (i = Ot), i }
                this.getParameters = function(e, t, i, n, r, a, o) { var s = p[e.type],
                        l = o.isSkinnedMesh ? function(e) { var t = e.skeleton.bones; if (d.floatVertexTextures) return 1024; var i = d.maxVertexUniforms,
                                n = Math.floor((i - 20) / 4),
                                r = Math.min(n, t.length); return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r }(o) : 0,
                        c = d.precision;
                    null !== e.precision && (c = d.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", c, "instead."); var h = u.getRenderTarget(); return { shaderID: s, precision: c, supportsVertexTextures: d.vertexTextures, outputEncoding: f(h ? h.texture : null, u.gammaOutput), map: !!e.map, mapEncoding: f(e.map, u.gammaInput), matcap: !!e.matcap, matcapEncoding: f(e.matcap, u.gammaInput), envMap: !!e.envMap, envMapMode: e.envMap && e.envMap.mapping, envMapEncoding: f(e.envMap, u.gammaInput), envMapCubeUV: !!e.envMap && (e.envMap.mapping === we || e.envMap.mapping === Se), lightMap: !!e.lightMap, aoMap: !!e.aoMap, emissiveMap: !!e.emissiveMap, emissiveMapEncoding: f(e.emissiveMap, u.gammaInput), bumpMap: !!e.bumpMap, normalMap: !!e.normalMap, objectSpaceNormalMap: e.normalMapType === kt, displacementMap: !!e.displacementMap, roughnessMap: !!e.roughnessMap, metalnessMap: !!e.metalnessMap, specularMap: !!e.specularMap, alphaMap: !!e.alphaMap, gradientMap: !!e.gradientMap, combine: e.combine, vertexTangents: e.normalMap && e.vertexTangents, vertexColors: e.vertexColors, fog: !!n, useFog: e.fog, fogExp: n && n.isFogExp2, flatShading: e.flatShading, sizeAttenuation: e.sizeAttenuation, logarithmicDepthBuffer: d.logarithmicDepthBuffer, skinning: e.skinning && 0 < l, maxBones: l, useVertexTexture: d.floatVertexTextures, morphTargets: e.morphTargets, morphNormals: e.morphNormals, maxMorphTargets: u.maxMorphTargets, maxMorphNormals: u.maxMorphNormals, numDirLights: t.directional.length, numPointLights: t.point.length, numSpotLights: t.spot.length, numRectAreaLights: t.rectArea.length, numHemiLights: t.hemi.length, numClippingPlanes: r, numClipIntersection: a, dithering: e.dithering, shadowMapEnabled: u.shadowMap.enabled && o.receiveShadow && 0 < i.length, shadowMapType: u.shadowMap.type, toneMapping: u.toneMapping, physicallyCorrectLights: u.physicallyCorrectLights, premultipliedAlpha: e.premultipliedAlpha, alphaTest: e.alphaTest, doubleSided: e.side === ee, flipSided: e.side === xe, depthPacking: void 0 !== e.depthPacking && e.depthPacking } }, this.getProgramCode = function(e, t) { var i = []; if (t.shaderID ? i.push(t.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines)
                        for (var n in e.defines) i.push(n), i.push(e.defines[n]); for (var r = 0; r < a.length; r++) i.push(t[a[r]]); return i.push(e.onBeforeCompile.toString()), i.push(u.gammaOutput), i.push(u.gammaFactor), i.join() }, this.acquireProgram = function(e, t, i, n) { for (var r, a = 0, o = c.length; a < o; a++) { var s = c[a]; if (s.code === n) {++(r = s).usedTimes; break } } return void 0 === r && (r = new Ia(u, l, n, e, t, i, d), c.push(r)), r }, this.releaseProgram = function(e) { if (0 == --e.usedTimes) { var t = c.indexOf(e);
                        c[t] = c[c.length - 1], c.pop(), e.destroy() } }, this.programs = c }

            function Na() { var n = new WeakMap; return { get: function(e) { var t = n.get(e); return void 0 === t && (t = {}, n.set(e, t)), t }, remove: function(e) { n.delete(e) }, update: function(e, t, i) { n.get(e)[t] = i }, dispose: function() { n = new WeakMap } } }

            function Fa(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id }

            function za(e, t) { return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id }

            function ka() { var s = [],
                    l = 0,
                    c = [],
                    h = [];

                function u(e, t, i, n, r, a) { var o = s[l]; return void 0 === o ? (o = { id: e.id, object: e, geometry: t, material: i, program: i.program, groupOrder: n, renderOrder: e.renderOrder, z: r, group: a }, s[l] = o) : (o.id = e.id, o.object = e, o.geometry = t, o.material = i, o.program = i.program, o.groupOrder = n, o.renderOrder = e.renderOrder, o.z = r, o.group = a), l++, o } return { opaque: c, transparent: h, init: function() { l = 0, c.length = 0, h.length = 0 }, push: function(e, t, i, n, r, a) { var o = u(e, t, i, n, r, a);
                        (!0 === i.transparent ? h : c).push(o) }, unshift: function(e, t, i, n, r, a) { var o = u(e, t, i, n, r, a);
                        (!0 === i.transparent ? h : c).unshift(o) }, sort: function() { 1 < c.length && c.sort(Fa), 1 < h.length && h.sort(za) } } }

            function Ua() { var r = {};

                function a(e) { var t = e.target;
                    t.removeEventListener("dispose", a), delete r[t.id] } return { get: function(e, t) { var i, n = r[e.id]; return void 0 === n ? (i = new ka, r[e.id] = {}, r[e.id][t.id] = i, e.addEventListener("dispose", a)) : void 0 === (i = n[t.id]) && (i = new ka, n[t.id] = i), i }, dispose: function() { r = {} } } }

            function Va() { var i = {}; return { get: function(e) { if (void 0 !== i[e.id]) return i[e.id]; var t; switch (e.type) {
                            case "DirectionalLight":
                                t = { direction: new Xt, color: new Li, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Vt }; break;
                            case "SpotLight":
                                t = { position: new Xt, direction: new Xt, color: new Li, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Vt }; break;
                            case "PointLight":
                                t = { position: new Xt, color: new Li, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new Vt, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break;
                            case "HemisphereLight":
                                t = { direction: new Xt, skyColor: new Li, groundColor: new Li }; break;
                            case "RectAreaLight":
                                t = { color: new Li, position: new Xt, halfWidth: new Xt, halfHeight: new Xt } } return i[e.id] = t } } } var ja = 0;

            function Wa() { var _ = new Va,
                    x = { id: ja++, hash: { stateID: -1, directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, shadowsLength: -1 }, ambient: [0, 0, 0], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] },
                    T = new Xt,
                    w = new jt,
                    S = new jt; return { setup: function(e, t, i) { for (var n = 0, r = 0, a = 0, o = 0, s = 0, l = 0, c = 0, h = 0, u = i.matrixWorldInverse, d = 0, p = e.length; d < p; d++) { var f = e[d],
                                m = f.color,
                                g = f.intensity,
                                v = f.distance,
                                M = f.shadow && f.shadow.map ? f.shadow.map.texture : null; if (f.isAmbientLight) n += m.r * g, r += m.g * g, a += m.b * g;
                            else if (f.isDirectionalLight) { if ((b = _.get(f)).color.copy(f.color).multiplyScalar(f.intensity), b.direction.setFromMatrixPosition(f.matrixWorld), T.setFromMatrixPosition(f.target.matrixWorld), b.direction.sub(T), b.direction.transformDirection(u), b.shadow = f.castShadow, f.castShadow) { var y = f.shadow;
                                    b.shadowBias = y.bias, b.shadowRadius = y.radius, b.shadowMapSize = y.mapSize }
                                x.directionalShadowMap[o] = M, x.directionalShadowMatrix[o] = f.shadow.matrix, x.directional[o] = b, o++ } else if (f.isSpotLight)(b = _.get(f)).position.setFromMatrixPosition(f.matrixWorld), b.position.applyMatrix4(u), b.color.copy(m).multiplyScalar(g), b.distance = v, b.direction.setFromMatrixPosition(f.matrixWorld), T.setFromMatrixPosition(f.target.matrixWorld), b.direction.sub(T), b.direction.transformDirection(u), b.coneCos = Math.cos(f.angle), b.penumbraCos = Math.cos(f.angle * (1 - f.penumbra)), b.decay = f.decay, b.shadow = f.castShadow, f.castShadow && (y = f.shadow, b.shadowBias = y.bias, b.shadowRadius = y.radius, b.shadowMapSize = y.mapSize), x.spotShadowMap[l] = M, x.spotShadowMatrix[l] = f.shadow.matrix, x.spot[l] = b, l++;
                            else if (f.isRectAreaLight)(b = _.get(f)).color.copy(m).multiplyScalar(g), b.position.setFromMatrixPosition(f.matrixWorld), b.position.applyMatrix4(u), S.identity(), w.copy(f.matrixWorld), w.premultiply(u), S.extractRotation(w), b.halfWidth.set(.5 * f.width, 0, 0), b.halfHeight.set(0, .5 * f.height, 0), b.halfWidth.applyMatrix4(S), b.halfHeight.applyMatrix4(S), x.rectArea[c] = b, c++;
                            else if (f.isPointLight)(b = _.get(f)).position.setFromMatrixPosition(f.matrixWorld), b.position.applyMatrix4(u), b.color.copy(f.color).multiplyScalar(f.intensity), b.distance = f.distance, b.decay = f.decay, b.shadow = f.castShadow, f.castShadow && (y = f.shadow, b.shadowBias = y.bias, b.shadowRadius = y.radius, b.shadowMapSize = y.mapSize, b.shadowCameraNear = y.camera.near, b.shadowCameraFar = y.camera.far), x.pointShadowMap[s] = M, x.pointShadowMatrix[s] = f.shadow.matrix, x.point[s] = b, s++;
                            else if (f.isHemisphereLight) { var b;
                                (b = _.get(f)).direction.setFromMatrixPosition(f.matrixWorld), b.direction.transformDirection(u), b.direction.normalize(), b.skyColor.copy(f.color).multiplyScalar(g), b.groundColor.copy(f.groundColor).multiplyScalar(g), x.hemi[h] = b, h++ } }
                        x.ambient[0] = n, x.ambient[1] = r, x.ambient[2] = a, x.directional.length = o, x.spot.length = l, x.rectArea.length = c, x.point.length = s, x.hemi.length = h, x.hash.stateID = x.id, x.hash.directionalLength = o, x.hash.pointLength = s, x.hash.spotLength = l, x.hash.rectAreaLength = c, x.hash.hemiLength = h, x.hash.shadowsLength = t.length }, state: x } }

            function Xa() { var t = new Wa,
                    i = [],
                    n = []; return { init: function() { i.length = 0, n.length = 0 }, state: { lightsArray: i, shadowsArray: n, lights: t }, setupLights: function(e) { t.setup(i, n, e) }, pushLight: function(e) { i.push(e) }, pushShadow: function(e) { n.push(e) } } }

            function Ya() { var n = {};

                function r(e) { var t = e.target;
                    t.removeEventListener("dispose", r), delete n[t.id] } return { get: function(e, t) { var i; return void 0 === n[e.id] ? (i = new Xa, n[e.id] = {}, n[e.id][t.id] = i, e.addEventListener("dispose", r)) : void 0 === n[e.id][t.id] ? (i = new Xa, n[e.id][t.id] = i) : i = n[e.id][t.id], i }, dispose: function() { n = {} } } }

            function qa(e) { Wn.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Nt, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(e) }

            function Za(e) { Wn.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new Xt, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(e) }

            function Ja(y, m, e) { for (var b = new _i, _ = new jt, x = new Vt, T = new Vt(e, e), w = new Xt, S = new Xt, v = 1, M = 2, t = 1 + (v | M), E = new Array(t), P = new Array(t), A = {}, C = { 0: xe, 1: D, 2: ee }, L = [new Xt(1, 0, 0), new Xt(-1, 0, 0), new Xt(0, 0, 1), new Xt(0, 0, -1), new Xt(0, 1, 0), new Xt(0, -1, 0)], R = [new Xt(0, 1, 0), new Xt(0, 1, 0), new Xt(0, 1, 0), new Xt(0, 1, 0), new Xt(0, 0, 1), new Xt(0, 0, -1)], H = [new pi, new pi, new pi, new pi, new pi, new pi], i = 0; i !== t; ++i) { var n = 0 != (i & v),
                        r = 0 != (i & M),
                        a = new qa({ depthPacking: Ft, morphTargets: n, skinning: r });
                    E[i] = a; var o = new Za({ morphTargets: n, skinning: r });
                    P[i] = o } var O = this;

                function g(e, t, i, n, r, a) { var o = e.geometry,
                        s = null,
                        l = E,
                        c = e.customDepthMaterial; if (i && (l = P, c = e.customDistanceMaterial), c) s = c;
                    else { var h = !1;
                        t.morphTargets && (o && o.isBufferGeometry ? h = o.morphAttributes && o.morphAttributes.position && 0 < o.morphAttributes.position.length : o && o.isGeometry && (h = o.morphTargets && 0 < o.morphTargets.length)), e.isSkinnedMesh && !1 === t.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e); var u = e.isSkinnedMesh && t.skinning,
                            d = 0;
                        h && (d |= v), u && (d |= M), s = l[d] } if (y.localClippingEnabled && !0 === t.clipShadows && 0 !== t.clippingPlanes.length) { var p = s.uuid,
                            f = t.uuid,
                            m = A[p];
                        void 0 === m && (m = {}, A[p] = m); var g = m[f];
                        void 0 === g && (g = s.clone(), m[f] = g), s = g } return s.visible = t.visible, s.wireframe = t.wireframe, s.side = null != t.shadowSide ? t.shadowSide : C[t.side], s.clipShadows = t.clipShadows, s.clippingPlanes = t.clippingPlanes, s.clipIntersection = t.clipIntersection, s.wireframeLinewidth = t.wireframeLinewidth, s.linewidth = t.linewidth, i && s.isMeshDistanceMaterial && (s.referencePosition.copy(n), s.nearDistance = r, s.farDistance = a), s }

                function G(e, t, i, n) { if (!1 !== e.visible) { if (e.layers.test(t.layers) && (e.isMesh || e.isLine || e.isPoints) && e.castShadow && (!e.frustumCulled || b.intersectsObject(e))) { e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld); var r = m.update(e),
                                a = e.material; if (Array.isArray(a))
                                for (var o = r.groups, s = 0, l = o.length; s < l; s++) { var c = o[s],
                                        h = a[c.materialIndex]; if (h && h.visible) { var u = g(e, h, n, S, i.near, i.far);
                                        y.renderBufferDirect(i, null, r, u, e, c) } } else if (a.visible) { u = g(e, a, n, S, i.near, i.far);
                                    y.renderBufferDirect(i, null, r, u, e, null) } } for (var d = e.children, p = 0, f = d.length; p < f; p++) G(d[p], t, i, n) } }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = F, this.render = function(e, t, i) { if (!1 !== O.enabled && (!1 !== O.autoUpdate || !1 !== O.needsUpdate) && 0 !== e.length) { var n, r = y.getRenderTarget(),
                            a = y.state;
                        a.setBlending(Z), a.buffers.color.setClear(1, 1, 1, 1), a.buffers.depth.setTest(!0), a.setScissorTest(!1); for (var o = 0, s = e.length; o < s; o++) { var l = e[o],
                                c = l.shadow,
                                h = l && l.isPointLight; if (void 0 !== c) { var u = c.camera; if (x.copy(c.mapSize), x.min(T), h) { var d = x.x,
                                        p = x.y;
                                    H[0].set(2 * d, p, d, p), H[1].set(0, p, d, p), H[2].set(3 * d, p, d, p), H[3].set(d, p, d, p), H[4].set(3 * d, 0, d, p), H[5].set(d, 0, d, p), x.x *= 4, x.y *= 2 } if (null === c.map) { var f = { minFilter: Ce, magFilter: Ce, format: Ze };
                                    c.map = new fi(x.x, x.y, f), c.map.texture.name = l.name + ".shadowMap", u.updateProjectionMatrix() }
                                c.isSpotLightShadow && c.update(l); var m = c.map,
                                    g = c.matrix;
                                S.setFromMatrixPosition(l.matrixWorld), u.position.copy(S), h ? (n = 6, g.makeTranslation(-S.x, -S.y, -S.z)) : (n = 1, w.setFromMatrixPosition(l.target.matrixWorld), u.lookAt(w), u.updateMatrixWorld(), g.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), g.multiply(u.projectionMatrix), g.multiply(u.matrixWorldInverse)), y.setRenderTarget(m), y.clear(); for (var v = 0; v < n; v++) { if (h) { w.copy(u.position), w.add(L[v]), u.up.copy(R[v]), u.lookAt(w), u.updateMatrixWorld(); var M = H[v];
                                        a.viewport(M) }
                                    _.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse), b.setFromMatrix(_), G(t, i, u, h) } } else console.warn("THREE.WebGLShadowMap:", l, "has no shadow.") }
                        O.needsUpdate = !1, y.setRenderTarget(r) } } }

            function Ka(h, i, l, n) { var r = new function() { var t = !1,
                            a = new pi,
                            i = null,
                            o = new pi(0, 0, 0, 0); return { setMask: function(e) { i === e || t || (h.colorMask(e, e, e, e), i = e) }, setLocked: function(e) { t = e }, setClear: function(e, t, i, n, r) {!0 === r && (e *= n, t *= n, i *= n), a.set(e, t, i, n), !1 === o.equals(a) && (h.clearColor(e, t, i, n), o.copy(a)) }, reset: function() { t = !1, i = null, o.set(-1, 0, 0, 0) } } },
                    a = new function() { var t = !1,
                            i = null,
                            n = null,
                            r = null; return { setTest: function(e) { e ? F(2929) : z(2929) }, setMask: function(e) { i === e || t || (h.depthMask(e), i = e) }, setFunc: function(e) { if (n !== e) { if (e) switch (e) {
                                        case ne:
                                            h.depthFunc(512); break;
                                        case re:
                                            h.depthFunc(519); break;
                                        case ae:
                                            h.depthFunc(513); break;
                                        case oe:
                                            h.depthFunc(515); break;
                                        case se:
                                            h.depthFunc(514); break;
                                        case le:
                                            h.depthFunc(518); break;
                                        case ce:
                                            h.depthFunc(516); break;
                                        case he:
                                            h.depthFunc(517); break;
                                        default:
                                            h.depthFunc(515) } else h.depthFunc(515);
                                    n = e } }, setLocked: function(e) { t = e }, setClear: function(e) { r !== e && (h.clearDepth(e), r = e) }, reset: function() { t = !1, r = n = i = null } } },
                    t = new function() { var t = !1,
                            i = null,
                            n = null,
                            r = null,
                            a = null,
                            o = null,
                            s = null,
                            l = null,
                            c = null; return { setTest: function(e) { e ? F(2960) : z(2960) }, setMask: function(e) { i === e || t || (h.stencilMask(e), i = e) }, setFunc: function(e, t, i) { n === e && r === t && a === i || (h.stencilFunc(e, t, i), n = e, r = t, a = i) }, setOp: function(e, t, i) { o === e && s === t && l === i || (h.stencilOp(e, t, i), o = e, s = t, l = i) }, setLocked: function(e) { t = e }, setClear: function(e) { c !== e && (h.clearStencil(e), c = e) }, reset: function() { t = !1, c = l = s = o = a = r = n = i = null } } },
                    e = h.getParameter(34921),
                    o = new Uint8Array(e),
                    s = new Uint8Array(e),
                    c = new Uint8Array(e),
                    u = {},
                    d = null,
                    p = null,
                    f = null,
                    m = null,
                    g = null,
                    v = null,
                    M = null,
                    y = null,
                    b = null,
                    _ = null,
                    x = !1,
                    T = null,
                    w = null,
                    S = null,
                    E = null,
                    P = null,
                    A = h.getParameter(35661),
                    C = !1,
                    L = 0,
                    R = h.getParameter(7938); - 1 !== R.indexOf("WebGL") ? (L = parseFloat(/^WebGL\ ([0-9])/.exec(R)[1]), C = 1 <= L) : -1 !== R.indexOf("OpenGL ES") && (L = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(R)[1]), C = 2 <= L); var H = null,
                    O = {},
                    G = new pi,
                    D = new pi;

                function I(e, t, i) { var n = new Uint8Array(4),
                        r = h.createTexture();
                    h.bindTexture(e, r), h.texParameteri(e, 10241, 9728), h.texParameteri(e, 10240, 9728); for (var a = 0; a < i; a++) h.texImage2D(t + a, 0, 6408, 1, 1, 0, 6408, 5121, n); return r } var B = {};

                function N(e, t) {
                    (o[e] = 1, 0 === s[e] && (h.enableVertexAttribArray(e), s[e] = 1), c[e] !== t) && ((n.isWebGL2 ? h : i.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, t), c[e] = t) }

                function F(e) {!0 !== u[e] && (h.enable(e), u[e] = !0) }

                function z(e) {!1 !== u[e] && (h.disable(e), u[e] = !1) }

                function k(e, t, i, n, r, a, o, s) { if (e !== Z) { if (f || (F(3042), f = !0), e === te) r = r || t, a = a || i, o = o || n, t === g && r === y || (h.blendEquationSeparate(l.convert(t), l.convert(r)), g = t, y = r), i === v && n === M && a === b && o === _ || (h.blendFuncSeparate(l.convert(i), l.convert(n), l.convert(a), l.convert(o)), v = i, M = n, b = a, _ = o), m = e, x = null;
                        else if (e !== m || s !== x) { if (g === ie && y === ie || (h.blendEquation(32774), y = g = ie), s) switch (e) {
                                case J:
                                    h.blendFuncSeparate(1, 771, 1, 771); break;
                                case K:
                                    h.blendFunc(1, 1); break;
                                case Q:
                                    h.blendFuncSeparate(0, 0, 769, 771); break;
                                case $:
                                    h.blendFuncSeparate(0, 768, 0, 770); break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) {
                                case J:
                                    h.blendFuncSeparate(770, 771, 1, 771); break;
                                case K:
                                    h.blendFunc(770, 1); break;
                                case Q:
                                    h.blendFunc(0, 769); break;
                                case $:
                                    h.blendFunc(0, 768); break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e) }
                            _ = b = M = v = null, m = e, x = s } } else f && (z(3042), f = !1) }

                function U(e) { T !== e && (e ? h.frontFace(2304) : h.frontFace(2305), T = e) }

                function V(e) { e !== X ? (F(2884), e !== w && (e === Y ? h.cullFace(1029) : e === q ? h.cullFace(1028) : h.cullFace(1032))) : z(2884), w = e }

                function j(e, t, i) { e ? (F(32823), E === t && P === i || (h.polygonOffset(t, i), E = t, P = i)) : z(32823) }

                function W(e) { void 0 === e && (e = 33984 + A - 1), H !== e && (h.activeTexture(e), H = e) } return B[3553] = I(3553, 3553, 1), B[34067] = I(34067, 34069, 6), r.setClear(0, 0, 0, 1), a.setClear(1), t.setClear(0), F(2929), a.setFunc(oe), U(!1), V(Y), F(2884), k(Z), { buffers: { color: r, depth: a, stencil: t }, initAttributes: function() { for (var e = 0, t = o.length; e < t; e++) o[e] = 0 }, enableAttribute: function(e) { N(e, 0) }, enableAttributeAndDivisor: N, disableUnusedAttributes: function() { for (var e = 0, t = s.length; e !== t; ++e) s[e] !== o[e] && (h.disableVertexAttribArray(e), s[e] = 0) }, enable: F, disable: z, getCompressedTextureFormats: function() { if (null === d && (d = [], i.get("WEBGL_compressed_texture_pvrtc") || i.get("WEBGL_compressed_texture_s3tc") || i.get("WEBGL_compressed_texture_etc1") || i.get("WEBGL_compressed_texture_astc")))
                            for (var e = h.getParameter(34467), t = 0; t < e.length; t++) d.push(e[t]); return d }, useProgram: function(e) { return p !== e && (h.useProgram(e), p = e, !0) }, setBlending: k, setMaterial: function(e, t) { e.side === ee ? z(2884) : F(2884); var i = e.side === xe;
                        t && (i = !i), U(i), e.blending === J && !1 === e.transparent ? k(Z) : k(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), a.setFunc(e.depthFunc), a.setTest(e.depthTest), a.setMask(e.depthWrite), r.setMask(e.colorWrite), j(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits) }, setFlipSided: U, setCullFace: V, setLineWidth: function(e) { e !== S && (C && h.lineWidth(e), S = e) }, setPolygonOffset: j, setScissorTest: function(e) { e ? F(3089) : z(3089) }, activeTexture: W, bindTexture: function(e, t) { null === H && W(); var i = O[H];
                        void 0 === i && (i = { type: void 0, texture: void 0 }, O[H] = i), i.type === e && i.texture === t || (h.bindTexture(e, t || B[e]), i.type = e, i.texture = t) }, compressedTexImage2D: function() { try { h.compressedTexImage2D.apply(h, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage2D: function() { try { h.texImage2D.apply(h, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, texImage3D: function() { try { h.texImage3D.apply(h, arguments) } catch (e) { console.error("THREE.WebGLState:", e) } }, scissor: function(e) {!1 === G.equals(e) && (h.scissor(e.x, e.y, e.z, e.w), G.copy(e)) }, viewport: function(e) {!1 === D.equals(e) && (h.viewport(e.x, e.y, e.z, e.w), D.copy(e)) }, reset: function() { for (var e = 0; e < s.length; e++) 1 === s[e] && (h.disableVertexAttribArray(e), s[e] = 0);
                        u = {}, O = {}, w = T = m = p = H = d = null, r.reset(), a.reset(), t.reset() } } }

            function Qa(g, r, v, M, y, b, c) { var h, s = {},
                    u = "undefined" != typeof OffscreenCanvas;

                function d(e, t) { return u ? new OffscreenCanvas(e, t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") }

                function _(e, t, i, n) { var r = 1; if ((e.width > n || e.height > n) && (r = n / Math.max(e.width, e.height)), r < 1 || !0 === t) { if (e instanceof ImageBitmap || e instanceof HTMLImageElement || e instanceof HTMLCanvasElement) { var a = t ? Ut.floorPowerOfTwo : Math.floor,
                                o = a(r * e.width),
                                s = a(r * e.height);
                            void 0 === h && (h = d(o, s)); var l = i ? d(o, s) : h; return l.width = o, l.height = s, l.getContext("2d").drawImage(e, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + s + ")."), u ? l.transferToImageBitmap() : l } return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e } return e }

                function x(e) { return Ut.isPowerOfTwo(e.width) && Ut.isPowerOfTwo(e.height) }

                function T(e, t) { return e.generateMipmaps && t && e.minFilter !== Ce && e.minFilter !== He }

                function w(e, t, i, n) { g.generateMipmap(e), M.get(t).__maxMipLevel = Math.log(Math.max(i, n)) * Math.LOG2E }

                function S(e, t) { if (!y.isWebGL2) return e; var i = e; return 6403 === e && (5126 === t && (i = 33326), 5131 === t && (i = 33325), 5121 === t && (i = 33321)), 6407 === e && (5126 === t && (i = 34837), 5131 === t && (i = 34843), 5121 === t && (i = 32849)), 6408 === e && (5126 === t && (i = 34836), 5131 === t && (i = 34842), 5121 === t && (i = 32856)), 33325 === i || 33326 === i || 34842 === i || 34836 === i ? r.get("EXT_color_buffer_float") : 34843 !== i && 34837 !== i || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), i }

                function a(e) { return e === Ce || e === Le || e === Re ? 9728 : 9729 }

                function i(e) { var t = e.target;
                    t.removeEventListener("dispose", i),
                        function(e) { var t = M.get(e); if (void 0 === t.__webglInit) return;
                            g.deleteTexture(t.__webglTexture), M.remove(e) }(t), t.isVideoTexture && delete s[t.id], c.memory.textures-- }

                function p(e) { var t = e.target;
                    t.removeEventListener("dispose", p),
                        function(e) { var t = M.get(e),
                                i = M.get(e.texture); if (!e) return;
                            void 0 !== i.__webglTexture && g.deleteTexture(i.__webglTexture);
                            e.depthTexture && e.depthTexture.dispose(); if (e.isWebGLRenderTargetCube)
                                for (var n = 0; n < 6; n++) g.deleteFramebuffer(t.__webglFramebuffer[n]), t.__webglDepthbuffer && g.deleteRenderbuffer(t.__webglDepthbuffer[n]);
                            else g.deleteFramebuffer(t.__webglFramebuffer), t.__webglDepthbuffer && g.deleteRenderbuffer(t.__webglDepthbuffer);
                            M.remove(e.texture), M.remove(e) }(t), c.memory.textures-- }

                function o(e, t) { var i, n, r, a = M.get(e); if (e.isVideoTexture && (n = (i = e).id, r = c.render.frame, s[n] !== r && (s[n] = r, i.update())), 0 < e.version && a.__version !== e.version) { var o = e.image; if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else { if (!1 !== o.complete) return void l(a, e, t);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } }
                    v.activeTexture(33984 + t), v.bindTexture(3553, a.__webglTexture) }

                function E(e, t, i) { var n; if (i ? (g.texParameteri(e, 10242, b.convert(t.wrapS)), g.texParameteri(e, 10243, b.convert(t.wrapT)), 32879 === e && g.texParameteri(e, 32882, b.convert(t.wrapR)), g.texParameteri(e, 10240, b.convert(t.magFilter)), g.texParameteri(e, 10241, b.convert(t.minFilter))) : (g.texParameteri(e, 10242, 33071), g.texParameteri(e, 10243, 33071), 32879 === e && g.texParameteri(e, 32882, 33071), t.wrapS === Pe && t.wrapT === Pe || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), g.texParameteri(e, 10240, a(t.magFilter)), g.texParameteri(e, 10241, a(t.minFilter)), t.minFilter !== Ce && t.minFilter !== He && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), n = r.get("EXT_texture_filter_anisotropic")) { if (t.type === ke && null === r.get("OES_texture_float_linear")) return; if (t.type === Ue && null === (y.isWebGL2 || r.get("OES_texture_half_float_linear"))) return;
                        (1 < t.anisotropy || M.get(t).__currentAnisotropy) && (g.texParameterf(e, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, y.getMaxAnisotropy())), M.get(t).__currentAnisotropy = t.anisotropy) } }

                function P(e, t) { void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", i), e.__webglTexture = g.createTexture(), c.memory.textures++) }

                function l(e, t, i) { var n = t.isDataTexture3D ? 32879 : 3553;
                    P(e, t), v.activeTexture(33984 + i), v.bindTexture(n, e.__webglTexture), g.pixelStorei(37440, t.flipY), g.pixelStorei(37441, t.premultiplyAlpha), g.pixelStorei(3317, t.unpackAlignment); var r, a = (r = t, !y.isWebGL2 && (r.wrapS !== Pe || r.wrapT !== Pe || r.minFilter !== Ce && r.minFilter !== He) && !1 === x(t.image)),
                        o = _(t.image, a, !1, y.maxTextureSize),
                        s = x(o) || y.isWebGL2,
                        l = b.convert(t.format),
                        c = b.convert(t.type),
                        h = S(l, c);
                    E(n, t, s); var u, d = t.mipmaps; if (t.isDepthTexture) { if (h = 6402, t.type === ke) { if (!y.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            h = 36012 } else y.isWebGL2 && (h = 33189);
                        t.format === $e && 6402 === h && t.type !== Ne && t.type !== ze && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), t.type = Ne, c = b.convert(t.type)), t.format === et && (h = 34041, t.type !== Xe && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), t.type = Xe, c = b.convert(t.type))), v.texImage2D(3553, 0, h, o.width, o.height, 0, l, c, null) } else if (t.isDataTexture)
                        if (0 < d.length && s) { for (var p = 0, f = d.length; p < f; p++) u = d[p], v.texImage2D(3553, p, h, u.width, u.height, 0, l, c, u.data);
                            t.generateMipmaps = !1, e.__maxMipLevel = d.length - 1 } else v.texImage2D(3553, 0, h, o.width, o.height, 0, l, c, o.data), e.__maxMipLevel = 0;
                    else if (t.isCompressedTexture) { for (p = 0, f = d.length; p < f; p++) u = d[p], t.format !== Ze && t.format !== qe ? -1 < v.getCompressedTextureFormats().indexOf(l) ? v.compressedTexImage2D(3553, p, h, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : v.texImage2D(3553, p, h, u.width, u.height, 0, l, c, u.data);
                        e.__maxMipLevel = d.length - 1 } else if (t.isDataTexture3D) v.texImage3D(32879, 0, h, o.width, o.height, o.depth, 0, l, c, o.data), e.__maxMipLevel = 0;
                    else if (0 < d.length && s) { for (p = 0, f = d.length; p < f; p++) u = d[p], v.texImage2D(3553, p, h, l, c, u);
                        t.generateMipmaps = !1, e.__maxMipLevel = d.length - 1 } else v.texImage2D(3553, 0, h, l, c, o), e.__maxMipLevel = 0;
                    T(t, s) && w(3553, t, o.width, o.height), e.__version = t.version, t.onUpdate && t.onUpdate(t) }

                function f(e, t, i, n) { var r = b.convert(t.texture.format),
                        a = b.convert(t.texture.type),
                        o = S(r, a);
                    v.texImage2D(n, 0, o, t.width, t.height, 0, r, a, null), g.bindFramebuffer(36160, e), g.framebufferTexture2D(36160, i, n, M.get(t.texture).__webglTexture, 0), g.bindFramebuffer(36160, null) }

                function m(e, t, i) { if (g.bindRenderbuffer(36161, e), t.depthBuffer && !t.stencilBuffer) { if (i) { var n = C(t);
                            g.renderbufferStorageMultisample(36161, n, 33189, t.width, t.height) } else g.renderbufferStorage(36161, 33189, t.width, t.height);
                        g.framebufferRenderbuffer(36160, 36096, 36161, e) } else if (t.depthBuffer && t.stencilBuffer) { if (i) { n = C(t);
                            g.renderbufferStorageMultisample(36161, n, 34041, t.width, t.height) } else g.renderbufferStorage(36161, 34041, t.width, t.height);
                        g.framebufferRenderbuffer(36160, 33306, 36161, e) } else { var r = S(b.convert(t.texture.format), b.convert(t.texture.type)); if (i) { n = C(t);
                            g.renderbufferStorageMultisample(36161, n, r, t.width, t.height) } else g.renderbufferStorage(36161, r, t.width, t.height) }
                    g.bindRenderbuffer(36161, null) }

                function A(e) { var t = M.get(e),
                        i = !0 === e.isWebGLRenderTargetCube; if (e.depthTexture) { if (i) throw new Error("target.depthTexture not supported in Cube render targets");! function(e, t) { if (t && t.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported"); if (g.bindFramebuffer(36160, e), !t.depthTexture || !t.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            M.get(t.depthTexture).__webglTexture && t.depthTexture.image.width === t.width && t.depthTexture.image.height === t.height || (t.depthTexture.image.width = t.width, t.depthTexture.image.height = t.height, t.depthTexture.needsUpdate = !0), o(t.depthTexture, 0); var i = M.get(t.depthTexture).__webglTexture; if (t.depthTexture.format === $e) g.framebufferTexture2D(36160, 36096, 3553, i, 0);
                            else { if (t.depthTexture.format !== et) throw new Error("Unknown depthTexture format");
                                g.framebufferTexture2D(36160, 33306, 3553, i, 0) } }(t.__webglFramebuffer, e) } else if (i) { t.__webglDepthbuffer = []; for (var n = 0; n < 6; n++) g.bindFramebuffer(36160, t.__webglFramebuffer[n]), t.__webglDepthbuffer[n] = g.createRenderbuffer(), m(t.__webglDepthbuffer[n], e) } else g.bindFramebuffer(36160, t.__webglFramebuffer), t.__webglDepthbuffer = g.createRenderbuffer(), m(t.__webglDepthbuffer, e);
                    g.bindFramebuffer(36160, null) }

                function C(e) { return y.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(y.maxSamples, e.samples) : 0 }
                this.setTexture2D = o, this.setTexture3D = function(e, t) { var i = M.get(e);
                    0 < e.version && i.__version !== e.version ? l(i, e, t) : (v.activeTexture(33984 + t), v.bindTexture(32879, i.__webglTexture)) }, this.setTextureCube = function(e, t) { var i = M.get(e); if (6 === e.image.length)
                        if (0 < e.version && i.__version !== e.version) { P(i, e), v.activeTexture(33984 + t), v.bindTexture(34067, i.__webglTexture), g.pixelStorei(37440, e.flipY); for (var n = e && e.isCompressedTexture, r = e.image[0] && e.image[0].isDataTexture, a = [], o = 0; o < 6; o++) a[o] = n || r ? r ? e.image[o].image : e.image[o] : _(e.image[o], !1, !0, y.maxCubemapSize); var s = a[0],
                                l = x(s) || y.isWebGL2,
                                c = b.convert(e.format),
                                h = b.convert(e.type),
                                u = S(c, h); for (E(34067, e, l), o = 0; o < 6; o++)
                                if (n)
                                    for (var d, p = a[o].mipmaps, f = 0, m = p.length; f < m; f++) d = p[f], e.format !== Ze && e.format !== qe ? -1 < v.getCompressedTextureFormats().indexOf(c) ? v.compressedTexImage2D(34069 + o, f, u, d.width, d.height, 0, d.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : v.texImage2D(34069 + o, f, u, d.width, d.height, 0, c, h, d.data);
                                else r ? v.texImage2D(34069 + o, 0, u, a[o].width, a[o].height, 0, c, h, a[o].data) : v.texImage2D(34069 + o, 0, u, c, h, a[o]);
                            i.__maxMipLevel = n ? p.length - 1 : 0, T(e, l) && w(34067, e, s.width, s.height), i.__version = e.version, e.onUpdate && e.onUpdate(e) } else v.activeTexture(33984 + t), v.bindTexture(34067, i.__webglTexture) }, this.setTextureCubeDynamic = function(e, t) { v.activeTexture(33984 + t), v.bindTexture(34067, M.get(e).__webglTexture) }, this.setupRenderTarget = function(e) { var t = M.get(e),
                        i = M.get(e.texture);
                    e.addEventListener("dispose", p), i.__webglTexture = g.createTexture(), c.memory.textures++; var n = !0 === e.isWebGLRenderTargetCube,
                        r = !0 === e.isWebGLMultisampleRenderTarget,
                        a = x(e) || y.isWebGL2; if (n) { t.__webglFramebuffer = []; for (var o = 0; o < 6; o++) t.__webglFramebuffer[o] = g.createFramebuffer() } else if (t.__webglFramebuffer = g.createFramebuffer(), r)
                        if (y.isWebGL2) { t.__webglMultisampledFramebuffer = g.createFramebuffer(), t.__webglColorRenderbuffer = g.createRenderbuffer(), g.bindRenderbuffer(36161, t.__webglColorRenderbuffer); var s = S(b.convert(e.texture.format), b.convert(e.texture.type)),
                                l = C(e);
                            g.renderbufferStorageMultisample(36161, l, s, e.width, e.height), g.bindFramebuffer(36160, t.__webglMultisampledFramebuffer), g.framebufferRenderbuffer(36160, 36064, 36161, t.__webglColorRenderbuffer), g.bindRenderbuffer(36161, null), e.depthBuffer && (t.__webglDepthRenderbuffer = g.createRenderbuffer(), m(t.__webglDepthRenderbuffer, e, !0)), g.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (n) { for (v.bindTexture(34067, i.__webglTexture), E(34067, e.texture, a), o = 0; o < 6; o++) f(t.__webglFramebuffer[o], e, 36064, 34069 + o);
                        T(e.texture, a) && w(34067, e.texture, e.width, e.height), v.bindTexture(34067, null) } else v.bindTexture(3553, i.__webglTexture), E(3553, e.texture, a), f(t.__webglFramebuffer, e, 36064, 3553), T(e.texture, a) && w(3553, e.texture, e.width, e.height), v.bindTexture(3553, null);
                    e.depthBuffer && A(e) }, this.updateRenderTargetMipmap = function(e) { var t = e.texture; if (T(t, x(e) || y.isWebGL2)) { var i = e.isWebGLRenderTargetCube ? 34067 : 3553,
                            n = M.get(t).__webglTexture;
                        v.bindTexture(i, n), w(i, t, e.width, e.height), v.bindTexture(i, null) } }, this.updateMultisampleRenderTarget = function(e) { if (e.isWebGLMultisampleRenderTarget)
                        if (y.isWebGL2) { var t = M.get(e);
                            g.bindFramebuffer(36008, t.__webglMultisampledFramebuffer), g.bindFramebuffer(36009, t.__webglFramebuffer); var i = e.width,
                                n = e.height,
                                r = 16384;
                            e.depthBuffer && (r |= 256), e.stencilBuffer && (r |= 1024), g.blitFramebuffer(0, 0, i, n, 0, 0, i, n, r, 9728) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") } }

            function $a(e, i, n) { return { convert: function(e) { var t; if (e === Ee) return 10497; if (e === Pe) return 33071; if (e === Ae) return 33648; if (e === Ce) return 9728; if (e === Le) return 9984; if (e === Re) return 9986; if (e === He) return 9729; if (e === Oe) return 9985; if (e === Ge) return 9987; if (e === De) return 5121; if (e === Ve) return 32819; if (e === je) return 32820; if (e === We) return 33635; if (e === Ie) return 5120; if (e === Be) return 5122; if (e === Ne) return 5123; if (e === Fe) return 5124; if (e === ze) return 5125; if (e === ke) return 5126; if (e === Ue) { if (n.isWebGL2) return 5131; if (null !== (t = i.get("OES_texture_half_float"))) return t.HALF_FLOAT_OES } if (e === Ye) return 6406; if (e === qe) return 6407; if (e === Ze) return 6408; if (e === Je) return 6409; if (e === Ke) return 6410; if (e === $e) return 6402; if (e === et) return 34041; if (e === tt) return 6403; if (e === ie) return 32774; if (e === E) return 32778; if (e === P) return 32779; if (e === L) return 0; if (e === R) return 1; if (e === H) return 768; if (e === O) return 769; if (e === G) return 770; if (e === I) return 771; if (e === B) return 772; if (e === N) return 773; if (e === k) return 774; if (e === U) return 775; if (e === V) return 776; if ((e === it || e === nt || e === rt || e === at) && null !== (t = i.get("WEBGL_compressed_texture_s3tc"))) { if (e === it) return t.COMPRESSED_RGB_S3TC_DXT1_EXT; if (e === nt) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (e === rt) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (e === at) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT } if ((e === ot || e === st || e === lt || e === ct) && null !== (t = i.get("WEBGL_compressed_texture_pvrtc"))) { if (e === ot) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (e === st) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (e === lt) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (e === ct) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (e === ht && null !== (t = i.get("WEBGL_compressed_texture_etc1"))) return t.COMPRESSED_RGB_ETC1_WEBGL; if ((e === ut || e === dt || e === pt || e === ft || e === mt || e === gt || e === vt || e === Mt || e === yt || e === bt || e === _t || e === xt || e === Tt || e === wt) && null !== (t = i.get("WEBGL_compressed_texture_astc"))) return e; if (e === A || e === C) { if (n.isWebGL2) { if (e === A) return 32775; if (e === C) return 32776 } if (null !== (t = i.get("EXT_blend_minmax"))) { if (e === A) return t.MIN_EXT; if (e === C) return t.MAX_EXT } } if (e === Xe) { if (n.isWebGL2) return 34042; if (null !== (t = i.get("WEBGL_depth_texture"))) return t.UNSIGNED_INT_24_8_WEBGL } return 0 } } }

            function eo() { on.call(this), this.type = "Group" }

            function to() { on.call(this), this.type = "Camera", this.matrixWorldInverse = new jt, this.projectionMatrix = new jt, this.projectionMatrixInverse = new jt }

            function io(e, t, i, n) { to.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== e ? e : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== t ? t : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() }

            function no(e) { io.call(this), this.cameras = e || [] }((qa.prototype = Object.create(Wn.prototype)).constructor = qa).prototype.isMeshDepthMaterial = !0, qa.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.depthPacking = e.depthPacking, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this }, ((Za.prototype = Object.create(Wn.prototype)).constructor = Za).prototype.isMeshDistanceMaterial = !0, Za.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.referencePosition.copy(e.referencePosition), this.nearDistance = e.nearDistance, this.farDistance = e.farDistance, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this }, eo.prototype = Object.assign(Object.create(on.prototype), { constructor: eo, isGroup: !0 }), to.prototype = Object.assign(Object.create(on.prototype), { constructor: to, isCamera: !0, copy: function(e, t) { return on.prototype.copy.call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this }, getWorldDirection: function(e) { void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), e = new Xt), this.updateMatrixWorld(!0); var t = this.matrixWorld.elements; return e.set(-t[8], -t[9], -t[10]).normalize() }, updateMatrixWorld: function(e) { on.prototype.updateMatrixWorld.call(this, e), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function() { return (new this.constructor).copy(this) } }), io.prototype = Object.assign(Object.create(to.prototype), { constructor: io, isPerspectiveCamera: !0, copy: function(e, t) { return to.prototype.copy.call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this }, setFocalLength: function(e) { var t = .5 * this.getFilmHeight() / e;
                    this.fov = 2 * Ut.RAD2DEG * Math.atan(t), this.updateProjectionMatrix() }, getFocalLength: function() { var e = Math.tan(.5 * Ut.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / e }, getEffectiveFOV: function() { return 2 * Ut.RAD2DEG * Math.atan(Math.tan(.5 * Ut.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function() { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function() { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function(e, t, i, n, r, a) { this.aspect = e / t, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function() { var e = this.near,
                        t = e * Math.tan(.5 * Ut.DEG2RAD * this.fov) / this.zoom,
                        i = 2 * t,
                        n = this.aspect * i,
                        r = -.5 * n,
                        a = this.view; if (null !== this.view && this.view.enabled) { var o = a.fullWidth,
                            s = a.fullHeight;
                        r += a.offsetX * n / o, t -= a.offsetY * i / s, n *= a.width / o, i *= a.height / s } var l = this.filmOffset;
                    0 !== l && (r += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, t, t - i, e, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function(e) { var t = on.prototype.toJSON.call(this, e); return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } }), no.prototype = Object.assign(Object.create(io.prototype), { constructor: no, isArrayCamera: !0 }); var ro, ao, oo, so, lo, co, ho, uo, po, fo, mo, go, vo, Mo, yo, bo, _o = new Xt,
                xo = new Xt;

            function To(e, t, i) { _o.setFromMatrixPosition(t.matrixWorld), xo.setFromMatrixPosition(i.matrixWorld); var n = _o.distanceTo(xo),
                    r = t.projectionMatrix.elements,
                    a = i.projectionMatrix.elements,
                    o = r[14] / (r[10] - 1),
                    s = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    h = (r[8] - 1) / r[0],
                    u = (a[8] + 1) / a[0],
                    d = o * h,
                    p = o * u,
                    f = n / (-h + u),
                    m = f * -h;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(f), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.getInverse(e.matrixWorld); var g = o + f,
                    v = s + f,
                    M = d - m,
                    y = p + (n - m),
                    b = l * s / v * g,
                    _ = c * s / v * g;
                e.projectionMatrix.makePerspective(M, y, b, _, g, v) }

            function wo(n) { var r = this,
                    l = null,
                    c = null,
                    h = null,
                    u = [],
                    d = new jt,
                    p = new jt,
                    a = 1,
                    f = "stage"; "undefined" != typeof window && "VRFrameData" in window && (c = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", e, !1)); var m = new jt,
                    g = new Wt,
                    v = new Xt,
                    M = new io;
                M.bounds = new pi(0, 0, .5, 1), M.layers.enable(1); var y = new io;
                y.bounds = new pi(.5, 0, .5, 1), y.layers.enable(2); var b = new no([M, y]);

                function _() { return null !== l && !0 === l.isPresenting }
                b.layers.enable(1), b.layers.enable(2); var o, s = new Vt;

                function e() { if (_()) { var e = l.getEyeParameters("left"),
                            t = e.renderWidth * a,
                            i = e.renderHeight * a;
                        o = n.getPixelRatio(), n.getSize(s), n.setDrawingBufferSize(2 * t, i, 1), w.start() } else r.enabled && n.setDrawingBufferSize(s.width, s.height, o), w.stop() } var x = [];

                function T(e) { for (var t = navigator.getGamepads && navigator.getGamepads(), i = 0, n = 0, r = t.length; i < r; i++) { var a = t[i]; if (a && ("Daydream Controller" === a.id || "Gear VR Controller" === a.id || "Oculus Go Controller" === a.id || "OpenVR Gamepad" === a.id || a.id.startsWith("Oculus Touch") || a.id.startsWith("Spatial Controller"))) { if (n === e) return a;
                            n++ } } }
                this.enabled = !1, this.getController = function(e) { var t = u[e]; return void 0 === t && ((t = new eo).matrixAutoUpdate = !1, t.visible = !1, u[e] = t), t }, this.getDevice = function() { return l }, this.setDevice = function(e) { void 0 !== e && (l = e), w.setContext(e) }, this.setFramebufferScaleFactor = function(e) { a = e }, this.setFrameOfReferenceType = function(e) { f = e }, this.setPoseTarget = function(e) { void 0 !== e && (h = e) }, this.getCamera = function(e) { var t = "stage" === f ? 1.6 : 0; if (!1 === _()) return e.position.set(0, t, 0), e.rotation.set(0, 0, 0), e; if (l.depthNear = e.near, l.depthFar = e.far, l.getFrameData(c), "stage" === f) { var i = l.stageParameters;
                        i ? d.fromArray(i.sittingToStandingTransform) : d.makeTranslation(0, t, 0) } var n = c.pose,
                        r = null !== h ? h : e;
                    r.matrix.copy(d), r.matrix.decompose(r.position, r.quaternion, r.scale), null !== n.orientation && (g.fromArray(n.orientation), r.quaternion.multiply(g)), null !== n.position && (g.setFromRotationMatrix(d), v.fromArray(n.position), v.applyQuaternion(g), r.position.add(v)), r.updateMatrixWorld(), M.near = e.near, y.near = e.near, M.far = e.far, y.far = e.far, M.matrixWorldInverse.fromArray(c.leftViewMatrix), y.matrixWorldInverse.fromArray(c.rightViewMatrix), p.getInverse(d), "stage" === f && (M.matrixWorldInverse.multiply(p), y.matrixWorldInverse.multiply(p)); var a = r.parent;
                    null !== a && (m.getInverse(a.matrixWorld), M.matrixWorldInverse.multiply(m), y.matrixWorldInverse.multiply(m)), M.matrixWorld.getInverse(M.matrixWorldInverse), y.matrixWorld.getInverse(y.matrixWorldInverse), M.projectionMatrix.fromArray(c.leftProjectionMatrix), y.projectionMatrix.fromArray(c.rightProjectionMatrix), To(b, M, y); var o = l.getLayers(); if (o.length) { var s = o[0];
                        null !== s.leftBounds && 4 === s.leftBounds.length && M.bounds.fromArray(s.leftBounds), null !== s.rightBounds && 4 === s.rightBounds.length && y.bounds.fromArray(s.rightBounds) } return function() { for (var e = 0; e < u.length; e++) { var t = u[e],
                                i = T(e); if (void 0 !== i && void 0 !== i.pose) { if (null === i.pose) return; var n = i.pose;!1 === n.hasPosition && t.position.set(.2, -.6, -.05), null !== n.position && t.position.fromArray(n.position), null !== n.orientation && t.quaternion.fromArray(n.orientation), t.matrix.compose(t.position, t.quaternion, t.scale), t.matrix.premultiply(d), t.matrix.decompose(t.position, t.quaternion, t.scale), t.matrixWorldNeedsUpdate = !0, t.visible = !0; var r = "Daydream Controller" === i.id ? 0 : 1;
                                x[e] !== i.buttons[r].pressed && (x[e] = i.buttons[r].pressed, !0 === x[e] ? t.dispatchEvent({ type: "selectstart" }) : (t.dispatchEvent({ type: "selectend" }), t.dispatchEvent({ type: "select" }))) } else t.visible = !1 } }(), b }, this.getStandingMatrix = function() { return d }, this.isPresenting = _; var w = new Di;
                this.setAnimationLoop = function(e) { w.setAnimationLoop(e) }, this.submitFrame = function() { _() && l.submitFrame() }, this.dispose = function() { "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", e) } }

            function So(t) { var i = t.context,
                    n = null,
                    d = null,
                    r = 1,
                    p = null,
                    a = "stage",
                    f = null,
                    m = [],
                    g = [];

                function o() { return null !== d && null !== p } var s = new io;
                s.layers.enable(1), s.viewport = new pi; var l = new io;
                l.layers.enable(2), l.viewport = new pi; var v = new no([s, l]);

                function c(e) { var t = m[g.indexOf(e.inputSource)];
                    t && t.dispatchEvent({ type: e.type }) }

                function h() { t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), y.stop() }

                function u(e, t) { null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.getInverse(e.matrixWorld) }
                v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function(e) { var t = m[e]; return void 0 === t && ((t = new eo).matrixAutoUpdate = !1, t.visible = !1, m[e] = t), t }, this.getDevice = function() { return n }, this.setDevice = function(e) { void 0 !== e && (n = e), e instanceof XRDevice && i.setCompatibleXRDevice(e) }, this.setFramebufferScaleFactor = function(e) { r = e }, this.setFrameOfReferenceType = function(e) { a = e }, this.setSession = function(e) { null !== (d = e) && (d.addEventListener("select", c), d.addEventListener("selectstart", c), d.addEventListener("selectend", c), d.addEventListener("end", h), d.baseLayer = new XRWebGLLayer(d, i, { framebufferScaleFactor: r }), d.requestFrameOfReference(a).then(function(e) { p = e, t.setFramebuffer(d.baseLayer.framebuffer), y.setContext(d), y.start() }), g = d.getInputSources(), d.addEventListener("inputsourceschange", function() { g = d.getInputSources(), console.log(g); for (var e = 0; e < m.length; e++) { m[e].userData.inputSource = g[e] } })) }, this.getCamera = function(e) { if (o()) { var t = e.parent,
                            i = v.cameras;
                        u(v, t); for (var n = 0; n < i.length; n++) u(i[n], t);
                        e.matrixWorld.copy(v.matrixWorld); for (var r = e.children, a = (n = 0, r.length); n < a; n++) r[n].updateMatrixWorld(!0); return To(v, s, l), v } return e }, this.isPresenting = o; var M = null; var y = new Di;
                y.setAnimationLoop(function(e, t) { if (null !== (f = t.getDevicePose(p)))
                        for (var i = d.baseLayer, n = t.views, r = 0; r < n.length; r++) { var a = n[r],
                                o = i.getViewport(a),
                                s = f.getViewMatrix(a),
                                l = v.cameras[r];
                            l.matrix.fromArray(s).getInverse(l.matrix), l.projectionMatrix.fromArray(a.projectionMatrix), l.viewport.set(o.x, o.y, o.width, o.height), 0 === r && v.matrix.copy(l.matrix) }
                    for (r = 0; r < m.length; r++) { var c = m[r],
                            h = g[r]; if (h) { var u = t.getInputPose(h, p); if (null !== u) { "targetRay" in u ? c.matrix.elements = u.targetRay.transformMatrix : "pointerMatrix" in u && (c.matrix.elements = u.pointerMatrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.visible = !0; continue } }
                        c.visible = !1 }
                    M && M(e) }), this.setAnimationLoop = function(e) { M = e }, this.dispose = function() {}, this.getStandingMatrix = function() { return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new jt }, this.submitFrame = function() {} }

            function Eo(e) { console.log("THREE.WebGLRenderer", "102"); var n = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    t = void 0 !== e.context ? e.context : null,
                    i = void 0 !== e.alpha && e.alpha,
                    r = void 0 === e.depth || e.depth,
                    a = void 0 === e.stencil || e.stencil,
                    o = void 0 !== e.antialias && e.antialias,
                    s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha,
                    l = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer,
                    c = void 0 !== e.powerPreference ? e.powerPreference : "default",
                    f = null,
                    k = null;
                this.domElement = n, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = Te, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; var U, T, V, j, h, W, u, w, S, m, M, d, p, g, E, P, A, v, X = this,
                    y = !1,
                    b = null,
                    _ = null,
                    x = null,
                    Y = -1,
                    C = { geometry: null, program: null, wireframe: !1 },
                    q = null,
                    L = null,
                    R = new pi,
                    H = new pi,
                    O = null,
                    Z = 0,
                    G = n.width,
                    J = n.height,
                    K = 1,
                    D = new pi(0, 0, G, J),
                    I = new pi(0, 0, G, J),
                    B = !1,
                    N = new _i,
                    Q = new Pr,
                    $ = !1,
                    ee = !1,
                    F = new jt,
                    te = new Xt;

                function z() { return null === _ ? K : 1 } try { var ie = { alpha: i, depth: r, stencil: a, antialias: o, premultipliedAlpha: s, preserveDrawingBuffer: l, powerPreference: c }; if (n.addEventListener("webglcontextlost", oe, !1), n.addEventListener("webglcontextrestored", se, !1), null === (U = t || n.getContext("webgl", ie) || n.getContext("experimental-webgl", ie))) throw null !== n.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === U.getShaderPrecisionFormat && (U.getShaderPrecisionFormat = function() { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (e) { throw console.error("THREE.WebGLRenderer: " + e.message), e }

                function ne() { T = new Ar(U), (V = new Er(U, T, e)).isWebGL2 || (T.get("WEBGL_depth_texture"), T.get("OES_texture_float"), T.get("OES_texture_half_float"), T.get("OES_texture_half_float_linear"), T.get("OES_standard_derivatives"), T.get("OES_element_index_uint"), T.get("ANGLE_instanced_arrays")), T.get("OES_texture_float_linear"), v = new $a(U, T, V), (j = new Ka(U, T, v, V)).scissor(H.copy(I).multiplyScalar(K)), j.viewport(R.copy(D).multiplyScalar(K)), h = new Rr(U), W = new Na, u = new Qa(U, T, j, W, V, v, h), w = new Ii(U), S = new Cr(U, w, h), m = new Gr(S, h), E = new Or(U), M = new Ba(X, T, V), d = new Ua, p = new Ya, g = new wr(X, j, m, s), P = new Sr(U, T, h, V), A = new Lr(U, T, h, V), h.programs = M.programs, X.context = U, X.capabilities = V, X.extensions = T, X.properties = W, X.renderLists = d, X.state = j, X.info = h }
                ne(); var re = null; "undefined" != typeof navigator && (re = "xr" in navigator ? new So(X) : new wo(X)), this.vr = re; var ae = new Ja(X, m, V.maxTextureSize);

                function oe(e) { e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0 }

                function se() { console.log("THREE.WebGLRenderer: Context Restored."), y = !1, ne() }

                function le(e) { var t, i = e.target;
                    i.removeEventListener("dispose", le), ce(t = i), W.remove(t) }

                function ce(e) { var t = W.get(e).program;
                    (e.program = void 0) !== t && M.releaseProgram(t) }
                this.shadowMap = ae, this.getContext = function() { return U }, this.getContextAttributes = function() { return U.getContextAttributes() }, this.forceContextLoss = function() { var e = T.get("WEBGL_lose_context");
                    e && e.loseContext() }, this.forceContextRestore = function() { var e = T.get("WEBGL_lose_context");
                    e && e.restoreContext() }, this.getPixelRatio = function() { return K }, this.setPixelRatio = function(e) { void 0 !== e && (K = e, this.setSize(G, J, !1)) }, this.getSize = function(e) { return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), e = new Vt), e.set(G, J) }, this.setSize = function(e, t, i) { re.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (G = e, J = t, n.width = e * K, n.height = t * K, !1 !== i && (n.style.width = e + "px", n.style.height = t + "px"), this.setViewport(0, 0, e, t)) }, this.getDrawingBufferSize = function(e) { return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), e = new Vt), e.set(G * K, J * K) }, this.setDrawingBufferSize = function(e, t, i) { G = e, J = t, K = i, n.width = e * i, n.height = t * i, this.setViewport(0, 0, e, t) }, this.getCurrentViewport = function(e) { return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), e = new pi), e.copy(R) }, this.getViewport = function(e) { return e.copy(D) }, this.setViewport = function(e, t, i, n) { e.isVector4 ? D.set(e.x, e.y, e.z, e.w) : D.set(e, t, i, n), j.viewport(R.copy(D).multiplyScalar(K)) }, this.getScissor = function(e) { return e.copy(I) }, this.setScissor = function(e, t, i, n) { e.isVector4 ? I.set(e.x, e.y, e.z, e.w) : I.set(e, t, i, n), j.scissor(H.copy(I).multiplyScalar(K)) }, this.getScissorTest = function() { return B }, this.setScissorTest = function(e) { j.setScissorTest(B = e) }, this.getClearColor = function() { return g.getClearColor() }, this.setClearColor = function() { g.setClearColor.apply(g, arguments) }, this.getClearAlpha = function() { return g.getClearAlpha() }, this.setClearAlpha = function() { g.setClearAlpha.apply(g, arguments) }, this.clear = function(e, t, i) { var n = 0;
                    (void 0 === e || e) && (n |= 16384), (void 0 === t || t) && (n |= 256), (void 0 === i || i) && (n |= 1024), U.clear(n) }, this.clearColor = function() { this.clear(!0, !1, !1) }, this.clearDepth = function() { this.clear(!1, !0, !1) }, this.clearStencil = function() { this.clear(!1, !1, !0) }, this.dispose = function() { n.removeEventListener("webglcontextlost", oe, !1), n.removeEventListener("webglcontextrestored", se, !1), d.dispose(), p.dispose(), W.dispose(), m.dispose(), re.dispose(), fe.stop() }, this.renderBufferImmediate = function(e, t) { j.initAttributes(); var i = W.get(e);
                    e.hasPositions && !i.position && (i.position = U.createBuffer()), e.hasNormals && !i.normal && (i.normal = U.createBuffer()), e.hasUvs && !i.uv && (i.uv = U.createBuffer()), e.hasColors && !i.color && (i.color = U.createBuffer()); var n = t.getAttributes();
                    e.hasPositions && (U.bindBuffer(34962, i.position), U.bufferData(34962, e.positionArray, 35048), j.enableAttribute(n.position), U.vertexAttribPointer(n.position, 3, 5126, !1, 0, 0)), e.hasNormals && (U.bindBuffer(34962, i.normal), U.bufferData(34962, e.normalArray, 35048), j.enableAttribute(n.normal), U.vertexAttribPointer(n.normal, 3, 5126, !1, 0, 0)), e.hasUvs && (U.bindBuffer(34962, i.uv), U.bufferData(34962, e.uvArray, 35048), j.enableAttribute(n.uv), U.vertexAttribPointer(n.uv, 2, 5126, !1, 0, 0)), e.hasColors && (U.bindBuffer(34962, i.color), U.bufferData(34962, e.colorArray, 35048), j.enableAttribute(n.color), U.vertexAttribPointer(n.color, 3, 5126, !1, 0, 0)), j.disableUnusedAttributes(), U.drawArrays(4, 0, e.count), e.count = 0 }, this.renderBufferDirect = function(e, t, i, n, r, a) { var o = r.isMesh && r.matrixWorld.determinant() < 0;
                    j.setMaterial(n, o); var s = Me(e, t, n, r),
                        l = !1;
                    C.geometry === i.id && C.program === s.id && C.wireframe === (!0 === n.wireframe) || (C.geometry = i.id, C.program = s.id, C.wireframe = !0 === n.wireframe, l = !0), r.morphTargetInfluences && (E.update(r, i, n, s), l = !0); var c, h = i.index,
                        u = i.attributes.position,
                        d = 1;!0 === n.wireframe && (h = S.getWireframeAttribute(i), d = 2); var p = P;
                    null !== h && (c = w.get(h), (p = A).setIndex(c)), l && (! function(e, t, i) { if (i && i.isInstancedBufferGeometry && !V.isWebGL2 && null === T.get("ANGLE_instanced_arrays")) return console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        j.initAttributes(); var n = i.attributes,
                            r = t.getAttributes(),
                            a = e.defaultAttributeValues; for (var o in r) { var s = r[o]; if (0 <= s) { var l = n[o]; if (void 0 !== l) { var c = l.normalized,
                                        h = l.itemSize,
                                        u = w.get(l); if (void 0 === u) continue; var d = u.buffer,
                                        p = u.type,
                                        f = u.bytesPerElement; if (l.isInterleavedBufferAttribute) { var m = l.data,
                                            g = m.stride,
                                            v = l.offset;
                                        m && m.isInstancedInterleavedBuffer ? (j.enableAttributeAndDivisor(s, m.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = m.meshPerAttribute * m.count)) : j.enableAttribute(s), U.bindBuffer(34962, d), U.vertexAttribPointer(s, h, p, c, g * f, v * f) } else l.isInstancedBufferAttribute ? (j.enableAttributeAndDivisor(s, l.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = l.meshPerAttribute * l.count)) : j.enableAttribute(s), U.bindBuffer(34962, d), U.vertexAttribPointer(s, h, p, c, 0, 0) } else if (void 0 !== a) { var M = a[o]; if (void 0 !== M) switch (M.length) {
                                        case 2:
                                            U.vertexAttrib2fv(s, M); break;
                                        case 3:
                                            U.vertexAttrib3fv(s, M); break;
                                        case 4:
                                            U.vertexAttrib4fv(s, M); break;
                                        default:
                                            U.vertexAttrib1fv(s, M) } } } }
                        j.disableUnusedAttributes() }(n, s, i), null !== h && U.bindBuffer(34963, c.buffer)); var f = 1 / 0;
                    null !== h ? f = h.count : void 0 !== u && (f = u.count); var m = i.drawRange.start * d,
                        g = i.drawRange.count * d,
                        v = null !== a ? a.start * d : 0,
                        M = null !== a ? a.count * d : 1 / 0,
                        y = Math.max(m, v),
                        b = Math.min(f, m + g, v + M) - 1,
                        _ = Math.max(0, b - y + 1); if (0 !== _) { if (r.isMesh)
                            if (!0 === n.wireframe) j.setLineWidth(n.wireframeLinewidth * z()), p.setMode(1);
                            else switch (r.drawMode) {
                                case Lt:
                                    p.setMode(4); break;
                                case 1:
                                    p.setMode(5); break;
                                case 2:
                                    p.setMode(6) } else if (r.isLine) { var x = n.linewidth;
                                void 0 === x && (x = 1), j.setLineWidth(x * z()), r.isLineSegments ? p.setMode(1) : r.isLineLoop ? p.setMode(2) : p.setMode(3) } else r.isPoints ? p.setMode(0) : r.isSprite && p.setMode(4);
                        i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && p.renderInstances(i, y, _) : p.render(y, _) } }, this.compile = function(i, e) {
                    (k = p.get(i, e)).init(), i.traverse(function(e) { e.isLight && (k.pushLight(e), e.castShadow && k.pushShadow(e)) }), k.setupLights(e), i.traverse(function(e) { if (e.material)
                            if (Array.isArray(e.material))
                                for (var t = 0; t < e.material.length; t++) ve(e.material[t], i.fog, e);
                            else ve(e.material, i.fog, e) }) }; var he = null; var ue, de, pe, fe = new Di;

                function me(e, t, i, n) { for (var r = 0, a = e.length; r < a; r++) { var o = e[r],
                            s = o.object,
                            l = o.geometry,
                            c = void 0 === n ? o.material : n,
                            h = o.group; if (i.isArrayCamera)
                            for (var u = (L = i).cameras, d = 0, p = u.length; d < p; d++) { var f = u[d]; if (s.layers.test(f.layers)) { if ("viewport" in f) j.viewport(R.copy(f.viewport));
                                    else { var m = f.bounds,
                                            g = m.x * G,
                                            v = m.y * J,
                                            M = m.z * G,
                                            y = m.w * J;
                                        j.viewport(R.set(g, v, M, y).multiplyScalar(K)) }
                                    k.setupLights(f), ge(s, t, f, l, c, h) } } else L = null, ge(s, t, i, l, c, h) } }

                function ge(e, t, i, n, r, a) { if (e.onBeforeRender(X, t, i, n, r, a), k = p.get(t, L || i), e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), e.isImmediateRenderObject) { j.setMaterial(r); var o = Me(i, t.fog, r, e);
                        C.geometry = null, C.program = null, C.wireframe = !1, s = o, e.render(function(e) { X.renderBufferImmediate(e, s) }) } else X.renderBufferDirect(i, t.fog, n, r, e, a); var s;
                    e.onAfterRender(X, t, i, n, r, a), k = p.get(t, L || i) }

                function ve(e, t, i) { var n = W.get(e),
                        r = k.state.lights,
                        a = k.state.shadowsArray,
                        o = n.lightsHash,
                        s = r.state.hash,
                        l = M.getParameters(e, r.state, a, t, Q.numPlanes, Q.numIntersection, i),
                        c = M.getProgramCode(e, l),
                        h = n.program,
                        u = !0; if (void 0 === h) e.addEventListener("dispose", le);
                    else if (h.code !== c) ce(e);
                    else if (o.stateID !== s.stateID || o.directionalLength !== s.directionalLength || o.pointLength !== s.pointLength || o.spotLength !== s.spotLength || o.rectAreaLength !== s.rectAreaLength || o.hemiLength !== s.hemiLength || o.shadowsLength !== s.shadowsLength) o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, u = !1;
                    else { if (void 0 !== l.shaderID) return;
                        u = !1 } if (u) { if (l.shaderID) { var d = Gi[l.shaderID];
                            n.shader = { name: e.type, uniforms: Ti(d.uniforms), vertexShader: d.vertexShader, fragmentShader: d.fragmentShader } } else n.shader = { name: e.type, uniforms: e.uniforms, vertexShader: e.vertexShader, fragmentShader: e.fragmentShader };
                        e.onBeforeCompile(n.shader, X), c = M.getProgramCode(e, l), h = M.acquireProgram(e, n.shader, l, c), n.program = h, e.program = h } var p = h.getAttributes(); if (e.morphTargets)
                        for (var f = e.numSupportedMorphTargets = 0; f < X.maxMorphTargets; f++) 0 <= p["morphTarget" + f] && e.numSupportedMorphTargets++; if (e.morphNormals)
                        for (f = e.numSupportedMorphNormals = 0; f < X.maxMorphNormals; f++) 0 <= p["morphNormal" + f] && e.numSupportedMorphNormals++; var m = n.shader.uniforms;
                    (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = Q.numPlanes, n.numIntersection = Q.numIntersection, m.clippingPlanes = Q.uniform), n.fog = t, void 0 === o && (n.lightsHash = o = {}), o.stateID = s.stateID, o.directionalLength = s.directionalLength, o.pointLength = s.pointLength, o.spotLength = s.spotLength, o.rectAreaLength = s.rectAreaLength, o.hemiLength = s.hemiLength, o.shadowsLength = s.shadowsLength, e.lights && (m.ambientLightColor.value = r.state.ambient, m.directionalLights.value = r.state.directional, m.spotLights.value = r.state.spot, m.rectAreaLights.value = r.state.rectArea, m.pointLights.value = r.state.point, m.hemisphereLights.value = r.state.hemi, m.directionalShadowMap.value = r.state.directionalShadowMap, m.directionalShadowMatrix.value = r.state.directionalShadowMatrix, m.spotShadowMap.value = r.state.spotShadowMap, m.spotShadowMatrix.value = r.state.spotShadowMatrix, m.pointShadowMap.value = r.state.pointShadowMap, m.pointShadowMatrix.value = r.state.pointShadowMatrix); var g = n.program.getUniforms(),
                        v = Ea.seqWithValue(g.seq, m);
                    n.uniformsList = v }

                function Me(e, t, i, n) { Z = 0; var r = W.get(i),
                        a = k.state.lights,
                        o = r.lightsHash,
                        s = a.state.hash; if ($ && (ee || e !== q)) { var l = e === q && i.id === Y;
                        Q.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, r, l) }!1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== t ? i.needsUpdate = !0 : (!i.lights || o.stateID === s.stateID && o.directionalLength === s.directionalLength && o.pointLength === s.pointLength && o.spotLength === s.spotLength && o.rectAreaLength === s.rectAreaLength && o.hemiLength === s.hemiLength && o.shadowsLength === s.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === Q.numPlanes && r.numIntersection === Q.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (ve(i, t, n), i.needsUpdate = !1); var c, h, u, d, p, f, m, g, v, M, y, b, _, x, T, w, S, E, P, A, C = !1,
                        L = !1,
                        R = !1,
                        H = r.program,
                        O = H.getUniforms(),
                        G = r.shader.uniforms; if (j.useProgram(H.program) && (R = L = C = !0), i.id !== Y && (Y = i.id, L = !0), C || q !== e) { if (O.setValue(U, "projectionMatrix", e.projectionMatrix), V.logarithmicDepthBuffer && O.setValue(U, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), q !== e && (q = e, R = L = !0), i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) { var D = O.map.cameraPosition;
                            void 0 !== D && D.setValue(U, te.setFromMatrixPosition(e.matrixWorld)) }(i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && O.setValue(U, "viewMatrix", e.matrixWorldInverse) } if (i.skinning) { O.setOptional(U, n, "bindMatrix"), O.setOptional(U, n, "bindMatrixInverse"); var I = n.skeleton; if (I) { var B = I.bones; if (V.floatVertexTextures) { if (void 0 === I.boneTexture) { var N = Math.sqrt(4 * B.length);
                                    N = Ut.ceilPowerOfTwo(N), N = Math.max(N, 4); var F = new Float32Array(N * N * 4);
                                    F.set(I.boneMatrices); var z = new vi(F, N, N, Ze, ke);
                                    z.needsUpdate = !0, I.boneMatrices = F, I.boneTexture = z, I.boneTextureSize = N }
                                O.setValue(U, "boneTexture", I.boneTexture), O.setValue(U, "boneTextureSize", I.boneTextureSize) } else O.setOptional(U, I, "boneMatrices") } } return L && (O.setValue(U, "toneMappingExposure", X.toneMappingExposure), O.setValue(U, "toneMappingWhitePoint", X.toneMappingWhitePoint), i.lights && (A = R, (P = G).ambientLightColor.needsUpdate = A, P.directionalLights.needsUpdate = A, P.pointLights.needsUpdate = A, P.spotLights.needsUpdate = A, P.rectAreaLights.needsUpdate = A, P.hemisphereLights.needsUpdate = A), t && i.fog && (E = t, (S = G).fogColor.value = E.color, E.isFog ? (S.fogNear.value = E.near, S.fogFar.value = E.far) : E.isFogExp2 && (S.fogDensity.value = E.density)), i.isMeshBasicMaterial ? ye(G, i) : i.isMeshLambertMaterial ? (ye(G, i), T = G, (w = i).emissiveMap && (T.emissiveMap.value = w.emissiveMap)) : i.isMeshPhongMaterial ? (ye(G, i), i.isMeshToonMaterial ? (be(_ = G, x = i), x.gradientMap && (_.gradientMap.value = x.gradientMap)) : be(G, i)) : i.isMeshStandardMaterial ? (ye(G, i), i.isMeshPhysicalMaterial ? (_e(y = G, b = i), y.reflectivity.value = b.reflectivity, y.clearCoat.value = b.clearCoat, y.clearCoatRoughness.value = b.clearCoatRoughness) : _e(G, i)) : i.isMeshMatcapMaterial ? (ye(G, i), function(e, t) { t.matcap && (e.matcap.value = t.matcap);
                        t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === xe && (e.bumpScale.value *= -1));
                        t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === xe && e.normalScale.value.negate());
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(G, i)) : i.isMeshDepthMaterial ? (ye(G, i), v = G, (M = i).displacementMap && (v.displacementMap.value = M.displacementMap, v.displacementScale.value = M.displacementScale, v.displacementBias.value = M.displacementBias)) : i.isMeshDistanceMaterial ? (ye(G, i), function(e, t) { t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias);
                        e.referencePosition.value.copy(t.referencePosition), e.nearDistance.value = t.nearDistance, e.farDistance.value = t.farDistance }(G, i)) : i.isMeshNormalMaterial ? (ye(G, i), function(e, t) { t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === xe && (e.bumpScale.value *= -1));
                        t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === xe && e.normalScale.value.negate());
                        t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }(G, i)) : i.isLineBasicMaterial ? (g = i, (m = G).diffuse.value = g.color, m.opacity.value = g.opacity, i.isLineDashedMaterial && (f = i, (p = G).dashSize.value = f.dashSize, p.totalSize.value = f.dashSize + f.gapSize, p.scale.value = f.scale)) : i.isPointsMaterial ? (d = i, (u = G).diffuse.value = d.color, u.opacity.value = d.opacity, u.size.value = d.size * K, u.scale.value = .5 * J, u.map.value = d.map, null !== d.map && (!0 === d.map.matrixAutoUpdate && d.map.updateMatrix(), u.uvTransform.value.copy(d.map.matrix))) : i.isSpriteMaterial ? (h = i, (c = G).diffuse.value = h.color, c.opacity.value = h.opacity, c.rotation.value = h.rotation, c.map.value = h.map, null !== h.map && (!0 === h.map.matrixAutoUpdate && h.map.updateMatrix(), c.uvTransform.value.copy(h.map.matrix))) : i.isShadowMaterial && (G.color.value = i.color, G.opacity.value = i.opacity), void 0 !== G.ltc_1 && (G.ltc_1.value = Oi.LTC_1), void 0 !== G.ltc_2 && (G.ltc_2.value = Oi.LTC_2), Ea.upload(U, r.uniformsList, G, X)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Ea.upload(U, r.uniformsList, G, X), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && O.setValue(U, "center", n.center), O.setValue(U, "modelViewMatrix", n.modelViewMatrix), O.setValue(U, "normalMatrix", n.normalMatrix), O.setValue(U, "modelMatrix", n.matrixWorld), H }

                function ye(e, t) { var i;
                    e.opacity.value = t.opacity, t.color && (e.diffuse.value = t.color), t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), t.map && (e.map.value = t.map), t.alphaMap && (e.alphaMap.value = t.alphaMap), t.specularMap && (e.specularMap.value = t.specularMap), t.envMap && (e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio, e.maxMipLevel.value = W.get(t.envMap).__maxMipLevel), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity), t.map ? i = t.map : t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap), void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), e.uvTransform.value.copy(i.matrix)) }

                function be(e, t) { e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === xe && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === xe && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias) }

                function _e(e, t) { e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale, t.side === xe && (e.bumpScale.value *= -1)), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale), t.side === xe && e.normalScale.value.negate()), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity) }
                fe.setAnimationLoop(function(e) { re.isPresenting() || he && he(e) }), "undefined" != typeof window && fe.setContext(window), this.setAnimationLoop = function(e) { he = e, re.setAnimationLoop(e), fe.start() }, this.render = function(e, t) { var i, n; if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), i = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), n = arguments[3]), t && t.isCamera) { if (!y) { C.geometry = null, C.program = null, C.wireframe = !1, Y = -1, !(q = null) === e.autoUpdate && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), re.enabled && (t = re.getCamera(t)), (k = p.get(e, t)).init(), e.onBeforeRender(X, e, t, i || _), F.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), N.setFromMatrix(F), ee = this.localClippingEnabled, $ = Q.init(this.clippingPlanes, ee, t), (f = d.get(e, t)).init(),
                                function e(t, i, n, r) { if (!1 === t.visible) return; var a = t.layers.test(i.layers); if (a)
                                        if (t.isGroup) n = t.renderOrder;
                                        else if (t.isLight) k.pushLight(t), t.castShadow && k.pushShadow(t);
                                    else if (t.isSprite) { if (!t.frustumCulled || N.intersectsSprite(t)) { r && te.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F); var o = m.update(t),
                                                s = t.material;
                                            f.push(t, o, s, n, te.z, null) } } else if (t.isImmediateRenderObject) r && te.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F), f.push(t, null, t.material, n, te.z, null);
                                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || N.intersectsObject(t))) { r && te.setFromMatrixPosition(t.matrixWorld).applyMatrix4(F); var o = m.update(t),
                                            s = t.material; if (Array.isArray(s))
                                            for (var l = o.groups, c = 0, h = l.length; c < h; c++) { var u = l[c],
                                                    d = s[u.materialIndex];
                                                d && d.visible && f.push(t, o, d, n, te.z, u) } else s.visible && f.push(t, o, s, n, te.z, null) } var p = t.children; for (var c = 0, h = p.length; c < h; c++) e(p[c], i, n, r) }(e, t, 0, X.sortObjects), !0 === X.sortObjects && f.sort(), $ && Q.beginShadows(); var r = k.state.shadowsArray;
                            ae.render(r, e, t), k.setupLights(t), $ && Q.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== i && this.setRenderTarget(i), g.render(f, e, t, n); var a = f.opaque,
                                o = f.transparent; if (e.overrideMaterial) { var s = e.overrideMaterial;
                                a.length && me(a, e, t, s), o.length && me(o, e, t, s) } else a.length && me(a, e, t), o.length && me(o, e, t);
                            null !== _ && (u.updateRenderTargetMipmap(_), u.updateMultisampleRenderTarget(_)), j.buffers.depth.setTest(!0), j.buffers.depth.setMask(!0), j.buffers.color.setMask(!0), j.setPolygonOffset(!1), e.onAfterRender(X, e, t), re.enabled && re.submitFrame(), k = f = null } } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.") }, this.allocTextureUnit = function() { var e = Z; return e >= V.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + V.maxTextures), Z += 1, e }, this.setTexture2D = (ue = !1, function(e, t) { e && e.isWebGLRenderTarget && (ue || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), ue = !0), e = e.texture), u.setTexture2D(e, t) }), this.setTexture3D = function(e, t) { u.setTexture3D(e, t) }, this.setTexture = (de = !1, function(e, t) { de || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), de = !0), u.setTexture2D(e, t) }), this.setTextureCube = (pe = !1, function(e, t) { e && e.isWebGLRenderTargetCube && (pe || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), pe = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? u.setTextureCube(e, t) : u.setTextureCubeDynamic(e, t) }), this.setFramebuffer = function(e) { b = e }, this.getRenderTarget = function() { return _ }, this.setRenderTarget = function(e, t, i) {
                    (_ = e) && void 0 === W.get(e).__webglFramebuffer && u.setupRenderTarget(e); var n = b,
                        r = !1; if (e) { var a = W.get(e).__webglFramebuffer;
                        e.isWebGLRenderTargetCube ? (n = a[t || 0], r = !0) : n = e.isWebGLMultisampleRenderTarget ? W.get(e).__webglMultisampledFramebuffer : a, R.copy(e.viewport), H.copy(e.scissor), O = e.scissorTest } else R.copy(D).multiplyScalar(K), H.copy(I).multiplyScalar(K), O = B; if (x !== n && (U.bindFramebuffer(36160, n), x = n), j.viewport(R), j.scissor(H), j.setScissorTest(O), r) { var o = W.get(e.texture);
                        U.framebufferTexture2D(36160, 36064, 34069 + t || 0, o.__webglTexture, i || 0) } }, this.readRenderTargetPixels = function(e, t, i, n, r, a) { if (e && e.isWebGLRenderTarget) { var o = W.get(e).__webglFramebuffer; if (o) { var s = !1;
                            o !== x && (U.bindFramebuffer(36160, o), s = !0); try { var l = e.texture,
                                    c = l.format,
                                    h = l.type; if (c !== Ze && v.convert(c) !== U.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); if (!(h === De || v.convert(h) === U.getParameter(35738) || h === ke && (V.isWebGL2 || T.get("OES_texture_float") || T.get("WEBGL_color_buffer_float")) || h === Ue && (V.isWebGL2 ? T.get("EXT_color_buffer_float") : T.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === U.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - n && 0 <= i && i <= e.height - r && U.readPixels(t, i, n, r, v.convert(c), v.convert(h), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") } finally { s && U.bindFramebuffer(36160, x) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.copyFramebufferToTexture = function(e, t, i) { var n = t.image.width,
                        r = t.image.height,
                        a = v.convert(t.format);
                    this.setTexture2D(t, 0), U.copyTexImage2D(3553, i || 0, a, e.x, e.y, n, r, 0) }, this.copyTextureToTexture = function(e, t, i, n) { var r = t.image.width,
                        a = t.image.height,
                        o = v.convert(i.format),
                        s = v.convert(i.type);
                    this.setTexture2D(i, 0), t.isDataTexture ? U.texSubImage2D(3553, n || 0, e.x, e.y, r, a, o, s, t.image.data) : U.texSubImage2D(3553, n || 0, e.x, e.y, o, s, t.image) } }

            function Po(e, t) { this.name = "", this.color = new Li(e), this.density = void 0 !== t ? t : 25e-5 }

            function Ao(e, t, i) { this.name = "", this.color = new Li(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3 }

            function Co() { on.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0 }

            function Lo(e, t) { this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 }

            function Ro(e, t, i, n) { this.data = e, this.itemSize = t, this.offset = i, this.normalized = !0 === n }

            function Ho(e) { Wn.call(this), this.type = "SpriteMaterial", this.color = new Li(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(e) }

            function Oo(e) { if (on.call(this), this.type = "Sprite", void 0 === ro) { ro = new Fn; var t = new Lo(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    ro.setIndex([0, 1, 2, 0, 2, 3]), ro.addAttribute("position", new Ro(t, 3, 0, !1)), ro.addAttribute("uv", new Ro(t, 2, 3, !1)) }
                this.geometry = ro, this.material = void 0 !== e ? e : new Ho, this.center = new Vt(.5, .5) }

            function Go() { on.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }) }

            function Do(e, t) { e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Tr.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new jt, this.bindMatrixInverse = new jt }

            function Io(e, t) { if (e = e || [], this.bones = e.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === t) this.calculateInverses();
                else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
                else { console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = []; for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new jt) } }

            function Bo() { on.call(this), this.type = "Bone" }

            function No(e) { Wn.call(this), this.type = "LineBasicMaterial", this.color = new Li(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(e) }

            function Fo(e, t, i) { 1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), on.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new Fn, this.material = void 0 !== t ? t : new No({ color: 16777215 * Math.random() }) }

            function zo(e, t) { Fo.call(this, e, t), this.type = "LineSegments" }

            function ko(e, t) { Fo.call(this, e, t), this.type = "LineLoop" }

            function Uo(e) { Wn.call(this), this.type = "PointsMaterial", this.color = new Li(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(e) }

            function Vo(e, t) { on.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new Fn, this.material = void 0 !== t ? t : new Uo({ color: 16777215 * Math.random() }) }

            function jo(e, t, i, n, r, a, o, s, l) { di.call(this, e, t, i, n, r, a, o, s, l), this.format = void 0 !== o ? o : qe, this.minFilter = void 0 !== a ? a : He, this.magFilter = void 0 !== r ? r : He, this.generateMipmaps = !1 }

            function Wo(e, t, i, n, r, a, o, s, l, c, h, u) { di.call(this, null, a, o, s, l, c, n, r, h, u), this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1 }

            function Xo(e, t, i, n, r, a, o, s, l) { di.call(this, e, t, i, n, r, a, o, s, l), this.needsUpdate = !0 }

            function Yo(e, t, i, n, r, a, o, s, l, c) { if ((c = void 0 !== c ? c : $e) !== $e && c !== et) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === i && c === $e && (i = Ne), void 0 === i && c === et && (i = Xe), di.call(this, null, n, r, a, o, s, c, i, l), this.image = { width: e, height: t }, this.magFilter = void 0 !== o ? o : Ce, this.minFilter = void 0 !== s ? s : Ce, this.flipY = !1, this.generateMipmaps = !1 }

            function qo(e) { Fn.call(this), this.type = "WireframeGeometry"; var t, i, n, r, a, o, s, l, c, h, u = [],
                    d = [0, 0],
                    p = {},
                    f = ["a", "b", "c"]; if (e && e.isGeometry) { var m = e.faces; for (t = 0, n = m.length; t < n; t++) { var g = m[t]; for (i = 0; i < 3; i++) s = g[f[i]], l = g[f[(i + 1) % 3]], d[0] = Math.min(s, l), d[1] = Math.max(s, l), void 0 === p[c = d[0] + "," + d[1]] && (p[c] = { index1: d[0], index2: d[1] }) } for (c in p) o = p[c], h = e.vertices[o.index1], u.push(h.x, h.y, h.z), h = e.vertices[o.index2], u.push(h.x, h.y, h.z) } else if (e && e.isBufferGeometry) { var v, M, y, b, _, x; if (h = new Xt, null !== e.index) { for (v = e.attributes.position, M = e.index, 0 === (y = e.groups).length && (y = [{ start: 0, count: M.count, materialIndex: 0 }]), r = 0, a = y.length; r < a; ++r)
                            for (n = (t = (b = y[r]).start) + b.count; t < n; t += 3)
                                for (i = 0; i < 3; i++) s = M.getX(t + i), l = M.getX(t + (i + 1) % 3), d[0] = Math.min(s, l), d[1] = Math.max(s, l), void 0 === p[c = d[0] + "," + d[1]] && (p[c] = { index1: d[0], index2: d[1] }); for (c in p) o = p[c], h.fromBufferAttribute(v, o.index1), u.push(h.x, h.y, h.z), h.fromBufferAttribute(v, o.index2), u.push(h.x, h.y, h.z) } else
                        for (t = 0, n = (v = e.attributes.position).count / 3; t < n; t++)
                            for (i = 0; i < 3; i++) _ = 3 * t + i, h.fromBufferAttribute(v, _), u.push(h.x, h.y, h.z), x = 3 * t + (i + 1) % 3, h.fromBufferAttribute(v, x), u.push(h.x, h.y, h.z) }
                this.addAttribute("position", new wn(u, 3)) }

            function Zo(e, t, i) { mn.call(this), this.type = "ParametricGeometry", this.parameters = { func: e, slices: t, stacks: i }, this.fromBufferGeometry(new Jo(e, t, i)), this.mergeVertices() }

            function Jo(e, t, i) { Fn.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: e, slices: t, stacks: i }; var n, r, a = [],
                    o = [],
                    s = [],
                    l = [],
                    c = new Xt,
                    h = new Xt,
                    u = new Xt,
                    d = new Xt,
                    p = new Xt;
                e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); var f = t + 1; for (n = 0; n <= i; n++) { var m = n / i; for (r = 0; r <= t; r++) { var g = r / t;
                        e(g, m, h), o.push(h.x, h.y, h.z), 0 <= g - 1e-5 ? (e(g - 1e-5, m, u), d.subVectors(h, u)) : (e(g + 1e-5, m, u), d.subVectors(u, h)), 0 <= m - 1e-5 ? (e(g, m - 1e-5, u), p.subVectors(h, u)) : (e(g, m + 1e-5, u), p.subVectors(u, h)), c.crossVectors(d, p).normalize(), s.push(c.x, c.y, c.z), l.push(g, m) } } for (n = 0; n < i; n++)
                    for (r = 0; r < t; r++) { var v = n * f + r,
                            M = n * f + r + 1,
                            y = (n + 1) * f + r + 1,
                            b = (n + 1) * f + r;
                        a.push(v, M, b), a.push(M, y, b) }
                this.setIndex(a), this.addAttribute("position", new wn(o, 3)), this.addAttribute("normal", new wn(s, 3)), this.addAttribute("uv", new wn(l, 2)) }

            function Ko(e, t, i, n) { mn.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: n }, this.fromBufferGeometry(new Qo(e, t, i, n)), this.mergeVertices() }

            function Qo(n, a, e, t) { Fn.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: n, indices: a, radius: e, detail: t }, e = e || 1; var h = [],
                    u = [];

                function o(e, t, i, n) { var r, a, o = Math.pow(2, n),
                        s = []; for (r = 0; r <= o; r++) { s[r] = []; var l = e.clone().lerp(i, r / o),
                            c = t.clone().lerp(i, r / o),
                            h = o - r; for (a = 0; a <= h; a++) s[r][a] = 0 === a && r === o ? l : l.clone().lerp(c, a / h) } for (r = 0; r < o; r++)
                        for (a = 0; a < 2 * (o - r) - 1; a++) { var u = Math.floor(a / 2);
                            a % 2 == 0 ? (d(s[r][u + 1]), d(s[r + 1][u]), d(s[r][u])) : (d(s[r][u + 1]), d(s[r + 1][u + 1]), d(s[r + 1][u])) } }

                function d(e) { h.push(e.x, e.y, e.z) }

                function s(e, t) { var i = 3 * e;
                    t.x = n[i + 0], t.y = n[i + 1], t.z = n[i + 2] }

                function p(e, t, i, n) { n < 0 && 1 === e.x && (u[t] = e.x - 1), 0 === i.x && 0 === i.z && (u[t] = n / 2 / Math.PI + .5) }

                function f(e) { return Math.atan2(e.z, -e.x) }! function(e) { for (var t = new Xt, i = new Xt, n = new Xt, r = 0; r < a.length; r += 3) s(a[r + 0], t), s(a[r + 1], i), s(a[r + 2], n), o(t, i, n, e) }(t = t || 0),
                function(e) { for (var t = new Xt, i = 0; i < h.length; i += 3) t.x = h[i + 0], t.y = h[i + 1], t.z = h[i + 2], t.normalize().multiplyScalar(e), h[i + 0] = t.x, h[i + 1] = t.y, h[i + 2] = t.z }(e),
                function() { for (var e = new Xt, t = 0; t < h.length; t += 3) { e.x = h[t + 0], e.y = h[t + 1], e.z = h[t + 2]; var i = f(e) / 2 / Math.PI + .5,
                            n = (r = e, Math.atan2(-r.y, Math.sqrt(r.x * r.x + r.z * r.z)) / Math.PI + .5);
                        u.push(i, 1 - n) } var r;
                    (function() { for (var e = new Xt, t = new Xt, i = new Xt, n = new Xt, r = new Vt, a = new Vt, o = new Vt, s = 0, l = 0; s < h.length; s += 9, l += 6) { e.set(h[s + 0], h[s + 1], h[s + 2]), t.set(h[s + 3], h[s + 4], h[s + 5]), i.set(h[s + 6], h[s + 7], h[s + 8]), r.set(u[l + 0], u[l + 1]), a.set(u[l + 2], u[l + 3]), o.set(u[l + 4], u[l + 5]), n.copy(e).add(t).add(i).divideScalar(3); var c = f(n);
                            p(r, l + 0, e, c), p(a, l + 2, t, c), p(o, l + 4, i, c) } })(),
                    function() { for (var e = 0; e < u.length; e += 6) { var t = u[e + 0],
                                i = u[e + 2],
                                n = u[e + 4],
                                r = Math.max(t, i, n),
                                a = Math.min(t, i, n);
                            .9 < r && a < .1 && (t < .2 && (u[e + 0] += 1), i < .2 && (u[e + 2] += 1), n < .2 && (u[e + 4] += 1)) } }() }(), this.addAttribute("position", new wn(h, 3)), this.addAttribute("normal", new wn(h.slice(), 3)), this.addAttribute("uv", new wn(u, 2)), 0 === t ? this.computeVertexNormals() : this.normalizeNormals() }

            function $o(e, t) { mn.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new es(e, t)), this.mergeVertices() }

            function es(e, t) { Qo.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function ts(e, t) { mn.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new is(e, t)), this.mergeVertices() }

            function is(e, t) { Qo.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t), this.type = "OctahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function ns(e, t) { mn.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new rs(e, t)), this.mergeVertices() }

            function rs(e, t) { var i = (1 + Math.sqrt(5)) / 2;
                Qo.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function as(e, t) { mn.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t }, this.fromBufferGeometry(new os(e, t)), this.mergeVertices() }

            function os(e, t) { var i = (1 + Math.sqrt(5)) / 2,
                    n = 1 / i;
                Qo.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: e, detail: t } }

            function ss(e, t, i, n, r, a) { mn.call(this), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: n, closed: r }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed."); var o = new ls(e, t, i, n, r);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals, this.fromBufferGeometry(o), this.mergeVertices() }

            function ls(o, s, l, c, e) { Fn.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: o, tubularSegments: s, radius: l, radialSegments: c, closed: e }, s = s || 64, l = l || 1, c = c || 8, e = e || !1; var h = o.computeFrenetFrames(s, e);
                this.tangents = h.tangents, this.normals = h.normals, this.binormals = h.binormals; var r, u, d = new Xt,
                    p = new Xt,
                    t = new Vt,
                    f = new Xt,
                    m = [],
                    g = [],
                    i = [],
                    a = [];

                function n(e) { f = o.getPointAt(e / s, f); var t = h.normals[e],
                        i = h.binormals[e]; for (u = 0; u <= c; u++) { var n = u / c * Math.PI * 2,
                            r = Math.sin(n),
                            a = -Math.cos(n);
                        p.x = a * t.x + r * i.x, p.y = a * t.y + r * i.y, p.z = a * t.z + r * i.z, p.normalize(), g.push(p.x, p.y, p.z), d.x = f.x + l * p.x, d.y = f.y + l * p.y, d.z = f.z + l * p.z, m.push(d.x, d.y, d.z) } }! function() { for (r = 0; r < s; r++) n(r);
                    n(!1 === e ? s : 0),
                        function() { for (r = 0; r <= s; r++)
                                for (u = 0; u <= c; u++) t.x = r / s, t.y = u / c, i.push(t.x, t.y) }(),
                        function() { for (u = 1; u <= s; u++)
                                for (r = 1; r <= c; r++) { var e = (c + 1) * (u - 1) + (r - 1),
                                        t = (c + 1) * u + (r - 1),
                                        i = (c + 1) * u + r,
                                        n = (c + 1) * (u - 1) + r;
                                    a.push(e, t, n), a.push(t, i, n) } }() }(), this.setIndex(a), this.addAttribute("position", new wn(m, 3)), this.addAttribute("normal", new wn(g, 3)), this.addAttribute("uv", new wn(i, 2)) }

            function cs(e, t, i, n, r, a, o) { mn.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: n, p: r, q: a }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new hs(e, t, i, n, r, a)), this.mergeVertices() }

            function hs(e, t, i, n, r, a) { Fn.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: n, p: r, q: a }, e = e || 1, t = t || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, a = a || 3; var o, s, l = [],
                    c = [],
                    h = [],
                    u = [],
                    d = new Xt,
                    p = new Xt,
                    f = new Xt,
                    m = new Xt,
                    g = new Xt,
                    v = new Xt,
                    M = new Xt; for (o = 0; o <= i; ++o) { var y = o / i * r * Math.PI * 2; for (P(y, r, a, e, f), P(y + .01, r, a, e, m), v.subVectors(m, f), M.addVectors(m, f), g.crossVectors(v, M), M.crossVectors(g, v), g.normalize(), M.normalize(), s = 0; s <= n; ++s) { var b = s / n * Math.PI * 2,
                            _ = -t * Math.cos(b),
                            x = t * Math.sin(b);
                        d.x = f.x + (_ * M.x + x * g.x), d.y = f.y + (_ * M.y + x * g.y), d.z = f.z + (_ * M.z + x * g.z), c.push(d.x, d.y, d.z), p.subVectors(d, f).normalize(), h.push(p.x, p.y, p.z), u.push(o / i), u.push(s / n) } } for (s = 1; s <= i; s++)
                    for (o = 1; o <= n; o++) { var T = (n + 1) * (s - 1) + (o - 1),
                            w = (n + 1) * s + (o - 1),
                            S = (n + 1) * s + o,
                            E = (n + 1) * (s - 1) + o;
                        l.push(T, w, E), l.push(w, S, E) }

                function P(e, t, i, n, r) { var a = Math.cos(e),
                        o = Math.sin(e),
                        s = i / t * e,
                        l = Math.cos(s);
                    r.x = n * (2 + l) * .5 * a, r.y = n * (2 + l) * o * .5, r.z = n * Math.sin(s) * .5 }
                this.setIndex(l), this.addAttribute("position", new wn(c, 3)), this.addAttribute("normal", new wn(h, 3)), this.addAttribute("uv", new wn(u, 2)) }

            function us(e, t, i, n, r) { mn.call(this), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: n, arc: r }, this.fromBufferGeometry(new ds(e, t, i, n, r)), this.mergeVertices() }

            function ds(e, t, i, n, r) { Fn.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: n, arc: r }, e = e || 1, t = t || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI; var a, o, s = [],
                    l = [],
                    c = [],
                    h = [],
                    u = new Xt,
                    d = new Xt,
                    p = new Xt; for (a = 0; a <= i; a++)
                    for (o = 0; o <= n; o++) { var f = o / n * r,
                            m = a / i * Math.PI * 2;
                        d.x = (e + t * Math.cos(m)) * Math.cos(f), d.y = (e + t * Math.cos(m)) * Math.sin(f), d.z = t * Math.sin(m), l.push(d.x, d.y, d.z), u.x = e * Math.cos(f), u.y = e * Math.sin(f), p.subVectors(d, u).normalize(), c.push(p.x, p.y, p.z), h.push(o / n), h.push(a / i) }
                for (a = 1; a <= i; a++)
                    for (o = 1; o <= n; o++) { var g = (n + 1) * a + o - 1,
                            v = (n + 1) * (a - 1) + o - 1,
                            M = (n + 1) * (a - 1) + o,
                            y = (n + 1) * a + o;
                        s.push(g, v, y), s.push(v, M, y) }
                this.setIndex(s), this.addAttribute("position", new wn(l, 3)), this.addAttribute("normal", new wn(c, 3)), this.addAttribute("uv", new wn(h, 2)) }
            Object.assign(Po.prototype, { isFogExp2: !0, clone: function() { return new Po(this.color, this.density) }, toJSON: function() { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } }), Object.assign(Ao.prototype, { isFog: !0, clone: function() { return new Ao(this.color, this.near, this.far) }, toJSON: function() { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }), Co.prototype = Object.assign(Object.create(on.prototype), { constructor: Co, isScene: !0, copy: function(e, t) { return on.prototype.copy.call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this }, toJSON: function(e) { var t = on.prototype.toJSON.call(this, e); return null !== this.background && (t.object.background = this.background.toJSON(e)), null !== this.fog && (t.object.fog = this.fog.toJSON()), t }, dispose: function() { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(Lo.prototype, "needsUpdate", { set: function(e) {!0 === e && this.version++ } }), Object.assign(Lo.prototype, { isInterleavedBuffer: !0, onUploadCallback: function() {}, setArray: function(e) { if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== e ? e.length / this.stride : 0, this.array = e, this }, setDynamic: function(e) { return this.dynamic = e, this }, copy: function(e) { return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.dynamic = e.dynamic, this }, copyAt: function(e, t, i) { e *= this.stride, i *= t.stride; for (var n = 0, r = this.stride; n < r; n++) this.array[e + n] = t.array[i + n]; return this }, set: function(e, t) { return void 0 === t && (t = 0), this.array.set(e, t), this }, clone: function() { return (new this.constructor).copy(this) }, onUpload: function(e) { return this.onUploadCallback = e, this } }), Object.defineProperties(Ro.prototype, { count: { get: function() { return this.data.count } }, array: { get: function() { return this.data.array } } }), Object.assign(Ro.prototype, { isInterleavedBufferAttribute: !0, setX: function(e, t) { return this.data.array[e * this.data.stride + this.offset] = t, this }, setY: function(e, t) { return this.data.array[e * this.data.stride + this.offset + 1] = t, this }, setZ: function(e, t) { return this.data.array[e * this.data.stride + this.offset + 2] = t, this }, setW: function(e, t) { return this.data.array[e * this.data.stride + this.offset + 3] = t, this }, getX: function(e) { return this.data.array[e * this.data.stride + this.offset] }, getY: function(e) { return this.data.array[e * this.data.stride + this.offset + 1] }, getZ: function(e) { return this.data.array[e * this.data.stride + this.offset + 2] }, getW: function(e) { return this.data.array[e * this.data.stride + this.offset + 3] }, setXY: function(e, t, i) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this }, setXYZ: function(e, t, i, n) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this }, setXYZW: function(e, t, i, n, r) { return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = r, this } }), ((Ho.prototype = Object.create(Wn.prototype)).constructor = Ho).prototype.isSpriteMaterial = !0, Ho.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this }, Oo.prototype = Object.assign(Object.create(on.prototype), { constructor: Oo, isSprite: !0, raycast: function() { var l = new Xt,
                        c = new Xt,
                        h = new Xt,
                        o = new Vt,
                        s = new Vt,
                        u = new jt,
                        d = new Xt,
                        p = new Xt,
                        f = new Xt,
                        m = new Vt,
                        g = new Vt,
                        v = new Vt;

                    function M(e, t, i, n, r, a) { o.subVectors(e, i).addScalar(.5).multiply(n), void 0 !== r ? (s.x = a * o.x - r * o.y, s.y = r * o.x + a * o.y) : s.copy(o), e.copy(t), e.x += s.x, e.y += s.y, e.applyMatrix4(u) } return function(e, t) { c.setFromMatrixScale(this.matrixWorld), u.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), h.setFromMatrixPosition(this.modelViewMatrix); var i, n, r = this.material.rotation;
                        0 !== r && (n = Math.cos(r), i = Math.sin(r)); var a = this.center;
                        M(d.set(-.5, -.5, 0), h, a, c, i, n), M(p.set(.5, -.5, 0), h, a, c, i, n), M(f.set(.5, .5, 0), h, a, c, i, n), m.set(0, 0), g.set(1, 0), v.set(1, 1); var o = e.ray.intersectTriangle(d, p, f, !1, l); if (null !== o || (M(p.set(-.5, .5, 0), h, a, c, i, n), g.set(0, 1), null !== (o = e.ray.intersectTriangle(d, f, p, !1, l)))) { var s = e.ray.origin.distanceTo(l);
                            s < e.near || s > e.far || t.push({ distance: s, point: l.clone(), uv: _r.getUV(l, d, p, f, m, g, v, new Vt), face: null, object: this }) } } }(), clone: function() { return new this.constructor(this.material).copy(this) }, copy: function(e) { return on.prototype.copy.call(this, e), void 0 !== e.center && this.center.copy(e.center), this } }), Go.prototype = Object.assign(Object.create(on.prototype), { constructor: Go, copy: function(e) { on.prototype.copy.call(this, e, !1); for (var t = e.levels, i = 0, n = t.length; i < n; i++) { var r = t[i];
                        this.addLevel(r.object.clone(), r.distance) } return this }, addLevel: function(e, t) { void 0 === t && (t = 0), t = Math.abs(t); for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++);
                    i.splice(n, 0, { distance: t, object: e }), this.add(e) }, getObjectForDistance: function(e) { for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++); return t[i - 1].object }, raycast: (so = new Xt, function(e, t) { so.setFromMatrixPosition(this.matrixWorld); var i = e.ray.origin.distanceTo(so);
                    this.getObjectForDistance(i).raycast(e, t) }), update: (ao = new Xt, oo = new Xt, function(e) { var t = this.levels; if (1 < t.length) { ao.setFromMatrixPosition(e.matrixWorld), oo.setFromMatrixPosition(this.matrixWorld); var i = ao.distanceTo(oo);
                        t[0].object.visible = !0; for (var n = 1, r = t.length; n < r && i >= t[n].distance; n++) t[n - 1].object.visible = !1, t[n].object.visible = !0; for (; n < r; n++) t[n].object.visible = !1 } }), toJSON: function(e) { var t = on.prototype.toJSON.call(this, e);
                    t.object.levels = []; for (var i = this.levels, n = 0, r = i.length; n < r; n++) { var a = i[n];
                        t.object.levels.push({ object: a.object.uuid, distance: a.distance }) } return t } }), Do.prototype = Object.assign(Object.create(Tr.prototype), { constructor: Do, isSkinnedMesh: !0, bind: function(e, t) { this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t) }, pose: function() { this.skeleton.pose() }, normalizeSkinWeights: function() { for (var e = new pi, t = this.geometry.attributes.skinWeight, i = 0, n = t.count; i < n; i++) { e.x = t.getX(i), e.y = t.getY(i), e.z = t.getZ(i), e.w = t.getW(i); var r = 1 / e.manhattanLength();
                        r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w) } }, updateMatrixWorld: function(e) { Tr.prototype.updateMatrixWorld.call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, clone: function() { return new this.constructor(this.geometry, this.material).copy(this) } }), Object.assign(Io.prototype, { calculateInverses: function() { this.boneInverses = []; for (var e = 0, t = this.bones.length; e < t; e++) { var i = new jt;
                        this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i) } }, pose: function() { var e, t, i; for (t = 0, i = this.bones.length; t < i; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]); for (t = 0, i = this.bones.length; t < i; t++)(e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale)) }, update: (lo = new jt, co = new jt, function() { for (var e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, a = e.length; r < a; r++) { var o = e[r] ? e[r].matrixWorld : co;
                        lo.multiplyMatrices(o, t[r]), lo.toArray(i, 16 * r) }
                    void 0 !== n && (n.needsUpdate = !0) }), clone: function() { return new Io(this.bones, this.boneInverses) }, getBoneByName: function(e) { for (var t = 0, i = this.bones.length; t < i; t++) { var n = this.bones[t]; if (n.name === e) return n } } }), Bo.prototype = Object.assign(Object.create(on.prototype), { constructor: Bo, isBone: !0 }), ((No.prototype = Object.create(Wn.prototype)).constructor = No).prototype.isLineBasicMaterial = !0, No.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this }, Fo.prototype = Object.assign(Object.create(on.prototype), { constructor: Fo, isLine: !0, computeLineDistances: (fo = new Xt, mo = new Xt, function() { var e = this.geometry; if (e.isBufferGeometry)
                        if (null === e.index) { for (var t = e.attributes.position, i = [0], n = 1, r = t.count; n < r; n++) fo.fromBufferAttribute(t, n - 1), mo.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += fo.distanceTo(mo);
                            e.addAttribute("lineDistance", new wn(i, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (e.isGeometry) { var a = e.vertices; for ((i = e.lineDistances)[0] = 0, n = 1, r = a.length; n < r; n++) i[n] = i[n - 1], i[n] += a[n - 1].distanceTo(a[n]) } return this }), raycast: (ho = new jt, uo = new br, po = new yi, function(e, t) { var i = e.linePrecision,
                        n = this.geometry,
                        r = this.matrixWorld; if (null === n.boundingSphere && n.computeBoundingSphere(), po.copy(n.boundingSphere), po.applyMatrix4(r), po.radius += i, !1 !== e.ray.intersectsSphere(po)) { ho.getInverse(r), uo.copy(e.ray).applyMatrix4(ho); var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            o = a * a,
                            s = new Xt,
                            l = new Xt,
                            c = new Xt,
                            h = new Xt,
                            u = this && this.isLineSegments ? 2 : 1; if (n.isBufferGeometry) { var d = n.index,
                                p = n.attributes.position.array; if (null !== d)
                                for (var f = d.array, m = 0, g = f.length - 1; m < g; m += u) { var v = f[m],
                                        M = f[m + 1];
                                    s.fromArray(p, 3 * v), l.fromArray(p, 3 * M), o < uo.distanceSqToSegment(s, l, h, c) || (h.applyMatrix4(this.matrixWorld), (_ = e.ray.origin.distanceTo(h)) < e.near || _ > e.far || t.push({ distance: _, point: c.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this })) } else
                                    for (m = 0, g = p.length / 3 - 1; m < g; m += u) s.fromArray(p, 3 * m), l.fromArray(p, 3 * m + 3), o < uo.distanceSqToSegment(s, l, h, c) || (h.applyMatrix4(this.matrixWorld), (_ = e.ray.origin.distanceTo(h)) < e.near || _ > e.far || t.push({ distance: _, point: c.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this })) } else if (n.isGeometry) { var y = n.vertices,
                                b = y.length; for (m = 0; m < b - 1; m += u) { var _;
                                o < uo.distanceSqToSegment(y[m], y[m + 1], h, c) || (h.applyMatrix4(this.matrixWorld), (_ = e.ray.origin.distanceTo(h)) < e.near || _ > e.far || t.push({ distance: _, point: c.clone().applyMatrix4(this.matrixWorld), index: m, face: null, faceIndex: null, object: this })) } } } }), copy: function(e) { return on.prototype.copy.call(this, e), this.geometry.copy(e.geometry), this.material.copy(e.material), this }, clone: function() { return (new this.constructor).copy(this) } }), zo.prototype = Object.assign(Object.create(Fo.prototype), { constructor: zo, isLineSegments: !0, computeLineDistances: (go = new Xt, vo = new Xt, function() { var e = this.geometry; if (e.isBufferGeometry)
                        if (null === e.index) { for (var t = e.attributes.position, i = [], n = 0, r = t.count; n < r; n += 2) go.fromBufferAttribute(t, n), vo.fromBufferAttribute(t, n + 1), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + go.distanceTo(vo);
                            e.addAttribute("lineDistance", new wn(i, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else if (e.isGeometry) { var a = e.vertices; for (i = e.lineDistances, n = 0, r = a.length; n < r; n += 2) go.copy(a[n]), vo.copy(a[n + 1]), i[n] = 0 === n ? 0 : i[n - 1], i[n + 1] = i[n] + go.distanceTo(vo) } return this }) }), ko.prototype = Object.assign(Object.create(Fo.prototype), { constructor: ko, isLineLoop: !0 }), ((Uo.prototype = Object.create(Wn.prototype)).constructor = Uo).prototype.isPointsMaterial = !0, Uo.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.morphTargets = e.morphTargets, this }, Vo.prototype = Object.assign(Object.create(on.prototype), { constructor: Vo, isPoints: !0, raycast: (Mo = new jt, yo = new br, bo = new yi, function(r, a) { var o = this,
                        e = this.geometry,
                        s = this.matrixWorld,
                        t = r.params.Points.threshold; if (null === e.boundingSphere && e.computeBoundingSphere(), bo.copy(e.boundingSphere), bo.applyMatrix4(s), bo.radius += t, !1 !== r.ray.intersectsSphere(bo)) { Mo.getInverse(s), yo.copy(r.ray).applyMatrix4(Mo); var i = t / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            l = i * i,
                            n = new Xt,
                            c = new Xt; if (e.isBufferGeometry) { var h = e.index,
                                u = e.attributes.position.array; if (null !== h)
                                for (var d = h.array, p = 0, f = d.length; p < f; p++) { var m = d[p];
                                    n.fromArray(u, 3 * m), M(n, m) } else { p = 0; for (var g = u.length / 3; p < g; p++) n.fromArray(u, 3 * p), M(n, p) } } else { var v = e.vertices; for (p = 0, g = v.length; p < g; p++) M(v[p], p) } }

                    function M(e, t) { var i = yo.distanceSqToPoint(e); if (i < l) { yo.closestPointToPoint(e, c), c.applyMatrix4(s); var n = r.ray.origin.distanceTo(c); if (n < r.near || n > r.far) return;
                            a.push({ distance: n, distanceToRay: Math.sqrt(i), point: c.clone(), index: t, face: null, object: o }) } } }), clone: function() { return new this.constructor(this.geometry, this.material).copy(this) } }), jo.prototype = Object.assign(Object.create(di.prototype), { constructor: jo, isVideoTexture: !0, update: function() { var e = this.image;
                    e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), ((Wo.prototype = Object.create(di.prototype)).constructor = Wo).prototype.isCompressedTexture = !0, ((Xo.prototype = Object.create(di.prototype)).constructor = Xo).prototype.isCanvasTexture = !0, ((Yo.prototype = Object.create(di.prototype)).constructor = Yo).prototype.isDepthTexture = !0, (qo.prototype = Object.create(Fn.prototype)).constructor = qo, (Zo.prototype = Object.create(mn.prototype)).constructor = Zo, (Jo.prototype = Object.create(Fn.prototype)).constructor = Jo, (Ko.prototype = Object.create(mn.prototype)).constructor = Ko, (Qo.prototype = Object.create(Fn.prototype)).constructor = Qo, ($o.prototype = Object.create(mn.prototype)).constructor = $o, (es.prototype = Object.create(Qo.prototype)).constructor = es, (ts.prototype = Object.create(mn.prototype)).constructor = ts, (is.prototype = Object.create(Qo.prototype)).constructor = is, (ns.prototype = Object.create(mn.prototype)).constructor = ns, (rs.prototype = Object.create(Qo.prototype)).constructor = rs, (as.prototype = Object.create(mn.prototype)).constructor = as, (os.prototype = Object.create(Qo.prototype)).constructor = os, (ss.prototype = Object.create(mn.prototype)).constructor = ss, ((ls.prototype = Object.create(Fn.prototype)).constructor = ls).prototype.toJSON = function() { var e = Fn.prototype.toJSON.call(this); return e.path = this.parameters.path.toJSON(), e }, (cs.prototype = Object.create(mn.prototype)).constructor = cs, (hs.prototype = Object.create(Fn.prototype)).constructor = hs, (us.prototype = Object.create(mn.prototype)).constructor = us, (ds.prototype = Object.create(Fn.prototype)).constructor = ds; var ps = function(e, t, i) { i = i || 2; var n, r, a, o, s, l, c, h = t && t.length,
                    u = h ? t[0] * i : e.length,
                    d = fs(e, 0, u, i, !0),
                    p = []; if (!d) return p; if (h && (d = function(e, t, i, n) { var r, a, o, s, l, c = []; for (r = 0, a = t.length; r < a; r++) o = t[r] * n, s = r < a - 1 ? t[r + 1] * n : e.length, (l = fs(e, o, s, n, !1)) === l.next && (l.steiner = !0), c.push(ws(l)); for (c.sort(_s), r = 0; r < c.length; r++) xs(c[r], i), i = ms(i, i.next); return i }(e, t, d, i)), e.length > 80 * i) { n = a = e[0], r = o = e[1]; for (var f = i; f < u; f += i)(s = e[f]) < n && (n = s), (l = e[f + 1]) < r && (r = l), a < s && (a = s), o < l && (o = l);
                    c = 0 !== (c = Math.max(a - n, o - r)) ? 1 / c : 0 } return gs(d, p, i, n, r, c), p };

            function fs(e, t, i, n, r) { var a, o; if (r === 0 < function(e, t, i, n) { for (var r = 0, a = t, o = i - n; a < i; a += n) r += (e[o] - e[a]) * (e[a + 1] + e[o + 1]), o = a; return r }(e, t, i, n))
                    for (a = t; a < i; a += n) o = Rs(a, e[a], e[a + 1], o);
                else
                    for (a = i - n; t <= a; a -= n) o = Rs(a, e[a], e[a + 1], o); return o && Ps(o, o.next) && (Hs(o), o = o.next), o }

            function ms(e, t) { if (!e) return e;
                t || (t = e); var i, n = e;
                do { if (i = !1, n.steiner || !Ps(n, n.next) && 0 !== Es(n.prev, n, n.next)) n = n.next;
                    else { if (Hs(n), (n = t = n.prev) === n.next) break;
                        i = !0 } } while (i || n !== t); return t }

            function gs(e, t, i, n, r, a, o) { if (e) {!o && a && function(e, t, i, n) { var r = e; for (; null === r.z && (r.z = Ts(r.x, r.y, t, i, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next, r !== e;);
                        r.prevZ.nextZ = null, r.prevZ = null,
                            function(e) { var t, i, n, r, a, o, s, l, c = 1;
                                do { for (i = e, a = e = null, o = 0; i;) { for (o++, n = i, t = s = 0; t < c && (s++, n = n.nextZ); t++); for (l = c; 0 < s || 0 < l && n;) 0 !== s && (0 === l || !n || i.z <= n.z) ? (i = (r = i).nextZ, s--) : (n = (r = n).nextZ, l--), a ? a.nextZ = r : e = r, r.prevZ = a, a = r;
                                        i = n }
                                    a.nextZ = null, c *= 2 } while (1 < o) }(r) }(e, n, r, a); for (var s, l, c = e; e.prev !== e.next;)
                        if (s = e.prev, l = e.next, a ? Ms(e, n, r, a) : vs(e)) t.push(s.i / i), t.push(e.i / i), t.push(l.i / i), Hs(e), e = l.next, c = l.next;
                        else if ((e = l) === c) { o ? 1 === o ? gs(e = ys(e, t, i), t, i, n, r, a, 2) : 2 === o && bs(e, t, i, n, r, a) : gs(ms(e), t, i, n, r, a, 1); break } } }

            function vs(e) { var t = e.prev,
                    i = e,
                    n = e.next; if (0 <= Es(t, i, n)) return !1; for (var r = e.next.next; r !== e.prev;) { if (Ss(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) && 0 <= Es(r.prev, r, r.next)) return !1;
                    r = r.next } return !0 }

            function Ms(e, t, i, n) { var r = e.prev,
                    a = e,
                    o = e.next; if (0 <= Es(r, a, o)) return !1; for (var s = r.x < a.x ? r.x < o.x ? r.x : o.x : a.x < o.x ? a.x : o.x, l = r.y < a.y ? r.y < o.y ? r.y : o.y : a.y < o.y ? a.y : o.y, c = r.x > a.x ? r.x > o.x ? r.x : o.x : a.x > o.x ? a.x : o.x, h = r.y > a.y ? r.y > o.y ? r.y : o.y : a.y > o.y ? a.y : o.y, u = Ts(s, l, t, i, n), d = Ts(c, h, t, i, n), p = e.nextZ; p && p.z <= d;) { if (p !== e.prev && p !== e.next && Ss(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= Es(p.prev, p, p.next)) return !1;
                    p = p.nextZ } for (p = e.prevZ; p && p.z >= u;) { if (p !== e.prev && p !== e.next && Ss(r.x, r.y, a.x, a.y, o.x, o.y, p.x, p.y) && 0 <= Es(p.prev, p, p.next)) return !1;
                    p = p.prevZ } return !0 }

            function ys(e, t, i) { var n = e;
                do { var r = n.prev,
                        a = n.next.next;!Ps(r, a) && As(r, n, n.next, a) && Cs(r, a) && Cs(a, r) && (t.push(r.i / i), t.push(n.i / i), t.push(a.i / i), Hs(n), Hs(n.next), n = e = a), n = n.next } while (n !== e); return n }

            function bs(e, t, i, n, r, a) { var o, s, l = e;
                do { for (var c = l.next.next; c !== l.prev;) { if (l.i !== c.i && (s = c, (o = l).next.i !== s.i && o.prev.i !== s.i && ! function(e, t) { var i = e;
                                do { if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && As(i, i.next, e, t)) return !0;
                                    i = i.next } while (i !== e); return !1 }(o, s) && Cs(o, s) && Cs(s, o) && function(e, t) { var i = e,
                                    n = !1,
                                    r = (e.x + t.x) / 2,
                                    a = (e.y + t.y) / 2; for (; i.y > a != i.next.y > a && i.next.y !== i.y && r < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next, i !== e;); return n }(o, s))) { var h = Ls(l, c); return l = ms(l, l.next), h = ms(h, h.next), gs(l, t, i, n, r, a), void gs(h, t, i, n, r, a) }
                        c = c.next }
                    l = l.next } while (l !== e) }

            function _s(e, t) { return e.x - t.x }

            function xs(e, t) { if (t = function(e, t) { var i, n = t,
                            r = e.x,
                            a = e.y,
                            o = -1 / 0;
                        do { if (a <= n.y && a >= n.next.y && n.next.y !== n.y) { var s = n.x + (a - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (s <= r && o < s) { if ((o = s) === r) { if (a === n.y) return n; if (a === n.next.y) return n.next }
                                    i = n.x < n.next.x ? n : n.next } }
                            n = n.next } while (n !== t); if (!i) return null; if (r === o) return i.prev; var l, c = i,
                            h = i.x,
                            u = i.y,
                            d = 1 / 0;
                        n = i.next; for (; n !== c;) r >= n.x && n.x >= h && r !== n.x && Ss(a < u ? r : o, a, h, u, a < u ? o : r, a, n.x, n.y) && ((l = Math.abs(a - n.y) / (r - n.x)) < d || l === d && n.x > i.x) && Cs(n, e) && (i = n, d = l), n = n.next; return i }(e, t)) { var i = Ls(t, e);
                    ms(i, i.next) } }

            function Ts(e, t, i, n, r) { return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1 }

            function ws(e) { for (var t = e, i = e; t.x < i.x && (i = t), (t = t.next) !== e;); return i }

            function Ss(e, t, i, n, r, a, o, s) { return 0 <= (r - o) * (t - s) - (e - o) * (a - s) && 0 <= (e - o) * (n - s) - (i - o) * (t - s) && 0 <= (i - o) * (a - s) - (r - o) * (n - s) }

            function Es(e, t, i) { return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y) }

            function Ps(e, t) { return e.x === t.x && e.y === t.y }

            function As(e, t, i, n) { return !!(Ps(e, t) && Ps(i, n) || Ps(e, n) && Ps(i, t)) || 0 < Es(e, t, i) != 0 < Es(e, t, n) && 0 < Es(i, n, e) != 0 < Es(i, n, t) }

            function Cs(e, t) { return Es(e.prev, e, e.next) < 0 ? 0 <= Es(e, t, e.next) && 0 <= Es(e, e.prev, t) : Es(e, t, e.prev) < 0 || Es(e, e.next, t) < 0 }

            function Ls(e, t) { var i = new Os(e.i, e.x, e.y),
                    n = new Os(t.i, t.x, t.y),
                    r = e.next,
                    a = t.prev; return (e.next = t).prev = e, (i.next = r).prev = i, (n.next = i).prev = n, (a.next = n).prev = a, n }

            function Rs(e, t, i, n) { var r = new Os(e, t, i); return n ? (r.next = n.next, (r.prev = n).next.prev = r, n.next = r) : (r.prev = r).next = r, r }

            function Hs(e) { e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ) }

            function Os(e, t, i) { this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 } var Gs = { area: function(e) { for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++) i += e[n].x * e[r].y - e[r].x * e[n].y; return .5 * i }, isClockWise: function(e) { return Gs.area(e) < 0 }, triangulateShape: function(e, t) { var i = [],
                        n = [],
                        r = [];
                    Ds(e), Is(i, e); var a = e.length;
                    t.forEach(Ds); for (var o = 0; o < t.length; o++) n.push(a), a += t[o].length, Is(i, t[o]); var s = ps(i, n); for (o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3)); return r } };

            function Ds(e) { var t = e.length;
                2 < t && e[t - 1].equals(e[0]) && e.pop() }

            function Is(e, t) { for (var i = 0; i < t.length; i++) e.push(t[i].x), e.push(t[i].y) }

            function Bs(e, t) { mn.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, this.fromBufferGeometry(new Ns(e, t)), this.mergeVertices() }

            function Ns(e, J) { Fn.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: e, options: J }, e = Array.isArray(e) ? e : [e]; for (var K = this, Q = [], $ = [], t = 0, i = e.length; t < i; t++) { n(e[t]) }

                function n(e) { var n = [],
                        t = void 0 !== J.curveSegments ? J.curveSegments : 12,
                        l = void 0 !== J.steps ? J.steps : 1,
                        i = void 0 !== J.depth ? J.depth : 100,
                        r = void 0 === J.bevelEnabled || J.bevelEnabled,
                        a = void 0 !== J.bevelThickness ? J.bevelThickness : 6,
                        o = void 0 !== J.bevelSize ? J.bevelSize : a - 2,
                        c = void 0 !== J.bevelSegments ? J.bevelSegments : 3,
                        s = J.extrudePath,
                        h = void 0 !== J.UVGenerator ? J.UVGenerator : Fs;
                    void 0 !== J.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), i = J.amount); var u, d, p, f, m, g, v, M, y = !1;
                    s && (u = s.getSpacedPoints(l), r = !(y = !0), d = s.computeFrenetFrames(l, !1), p = new Xt, f = new Xt, m = new Xt), r || (o = a = c = 0); var b = e.extractPoints(t),
                        _ = b.shape,
                        x = b.holes; if (!Gs.isClockWise(_))
                        for (_ = _.reverse(), v = 0, M = x.length; v < M; v++) g = x[v], Gs.isClockWise(g) && (x[v] = g.reverse()); var T = Gs.triangulateShape(_, x),
                        w = _; for (v = 0, M = x.length; v < M; v++) g = x[v], _ = _.concat(g);

                    function S(e, t, i) { return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e) } var E, P, A, C, L, R, H = _.length,
                        O = T.length;

                    function G(e, t, i) { var n, r, a, o = e.x - t.x,
                            s = e.y - t.y,
                            l = i.x - e.x,
                            c = i.y - e.y,
                            h = o * o + s * s,
                            u = o * c - s * l; if (Math.abs(u) > Number.EPSILON) { var d = Math.sqrt(h),
                                p = Math.sqrt(l * l + c * c),
                                f = t.x - s / d,
                                m = t.y + o / d,
                                g = ((i.x - c / p - f) * c - (i.y + l / p - m) * l) / (o * c - s * l),
                                v = (n = f + o * g - e.x) * n + (r = m + s * g - e.y) * r; if (v <= 2) return new Vt(n, r);
                            a = Math.sqrt(v / 2) } else { var M = !1;
                            o > Number.EPSILON ? l > Number.EPSILON && (M = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (M = !0) : Math.sign(s) === Math.sign(c) && (M = !0), a = M ? (n = -s, r = o, Math.sqrt(h)) : (n = o, r = s, Math.sqrt(h / 2)) } return new Vt(n / a, r / a) } for (var D = [], I = 0, B = w.length, N = B - 1, F = I + 1; I < B; I++, N++, F++) N === B && (N = 0), F === B && (F = 0), D[I] = G(w[I], w[N], w[F]); var z, k, U = [],
                        V = D.concat(); for (v = 0, M = x.length; v < M; v++) { for (g = x[v], z = [], I = 0, N = (B = g.length) - 1, F = I + 1; I < B; I++, N++, F++) N === B && (N = 0), F === B && (F = 0), z[I] = G(g[I], g[N], g[F]);
                        U.push(z), V = V.concat(z) } for (E = 0; E < c; E++) { for (A = E / c, C = a * Math.cos(A * Math.PI / 2), P = o * Math.sin(A * Math.PI / 2), I = 0, B = w.length; I < B; I++) W((L = S(w[I], D[I], P)).x, L.y, -C); for (v = 0, M = x.length; v < M; v++)
                            for (g = x[v], z = U[v], I = 0, B = g.length; I < B; I++) W((L = S(g[I], z[I], P)).x, L.y, -C) } for (P = o, I = 0; I < H; I++) L = r ? S(_[I], V[I], P) : _[I], y ? (f.copy(d.normals[0]).multiplyScalar(L.x), p.copy(d.binormals[0]).multiplyScalar(L.y), m.copy(u[0]).add(f).add(p), W(m.x, m.y, m.z)) : W(L.x, L.y, 0); for (k = 1; k <= l; k++)
                        for (I = 0; I < H; I++) L = r ? S(_[I], V[I], P) : _[I], y ? (f.copy(d.normals[k]).multiplyScalar(L.x), p.copy(d.binormals[k]).multiplyScalar(L.y), m.copy(u[k]).add(f).add(p), W(m.x, m.y, m.z)) : W(L.x, L.y, i / l * k); for (E = c - 1; 0 <= E; E--) { for (A = E / c, C = a * Math.cos(A * Math.PI / 2), P = o * Math.sin(A * Math.PI / 2), I = 0, B = w.length; I < B; I++) W((L = S(w[I], D[I], P)).x, L.y, i + C); for (v = 0, M = x.length; v < M; v++)
                            for (g = x[v], z = U[v], I = 0, B = g.length; I < B; I++) L = S(g[I], z[I], P), y ? W(L.x, L.y + u[l - 1].y, u[l - 1].x + C) : W(L.x, L.y, i + C) }

                    function j(e, t) { var i, n; for (I = e.length; 0 <= --I;) {
                            (n = (i = I) - 1) < 0 && (n = e.length - 1); var r = 0,
                                a = l + 2 * c; for (r = 0; r < a; r++) { var o = H * r,
                                    s = H * (r + 1);
                                Y(t + i + o, t + n + o, t + n + s, t + i + s) } } }

                    function W(e, t, i) { n.push(e), n.push(t), n.push(i) }

                    function X(e, t, i) { q(e), q(t), q(i); var n = Q.length / 3,
                            r = h.generateTopUV(K, Q, n - 3, n - 2, n - 1);
                        Z(r[0]), Z(r[1]), Z(r[2]) }

                    function Y(e, t, i, n) { q(e), q(t), q(n), q(t), q(i), q(n); var r = Q.length / 3,
                            a = h.generateSideWallUV(K, Q, r - 6, r - 3, r - 2, r - 1);
                        Z(a[0]), Z(a[1]), Z(a[3]), Z(a[1]), Z(a[2]), Z(a[3]) }

                    function q(e) { Q.push(n[3 * e + 0]), Q.push(n[3 * e + 1]), Q.push(n[3 * e + 2]) }

                    function Z(e) { $.push(e.x), $.push(e.y) }! function() { var e = Q.length / 3; if (r) { var t = 0,
                                i = H * t; for (I = 0; I < O; I++) X((R = T[I])[2] + i, R[1] + i, R[0] + i); for (i = H * (t = l + 2 * c), I = 0; I < O; I++) X((R = T[I])[0] + i, R[1] + i, R[2] + i) } else { for (I = 0; I < O; I++) X((R = T[I])[2], R[1], R[0]); for (I = 0; I < O; I++) X((R = T[I])[0] + H * l, R[1] + H * l, R[2] + H * l) }
                        K.addGroup(e, Q.length / 3 - e, 0) }(),
                    function() { var e = Q.length / 3,
                            t = 0; for (j(w, t), t += w.length, v = 0, M = x.length; v < M; v++) j(g = x[v], t), t += g.length;
                        K.addGroup(e, Q.length / 3 - e, 1) }() }
                this.addAttribute("position", new wn(Q, 3)), this.addAttribute("uv", new wn($, 2)), this.computeVertexNormals() }((Bs.prototype = Object.create(mn.prototype)).constructor = Bs).prototype.toJSON = function() { var e = mn.prototype.toJSON.call(this); return zs(this.parameters.shapes, this.parameters.options, e) }, ((Ns.prototype = Object.create(Fn.prototype)).constructor = Ns).prototype.toJSON = function() { var e = Fn.prototype.toJSON.call(this); return zs(this.parameters.shapes, this.parameters.options, e) }; var Fs = { generateTopUV: function(e, t, i, n, r) { var a = t[3 * i],
                        o = t[3 * i + 1],
                        s = t[3 * n],
                        l = t[3 * n + 1],
                        c = t[3 * r],
                        h = t[3 * r + 1]; return [new Vt(a, o), new Vt(s, l), new Vt(c, h)] }, generateSideWallUV: function(e, t, i, n, r, a) { var o = t[3 * i],
                        s = t[3 * i + 1],
                        l = t[3 * i + 2],
                        c = t[3 * n],
                        h = t[3 * n + 1],
                        u = t[3 * n + 2],
                        d = t[3 * r],
                        p = t[3 * r + 1],
                        f = t[3 * r + 2],
                        m = t[3 * a],
                        g = t[3 * a + 1],
                        v = t[3 * a + 2]; return Math.abs(s - h) < .01 ? [new Vt(o, 1 - l), new Vt(c, 1 - u), new Vt(d, 1 - f), new Vt(m, 1 - v)] : [new Vt(s, 1 - l), new Vt(h, 1 - u), new Vt(p, 1 - f), new Vt(g, 1 - v)] } };

            function zs(e, t, i) { if (i.shapes = [], Array.isArray(e))
                    for (var n = 0, r = e.length; n < r; n++) { var a = e[n];
                        i.shapes.push(a.uuid) } else i.shapes.push(e.uuid); return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()), i }

            function ks(e, t) { mn.call(this), this.type = "TextGeometry", this.parameters = { text: e, parameters: t }, this.fromBufferGeometry(new Us(e, t)), this.mergeVertices() }

            function Us(e, t) { var i = (t = t || {}).font; if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new mn; var n = i.generateShapes(e, t.size);
                t.depth = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), Ns.call(this, n, t), this.type = "TextBufferGeometry" }

            function Vs(e, t, i, n, r, a, o) { mn.call(this), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: n, phiLength: r, thetaStart: a, thetaLength: o }, this.fromBufferGeometry(new js(e, t, i, n, r, a, o)), this.mergeVertices() }

            function js(e, t, i, n, r, a, o) { Fn.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: n, phiLength: r, thetaStart: a, thetaLength: o }, e = e || 1, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI; var s, l, c = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI),
                    h = 0,
                    u = [],
                    d = new Xt,
                    p = new Xt,
                    f = [],
                    m = [],
                    g = [],
                    v = []; for (l = 0; l <= i; l++) { var M = [],
                        y = l / i; for (s = 0; s <= t; s++) { var b = s / t;
                        d.x = -e * Math.cos(n + b * r) * Math.sin(a + y * o), d.y = e * Math.cos(a + y * o), d.z = e * Math.sin(n + b * r) * Math.sin(a + y * o), m.push(d.x, d.y, d.z), p.set(d.x, d.y, d.z).normalize(), g.push(p.x, p.y, p.z), v.push(b, 1 - y), M.push(h++) }
                    u.push(M) } for (l = 0; l < i; l++)
                    for (s = 0; s < t; s++) { var _ = u[l][s + 1],
                            x = u[l][s],
                            T = u[l + 1][s],
                            w = u[l + 1][s + 1];
                        (0 !== l || 0 < a) && f.push(_, x, w), (l !== i - 1 || c < Math.PI) && f.push(x, T, w) }
                this.setIndex(f), this.addAttribute("position", new wn(m, 3)), this.addAttribute("normal", new wn(g, 3)), this.addAttribute("uv", new wn(v, 2)) }

            function Ws(e, t, i, n, r, a) { mn.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: n, thetaStart: r, thetaLength: a }, this.fromBufferGeometry(new Xs(e, t, i, n, r, a)), this.mergeVertices() }

            function Xs(e, t, i, n, r, a) { Fn.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: n, thetaStart: r, thetaLength: a }, e = e || .5, t = t || 1, r = void 0 !== r ? r : 0, a = void 0 !== a ? a : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8; var o, s, l, c = [],
                    h = [],
                    u = [],
                    d = [],
                    p = e,
                    f = (t - e) / (n = void 0 !== n ? Math.max(1, n) : 1),
                    m = new Xt,
                    g = new Vt; for (s = 0; s <= n; s++) { for (l = 0; l <= i; l++) o = r + l / i * a, m.x = p * Math.cos(o), m.y = p * Math.sin(o), h.push(m.x, m.y, m.z), u.push(0, 0, 1), g.x = (m.x / t + 1) / 2, g.y = (m.y / t + 1) / 2, d.push(g.x, g.y);
                    p += f } for (s = 0; s < n; s++) { var v = s * (i + 1); for (l = 0; l < i; l++) { var M = o = l + v,
                            y = o + i + 1,
                            b = o + i + 2,
                            _ = o + 1;
                        c.push(M, y, _), c.push(y, b, _) } }
                this.setIndex(c), this.addAttribute("position", new wn(h, 3)), this.addAttribute("normal", new wn(u, 3)), this.addAttribute("uv", new wn(d, 2)) }

            function Ys(e, t, i, n) { mn.call(this), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: n }, this.fromBufferGeometry(new qs(e, t, i, n)), this.mergeVertices() }

            function qs(e, t, i, n) { Fn.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: n }, t = Math.floor(t) || 12, i = i || 0, n = n || 2 * Math.PI, n = Ut.clamp(n, 0, 2 * Math.PI); var r, a, o, s = [],
                    l = [],
                    c = [],
                    h = 1 / t,
                    u = new Xt,
                    d = new Vt; for (a = 0; a <= t; a++) { var p = i + a * h * n,
                        f = Math.sin(p),
                        m = Math.cos(p); for (o = 0; o <= e.length - 1; o++) u.x = e[o].x * f, u.y = e[o].y, u.z = e[o].x * m, l.push(u.x, u.y, u.z), d.x = a / t, d.y = o / (e.length - 1), c.push(d.x, d.y) } for (a = 0; a < t; a++)
                    for (o = 0; o < e.length - 1; o++) { var g = r = o + a * e.length,
                            v = r + e.length,
                            M = r + e.length + 1,
                            y = r + 1;
                        s.push(g, v, y), s.push(v, M, y) }
                if (this.setIndex(s), this.addAttribute("position", new wn(l, 3)), this.addAttribute("uv", new wn(c, 2)), this.computeVertexNormals(), n === 2 * Math.PI) { var b = this.attributes.normal.array,
                        _ = new Xt,
                        x = new Xt,
                        T = new Xt; for (r = t * e.length * 3, o = a = 0; a < e.length; a++, o += 3) _.x = b[o + 0], _.y = b[o + 1], _.z = b[o + 2], x.x = b[r + o + 0], x.y = b[r + o + 1], x.z = b[r + o + 2], T.addVectors(_, x).normalize(), b[o + 0] = b[r + o + 0] = T.x, b[o + 1] = b[r + o + 1] = T.y, b[o + 2] = b[r + o + 2] = T.z } }

            function Zs(e, t) { mn.call(this), this.type = "ShapeGeometry", "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), t = t.curveSegments), this.parameters = { shapes: e, curveSegments: t }, this.fromBufferGeometry(new Js(e, t)), this.mergeVertices() }

            function Js(e, f) { Fn.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: e, curveSegments: f }, f = f || 12; var m = [],
                    g = [],
                    v = [],
                    M = [],
                    t = 0,
                    y = 0; if (!1 === Array.isArray(e)) n(e);
                else
                    for (var i = 0; i < e.length; i++) n(e[i]), this.addGroup(t, y, i), t += y, y = 0;

                function n(e) { var t, i, n, r = g.length / 3,
                        a = e.extractPoints(f),
                        o = a.shape,
                        s = a.holes; for (!1 === Gs.isClockWise(o) && (o = o.reverse()), t = 0, i = s.length; t < i; t++) n = s[t], !0 === Gs.isClockWise(n) && (s[t] = n.reverse()); var l = Gs.triangulateShape(o, s); for (t = 0, i = s.length; t < i; t++) n = s[t], o = o.concat(n); for (t = 0, i = o.length; t < i; t++) { var c = o[t];
                        g.push(c.x, c.y, 0), v.push(0, 0, 1), M.push(c.x, c.y) } for (t = 0, i = l.length; t < i; t++) { var h = l[t],
                            u = h[0] + r,
                            d = h[1] + r,
                            p = h[2] + r;
                        m.push(u, d, p), y += 3 } }
                this.setIndex(m), this.addAttribute("position", new wn(g, 3)), this.addAttribute("normal", new wn(v, 3)), this.addAttribute("uv", new wn(M, 2)) }

            function Ks(e, t) { if (t.shapes = [], Array.isArray(e))
                    for (var i = 0, n = e.length; i < n; i++) { var r = e[i];
                        t.shapes.push(r.uuid) } else t.shapes.push(e.uuid); return t }

            function Qs(e, t) { Fn.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: t }, t = void 0 !== t ? t : 1; var i, n, r, a, o = [],
                    s = Math.cos(Ut.DEG2RAD * t),
                    l = [0, 0],
                    c = {},
                    h = ["a", "b", "c"];
                e.isBufferGeometry ? (a = new mn).fromBufferGeometry(e) : a = e.clone(), a.mergeVertices(), a.computeFaceNormals(); for (var u = a.vertices, d = a.faces, p = 0, f = d.length; p < f; p++)
                    for (var m = d[p], g = 0; g < 3; g++) i = m[h[g]], n = m[h[(g + 1) % 3]], l[0] = Math.min(i, n), l[1] = Math.max(i, n), void 0 === c[r = l[0] + "," + l[1]] ? c[r] = { index1: l[0], index2: l[1], face1: p, face2: void 0 } : c[r].face2 = p; for (r in c) { var v = c[r]; if (void 0 === v.face2 || d[v.face1].normal.dot(d[v.face2].normal) <= s) { var M = u[v.index1];
                        o.push(M.x, M.y, M.z), M = u[v.index2], o.push(M.x, M.y, M.z) } }
                this.addAttribute("position", new wn(o, 3)) }

            function $s(e, t, i, n, r, a, o, s) { mn.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: n, heightSegments: r, openEnded: a, thetaStart: o, thetaLength: s }, this.fromBufferGeometry(new el(e, t, i, n, r, a, o, s)), this.mergeVertices() }

            function el(v, M, y, b, _, e, x, T) { Fn.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: v, radiusBottom: M, height: y, radialSegments: b, heightSegments: _, openEnded: e, thetaStart: x, thetaLength: T }; var w = this;
                v = void 0 !== v ? v : 1, M = void 0 !== M ? M : 1, y = y || 1, b = Math.floor(b) || 8, _ = Math.floor(_) || 1, e = void 0 !== e && e, x = void 0 !== x ? x : 0, T = void 0 !== T ? T : 2 * Math.PI; var S = [],
                    E = [],
                    P = [],
                    A = [],
                    C = 0,
                    L = [],
                    R = y / 2,
                    H = 0;

                function t(e) { var t, i, n, r = new Vt,
                        a = new Xt,
                        o = 0,
                        s = !0 === e ? v : M,
                        l = !0 === e ? 1 : -1; for (i = C, t = 1; t <= b; t++) E.push(0, R * l, 0), P.push(0, l, 0), A.push(.5, .5), C++; for (n = C, t = 0; t <= b; t++) { var c = t / b * T + x,
                            h = Math.cos(c),
                            u = Math.sin(c);
                        a.x = s * u, a.y = R * l, a.z = s * h, E.push(a.x, a.y, a.z), P.push(0, l, 0), r.x = .5 * h + .5, r.y = .5 * u * l + .5, A.push(r.x, r.y), C++ } for (t = 0; t < b; t++) { var d = i + t,
                            p = n + t;!0 === e ? S.push(p, p + 1, d) : S.push(p + 1, p, d), o += 3 }
                    w.addGroup(H, o, !0 === e ? 1 : 2), H += o }! function() { var e, t, i = new Xt,
                        n = new Xt,
                        r = 0,
                        a = (M - v) / y; for (t = 0; t <= _; t++) { var o = [],
                            s = t / _,
                            l = s * (M - v) + v; for (e = 0; e <= b; e++) { var c = e / b,
                                h = c * T + x,
                                u = Math.sin(h),
                                d = Math.cos(h);
                            n.x = l * u, n.y = -s * y + R, n.z = l * d, E.push(n.x, n.y, n.z), i.set(u, a, d).normalize(), P.push(i.x, i.y, i.z), A.push(c, 1 - s), o.push(C++) }
                        L.push(o) } for (e = 0; e < b; e++)
                        for (t = 0; t < _; t++) { var p = L[t][e],
                                f = L[t + 1][e],
                                m = L[t + 1][e + 1],
                                g = L[t][e + 1];
                            S.push(p, f, g), S.push(f, m, g), r += 6 }
                    w.addGroup(H, r, 0), H += r }(), !1 === e && (0 < v && t(!0), 0 < M && t(!1)), this.setIndex(S), this.addAttribute("position", new wn(E, 3)), this.addAttribute("normal", new wn(P, 3)), this.addAttribute("uv", new wn(A, 2)) }

            function tl(e, t, i, n, r, a, o) { $s.call(this, 0, e, t, i, n, r, a, o), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: n, openEnded: r, thetaStart: a, thetaLength: o } }

            function il(e, t, i, n, r, a, o) { el.call(this, 0, e, t, i, n, r, a, o), this.type = "ConeBufferGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: n, openEnded: r, thetaStart: a, thetaLength: o } }

            function nl(e, t, i, n) { mn.call(this), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: n }, this.fromBufferGeometry(new rl(e, t, i, n)), this.mergeVertices() }

            function rl(e, t, i, n) { Fn.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: n }, e = e || 1, t = void 0 !== t ? Math.max(3, t) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI; var r, a, o = [],
                    s = [],
                    l = [],
                    c = [],
                    h = new Xt,
                    u = new Vt; for (s.push(0, 0, 0), l.push(0, 0, 1), c.push(.5, .5), a = 0, r = 3; a <= t; a++, r += 3) { var d = i + a / t * n;
                    h.x = e * Math.cos(d), h.y = e * Math.sin(d), s.push(h.x, h.y, h.z), l.push(0, 0, 1), u.x = (s[r] / e + 1) / 2, u.y = (s[r + 1] / e + 1) / 2, c.push(u.x, u.y) } for (r = 1; r <= t; r++) o.push(r, r + 1, 0);
                this.setIndex(o), this.addAttribute("position", new wn(s, 3)), this.addAttribute("normal", new wn(l, 3)), this.addAttribute("uv", new wn(c, 2)) }(ks.prototype = Object.create(mn.prototype)).constructor = ks, (Us.prototype = Object.create(Ns.prototype)).constructor = Us, (Vs.prototype = Object.create(mn.prototype)).constructor = Vs, (js.prototype = Object.create(Fn.prototype)).constructor = js, (Ws.prototype = Object.create(mn.prototype)).constructor = Ws, (Xs.prototype = Object.create(Fn.prototype)).constructor = Xs, (Ys.prototype = Object.create(mn.prototype)).constructor = Ys, (qs.prototype = Object.create(Fn.prototype)).constructor = qs, ((Zs.prototype = Object.create(mn.prototype)).constructor = Zs).prototype.toJSON = function() { var e = mn.prototype.toJSON.call(this); return Ks(this.parameters.shapes, e) }, ((Js.prototype = Object.create(Fn.prototype)).constructor = Js).prototype.toJSON = function() { var e = Fn.prototype.toJSON.call(this); return Ks(this.parameters.shapes, e) }, (Qs.prototype = Object.create(Fn.prototype)).constructor = Qs, ($s.prototype = Object.create(mn.prototype)).constructor = $s, (el.prototype = Object.create(Fn.prototype)).constructor = el, (tl.prototype = Object.create($s.prototype)).constructor = tl, (il.prototype = Object.create(el.prototype)).constructor = il, (nl.prototype = Object.create(mn.prototype)).constructor = nl, (rl.prototype = Object.create(Fn.prototype)).constructor = rl; var al = Object.freeze({ WireframeGeometry: qo, ParametricGeometry: Zo, ParametricBufferGeometry: Jo, TetrahedronGeometry: $o, TetrahedronBufferGeometry: es, OctahedronGeometry: ts, OctahedronBufferGeometry: is, IcosahedronGeometry: ns, IcosahedronBufferGeometry: rs, DodecahedronGeometry: as, DodecahedronBufferGeometry: os, PolyhedronGeometry: Ko, PolyhedronBufferGeometry: Qo, TubeGeometry: ss, TubeBufferGeometry: ls, TorusKnotGeometry: cs, TorusKnotBufferGeometry: hs, TorusGeometry: us, TorusBufferGeometry: ds, TextGeometry: ks, TextBufferGeometry: Us, SphereGeometry: Vs, SphereBufferGeometry: js, RingGeometry: Ws, RingBufferGeometry: Xs, PlaneGeometry: Un, PlaneBufferGeometry: Vn, LatheGeometry: Ys, LatheBufferGeometry: qs, ShapeGeometry: Zs, ShapeBufferGeometry: Js, ExtrudeGeometry: Bs, ExtrudeBufferGeometry: Ns, EdgesGeometry: Qs, ConeGeometry: tl, ConeBufferGeometry: il, CylinderGeometry: $s, CylinderBufferGeometry: el, CircleGeometry: nl, CircleBufferGeometry: rl, BoxGeometry: zn, BoxBufferGeometry: kn });

            function ol(e) { Wn.call(this), this.type = "ShadowMaterial", this.color = new Li(0), this.transparent = !0, this.setValues(e) }

            function sl(e) { yr.call(this, e), this.type = "RawShaderMaterial" }

            function ll(e) { Wn.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Li(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Li(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zt, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) }

            function cl(e) { ll.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(e) }

            function hl(e) { Wn.call(this), this.type = "MeshPhongMaterial", this.color = new Li(16777215), this.specular = new Li(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Li(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zt, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = j, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) }

            function ul(e) { hl.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(e) }

            function dl(e) { Wn.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zt, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) }

            function pl(e) { Wn.call(this), this.type = "MeshLambertMaterial", this.color = new Li(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Li(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = j, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e) }

            function fl(e) { Wn.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Li(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = zt, this.normalScale = new Vt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(e) }

            function ml(e) { No.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e) }((ol.prototype = Object.create(Wn.prototype)).constructor = ol).prototype.isShadowMaterial = !0, ol.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.color.copy(e.color), this }, ((sl.prototype = Object.create(yr.prototype)).constructor = sl).prototype.isRawShaderMaterial = !0, ((ll.prototype = Object.create(Wn.prototype)).constructor = ll).prototype.isMeshStandardMaterial = !0, ll.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, ((cl.prototype = Object.create(ll.prototype)).constructor = cl).prototype.isMeshPhysicalMaterial = !0, cl.prototype.copy = function(e) { return ll.prototype.copy.call(this, e), this.defines = { PHYSICAL: "" }, this.reflectivity = e.reflectivity, this.clearCoat = e.clearCoat, this.clearCoatRoughness = e.clearCoatRoughness, this }, ((hl.prototype = Object.create(Wn.prototype)).constructor = hl).prototype.isMeshPhongMaterial = !0, hl.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, ((ul.prototype = Object.create(hl.prototype)).constructor = ul).prototype.isMeshToonMaterial = !0, ul.prototype.copy = function(e) { return hl.prototype.copy.call(this, e), this.gradientMap = e.gradientMap, this }, ((dl.prototype = Object.create(Wn.prototype)).constructor = dl).prototype.isMeshNormalMaterial = !0, dl.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, ((pl.prototype = Object.create(Wn.prototype)).constructor = pl).prototype.isMeshLambertMaterial = !0, pl.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, ((fl.prototype = Object.create(Wn.prototype)).constructor = fl).prototype.isMeshMatcapMaterial = !0, fl.prototype.copy = function(e) { return Wn.prototype.copy.call(this, e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this }, ((ml.prototype = Object.create(No.prototype)).constructor = ml).prototype.isLineDashedMaterial = !0, ml.prototype.copy = function(e) { return No.prototype.copy.call(this, e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this }; var gl = Object.freeze({ ShadowMaterial: ol, SpriteMaterial: Ho, RawShaderMaterial: sl, ShaderMaterial: yr, PointsMaterial: Uo, MeshPhysicalMaterial: cl, MeshStandardMaterial: ll, MeshPhongMaterial: hl, MeshToonMaterial: ul, MeshNormalMaterial: dl, MeshLambertMaterial: pl, MeshDepthMaterial: qa, MeshDistanceMaterial: Za, MeshBasicMaterial: xr, MeshMatcapMaterial: fl, LineDashedMaterial: ml, LineBasicMaterial: No, Material: Wn }),
                vl = { arraySlice: function(e, t, i) { return vl.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i) }, convertArray: function(e, t, i) { return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e) }, isTypedArray: function(e) { return ArrayBuffer.isView(e) && !(e instanceof DataView) }, getKeyframeOrder: function(i) { for (var e = i.length, t = new Array(e), n = 0; n !== e; ++n) t[n] = n; return t.sort(function(e, t) { return i[e] - i[t] }), t }, sortedArray: function(e, t, i) { for (var n = e.length, r = new e.constructor(n), a = 0, o = 0; o !== n; ++a)
                            for (var s = i[a] * t, l = 0; l !== t; ++l) r[o++] = e[s + l]; return r }, flattenJSON: function(e, t, i, n) { for (var r = 1, a = e[0]; void 0 !== a && void 0 === a[n];) a = e[r++]; if (void 0 !== a) { var o = a[n]; if (void 0 !== o)
                                if (Array.isArray(o))
                                    for (; void 0 !== (o = a[n]) && (t.push(a.time), i.push.apply(i, o)), void 0 !== (a = e[r++]););
                                else if (void 0 !== o.toArray)
                                for (; void 0 !== (o = a[n]) && (t.push(a.time), o.toArray(i, i.length)), void 0 !== (a = e[r++]););
                            else
                                for (; void 0 !== (o = a[n]) && (t.push(a.time), i.push(o)), void 0 !== (a = e[r++]);); } } };

            function Ml(e, t, i, n) { this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i }

            function yl(e, t, i, n) { Ml.call(this, e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0 }

            function bl(e, t, i, n) { Ml.call(this, e, t, i, n) }

            function _l(e, t, i, n) { Ml.call(this, e, t, i, n) }

            function xl(e, t, i, n) { if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = vl.convertArray(t, this.TimeBufferType), this.values = vl.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation) }

            function Tl(e, t, i) { xl.call(this, e, t, i) }

            function wl(e, t, i, n) { xl.call(this, e, t, i, n) }

            function Sl(e, t, i, n) { xl.call(this, e, t, i, n) }

            function El(e, t, i, n) { Ml.call(this, e, t, i, n) }

            function Pl(e, t, i, n) { xl.call(this, e, t, i, n) }

            function Al(e, t, i, n) { xl.call(this, e, t, i, n) }

            function Cl(e, t, i, n) { xl.call(this, e, t, i, n) }

            function Ll(e, t, i) { this.name = e, this.tracks = i, this.duration = void 0 !== t ? t : -1, this.uuid = Ut.generateUUID(), this.duration < 0 && this.resetDuration() }

            function Rl(e) { if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); var t = function(e) { switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Sl;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return Cl;
                        case "color":
                            return wl;
                        case "quaternion":
                            return Pl;
                        case "bool":
                        case "boolean":
                            return Tl;
                        case "string":
                            return Al } throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e) }(e.type); if (void 0 === e.times) { var i = [],
                        n = [];
                    vl.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n } return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation) }
            Object.assign(Ml.prototype, { evaluate: function(e) { var t = this.parameterPositions,
                        i = this._cachedIndex,
                        n = t[i],
                        r = t[i - 1];
                    e: { t: { var a;i: { n: if (!(e < n)) { for (var o = i + 2;;) { if (void 0 === n) { if (e < r) break n; return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, e, r) } if (i === o) break; if (r = n, e < (n = t[++i])) break t }
                                    a = t.length; break i } if (r <= e) break e; var s = t[1];e < s && (i = 2, r = s); for (o = i - 2;;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, e, n); if (i === o) break; if (n = r, (r = t[--i - 1]) <= e) break t }
                                a = i, i = 0 } for (; i < a;) { var l = i + a >>> 1;
                                e < t[l] ? a = l : i = l + 1 } if (n = t[i], void 0 === (r = t[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, e, n); if (void 0 === n) return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, r, e) }
                        this._cachedIndex = i, this.intervalChanged_(i, r, n) }
                    return this.interpolate_(i, r, e, n) }, settings: null, DefaultSettings_: {}, getSettings_: function() { return this.settings || this.DefaultSettings_ }, copySampleValue_: function(e) { for (var t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, r = e * n, a = 0; a !== n; ++a) t[a] = i[r + a]; return t }, interpolate_: function() { throw new Error("call to abstract method") }, intervalChanged_: function() {} }), Object.assign(Ml.prototype, { beforeStart_: Ml.prototype.copySampleValue_, afterEnd_: Ml.prototype.copySampleValue_ }), yl.prototype = Object.assign(Object.create(Ml.prototype), { constructor: yl, DefaultSettings_: { endingStart: Pt, endingEnd: Pt }, intervalChanged_: function(e, t, i) { var n = this.parameterPositions,
                        r = e - 2,
                        a = e + 1,
                        o = n[r],
                        s = n[a]; if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case At:
                            r = e, o = 2 * t - i; break;
                        case Ct:
                            o = t + n[r = n.length - 2] - n[r + 1]; break;
                        default:
                            r = e, o = i }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case At:
                            a = e, s = 2 * i - t; break;
                        case Ct:
                            s = i + n[a = 1] - n[0]; break;
                        default:
                            a = e - 1, s = t }
                    var l = .5 * (i - t),
                        c = this.valueSize;
                    this._weightPrev = l / (t - o), this._weightNext = l / (s - i), this._offsetPrev = r * c, this._offsetNext = a * c }, interpolate_: function(e, t, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, d = this._weightNext, p = (i - t) / (n - t), f = p * p, m = f * p, g = -u * m + 2 * u * f - u * p, v = (1 + u) * m + (-1.5 - 2 * u) * f + (-.5 + u) * p + 1, M = (-1 - d) * m + (1.5 + d) * f + .5 * p, y = d * m - d * f, b = 0; b !== o; ++b) r[b] = g * a[c + b] + v * a[l + b] + M * a[s + b] + y * a[h + b]; return r } }), bl.prototype = Object.assign(Object.create(Ml.prototype), { constructor: bl, interpolate_: function(e, t, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, c = (i - t) / (n - t), h = 1 - c, u = 0; u !== o; ++u) r[u] = a[l + u] * h + a[s + u] * c; return r } }), _l.prototype = Object.assign(Object.create(Ml.prototype), { constructor: _l, interpolate_: function(e) { return this.copySampleValue_(e - 1) } }), Object.assign(xl, { toJSON: function(e) { var t, i = e.constructor; if (void 0 !== i.toJSON) t = i.toJSON(e);
                    else { t = { name: e.name, times: vl.convertArray(e.times, Array), values: vl.convertArray(e.values, Array) }; var n = e.getInterpolation();
                        n !== e.DefaultInterpolation && (t.interpolation = n) } return t.type = e.ValueTypeName, t } }), Object.assign(xl.prototype, { constructor: xl, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: Et, InterpolantFactoryMethodDiscrete: function(e) { return new _l(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodLinear: function(e) { return new bl(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodSmooth: function(e) { return new yl(this.times, this.values, this.getValueSize(), e) }, setInterpolation: function(e) { var t; switch (e) {
                        case St:
                            t = this.InterpolantFactoryMethodDiscrete; break;
                        case Et:
                            t = this.InterpolantFactoryMethodLinear; break;
                        case 2302:
                            t = this.InterpolantFactoryMethodSmooth } if (void 0 !== t) return this.createInterpolant = t, this; var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (void 0 === this.createInterpolant) { if (e === this.DefaultInterpolation) throw new Error(i);
                        this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", i), this }, getInterpolation: function() { switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return St;
                        case this.InterpolantFactoryMethodLinear:
                            return Et;
                        case this.InterpolantFactoryMethodSmooth:
                            return 2302 } }, getValueSize: function() { return this.values.length / this.times.length }, shift: function(e) { if (0 !== e)
                        for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] += e; return this }, scale: function(e) { if (1 !== e)
                        for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] *= e; return this }, trim: function(e, t) { for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < e;) ++r; for (; - 1 !== a && i[a] > t;) --a; if (++a, 0 !== r || a !== n) { a <= r && (r = (a = Math.max(a, 1)) - 1); var o = this.getValueSize();
                        this.times = vl.arraySlice(i, r, a), this.values = vl.arraySlice(this.values, r * o, a * o) } return this }, validate: function() { var e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1); var i = this.times,
                        n = this.values,
                        r = i.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1); for (var a = null, o = 0; o !== r; o++) { var s = i[o]; if ("number" == typeof s && isNaN(s)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1; break } if (null !== a && s < a) { console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1; break }
                        a = s } if (void 0 !== n && vl.isTypedArray(n)) { o = 0; for (var l = n.length; o !== l; ++o) { var c = n[o]; if (isNaN(c)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = !1; break } } } return e }, optimize: function() { for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, a = e.length - 1, o = 1; o < a; ++o) { var s = !1,
                            l = e[o]; if (l !== e[o + 1] && (1 !== o || l !== l[0]))
                            if (n) s = !0;
                            else
                                for (var c = o * i, h = c - i, u = c + i, d = 0; d !== i; ++d) { var p = t[c + d]; if (p !== t[h + d] || p !== t[u + d]) { s = !0; break } }
                            if (s) { if (o !== r) { e[r] = e[o]; var f = o * i,
                                        m = r * i; for (d = 0; d !== i; ++d) t[m + d] = t[f + d] }++r } } if (0 < a) { e[r] = e[a]; for (f = a * i, m = r * i, d = 0; d !== i; ++d) t[m + d] = t[f + d];++r } return r !== e.length && (this.times = vl.arraySlice(e, 0, r), this.values = vl.arraySlice(t, 0, r * i)), this }, clone: function() { var e = vl.arraySlice(this.times, 0),
                        t = vl.arraySlice(this.values, 0),
                        i = new this.constructor(this.name, e, t); return i.createInterpolant = this.createInterpolant, i } }), Tl.prototype = Object.assign(Object.create(xl.prototype), { constructor: Tl, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: St, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), wl.prototype = Object.assign(Object.create(xl.prototype), { constructor: wl, ValueTypeName: "color" }), Sl.prototype = Object.assign(Object.create(xl.prototype), { constructor: Sl, ValueTypeName: "number" }), El.prototype = Object.assign(Object.create(Ml.prototype), { constructor: El, interpolate_: function(e, t, i, n) { for (var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = (i - t) / (n - t), c = s + o; s !== c; s += 4) Wt.slerpFlat(r, 0, a, s - o, a, s, l); return r } }), Pl.prototype = Object.assign(Object.create(xl.prototype), { constructor: Pl, ValueTypeName: "quaternion", DefaultInterpolation: Et, InterpolantFactoryMethodLinear: function(e) { return new El(this.times, this.values, this.getValueSize(), e) }, InterpolantFactoryMethodSmooth: void 0 }), Al.prototype = Object.assign(Object.create(xl.prototype), { constructor: Al, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: St, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), Cl.prototype = Object.assign(Object.create(xl.prototype), { constructor: Cl, ValueTypeName: "vector" }), Object.assign(Ll, { parse: function(e) { for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, a = i.length; r !== a; ++r) t.push(Rl(i[r]).scale(n)); return new Ll(e.name, e.duration, t) }, toJSON: function(e) { for (var t = [], i = e.tracks, n = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid }, r = 0, a = i.length; r !== a; ++r) t.push(xl.toJSON(i[r])); return n }, CreateFromMorphTargetSequence: function(e, t, i, n) { for (var r = t.length, a = [], o = 0; o < r; o++) { var s = [],
                            l = [];
                        s.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0); var c = vl.getKeyframeOrder(s);
                        s = vl.sortedArray(s, 1, c), l = vl.sortedArray(l, 1, c), n || 0 !== s[0] || (s.push(r), l.push(l[0])), a.push(new Sl(".morphTargetInfluences[" + t[o].name + "]", s, l).scale(1 / i)) } return new Ll(e, -1, a) }, findByName: function(e, t) { var i = e; if (!Array.isArray(e)) { var n = e;
                        i = n.geometry && n.geometry.animations || n.animations } for (var r = 0; r < i.length; r++)
                        if (i[r].name === t) return i[r];
                    return null }, CreateClipsFromMorphTargetSequences: function(e, t, i) { for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) { var s = e[a],
                            l = s.name.match(r); if (l && 1 < l.length) { var c = n[u = l[1]];
                            c || (n[u] = c = []), c.push(s) } } var h = []; for (var u in n) h.push(Ll.CreateFromMorphTargetSequence(u, n[u], t, i)); return h }, parseAnimation: function(e, t) { if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; for (var i = function(e, t, i, n, r) { if (0 !== i.length) { var a = [],
                                    o = [];
                                vl.flattenJSON(i, a, o, n), 0 !== a.length && r.push(new e(t, a, o)) } }, n = [], r = e.name || "default", a = e.length || -1, o = e.fps || 30, s = e.hierarchy || [], l = 0; l < s.length; l++) { var c = s[l].keys; if (c && 0 !== c.length)
                            if (c[0].morphTargets) { for (var h = {}, u = 0; u < c.length; u++)
                                    if (c[u].morphTargets)
                                        for (var d = 0; d < c[u].morphTargets.length; d++) h[c[u].morphTargets[d]] = -1;
                                for (var p in h) { var f = [],
                                        m = []; for (d = 0; d !== c[u].morphTargets.length; ++d) { var g = c[u];
                                        f.push(g.time), m.push(g.morphTarget === p ? 1 : 0) }
                                    n.push(new Sl(".morphTargetInfluence[" + p + "]", f, m)) }
                                a = h.length * (o || 1) } else { var v = ".bones[" + t[l].name + "]";
                                i(Cl, v + ".position", c, "pos", n), i(Pl, v + ".quaternion", c, "rot", n), i(Cl, v + ".scale", c, "scl", n) } } return 0 === n.length ? null : new Ll(r, a, n) } }), Object.assign(Ll.prototype, { resetDuration: function() { for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t) { var n = this.tracks[t];
                        e = Math.max(e, n.times[n.times.length - 1]) } return this.duration = e, this }, trim: function() { for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration); return this }, validate: function() { for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate(); return e }, optimize: function() { for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize(); return this }, clone: function() { for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone()); return new Ll(this.name, this.duration, e) } }); var Hl = { enabled: !1, files: {}, add: function(e, t) {!1 !== this.enabled && (this.files[e] = t) }, get: function(e) { if (!1 !== this.enabled) return this.files[e] }, remove: function(e) { delete this.files[e] }, clear: function() { this.files = {} } };

            function Ol(e, t, i) { var n = this,
                    r = !1,
                    a = 0,
                    o = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(e) { o++, !1 === r && void 0 !== n.onStart && n.onStart(e, a, o), r = !0 }, this.itemEnd = function(e) { a++, void 0 !== n.onProgress && n.onProgress(e, a, o), a === o && (r = !1, void 0 !== n.onLoad && n.onLoad()) }, this.itemError = function(e) { void 0 !== n.onError && n.onError(e) }, this.resolveURL = function(e) { return s ? s(e) : e }, this.setURLModifier = function(e) { return s = e, this } } var Gl = new Ol,
                Dl = {};

            function Il(e) { this.manager = void 0 !== e ? e : Gl }

            function Bl(e) { this.manager = void 0 !== e ? e : Gl }

            function Nl(e) { this.manager = void 0 !== e ? e : Gl, this._parser = null }

            function Fl(e) { this.manager = void 0 !== e ? e : Gl, this._parser = null }

            function zl(e) { this.manager = void 0 !== e ? e : Gl }

            function kl(e) { this.manager = void 0 !== e ? e : Gl }

            function Ul(e) { this.manager = void 0 !== e ? e : Gl }

            function Vl() { this.type = "Curve", this.arcLengthDivisions = 200 }

            function jl(e, t, i, n, r, a, o, s) { Vl.call(this), this.type = "EllipseCurve", this.aX = e || 0, this.aY = t || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0 }

            function Wl(e, t, i, n, r, a) { jl.call(this, e, t, i, i, n, r, a), this.type = "ArcCurve" }

            function Xl() { var r = 0,
                    a = 0,
                    o = 0,
                    s = 0;

                function c(e, t, i, n) { o = -3 * (r = e) + 3 * t - 2 * (a = i) - n, s = 2 * e - 2 * t + i + n } return { initCatmullRom: function(e, t, i, n, r) { c(t, i, r * (i - e), r * (n - t)) }, initNonuniformCatmullRom: function(e, t, i, n, r, a, o) { var s = (t - e) / r - (i - e) / (r + a) + (i - t) / a,
                            l = (i - t) / a - (n - t) / (a + o) + (n - i) / o;
                        c(t, i, s *= a, l *= a) }, calc: function(e) { var t = e * e; return r + a * e + o * t + s * (t * e) } } }
            Object.assign(Il.prototype, { load: function(o, e, t, i) { void 0 === o && (o = ""), void 0 !== this.path && (o = this.path + o), o = this.manager.resolveURL(o); var s = this,
                        n = Hl.get(o); if (void 0 !== n) return s.manager.itemStart(o), setTimeout(function() { e && e(n), s.manager.itemEnd(o) }, 0), n; if (void 0 === Dl[o]) { var r = o.match(/^data:(.*?)(;base64)?,(.*)$/); if (r) { var a = r[1],
                                l = !!r[2],
                                c = r[3];
                            c = decodeURIComponent(c), l && (c = atob(c)); try { var h, u = (this.responseType || "").toLowerCase(); switch (u) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var d = new Uint8Array(c.length), p = 0; p < c.length; p++) d[p] = c.charCodeAt(p);
                                        h = "blob" === u ? new Blob([d.buffer], { type: a }) : d.buffer; break;
                                    case "document":
                                        var f = new DOMParser;
                                        h = f.parseFromString(c, a); break;
                                    case "json":
                                        h = JSON.parse(c); break;
                                    default:
                                        h = c }
                                setTimeout(function() { e && e(h), s.manager.itemEnd(o) }, 0) } catch (e) { setTimeout(function() { i && i(e), s.manager.itemError(o), s.manager.itemEnd(o) }, 0) } } else { Dl[o] = [], Dl[o].push({ onLoad: e, onProgress: t, onError: i }); var m = new XMLHttpRequest; for (var g in m.open("GET", o, !0), m.addEventListener("load", function(e) { var t = this.response;
                                    Hl.add(o, t); var i = Dl[o]; if (delete Dl[o], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."); for (var n = 0, r = i.length; n < r; n++) {
                                            (a = i[n]).onLoad && a.onLoad(t) }
                                        s.manager.itemEnd(o) } else { for (n = 0, r = i.length; n < r; n++) { var a;
                                            (a = i[n]).onError && a.onError(e) }
                                        s.manager.itemError(o), s.manager.itemEnd(o) } }, !1), m.addEventListener("progress", function(e) { for (var t = Dl[o], i = 0, n = t.length; i < n; i++) { var r = t[i];
                                        r.onProgress && r.onProgress(e) } }, !1), m.addEventListener("error", function(e) { var t = Dl[o];
                                    delete Dl[o]; for (var i = 0, n = t.length; i < n; i++) { var r = t[i];
                                        r.onError && r.onError(e) }
                                    s.manager.itemError(o), s.manager.itemEnd(o) }, !1), m.addEventListener("abort", function(e) { var t = Dl[o];
                                    delete Dl[o]; for (var i = 0, n = t.length; i < n; i++) { var r = t[i];
                                        r.onError && r.onError(e) }
                                    s.manager.itemError(o), s.manager.itemEnd(o) }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
                            m.send(null) } return s.manager.itemStart(o), m }
                    Dl[o].push({ onLoad: e, onProgress: t, onError: i }) }, setPath: function(e) { return this.path = e, this }, setResponseType: function(e) { return this.responseType = e, this }, setWithCredentials: function(e) { return this.withCredentials = e, this }, setMimeType: function(e) { return this.mimeType = e, this }, setRequestHeader: function(e) { return this.requestHeader = e, this } }), Object.assign(Bl.prototype, { load: function(e, t, i, n) { var r = this,
                        a = new Il(r.manager);
                    a.setPath(r.path), a.load(e, function(e) { t(r.parse(JSON.parse(e))) }, i, n) }, parse: function(e, t) { for (var i = [], n = 0; n < e.length; n++) { var r = Ll.parse(e[n]);
                        i.push(r) }
                    t(i) }, setPath: function(e) { return this.path = e, this } }), Object.assign(Nl.prototype, { load: function(e, a, t, n) { var o = this,
                        s = [],
                        l = new Wo;
                    l.image = s; var r = new Il(this.manager);

                    function i(i) { r.load(e[i], function(e) { var t = o._parser(e, !0);
                            s[i] = { width: t.width, height: t.height, format: t.format, mipmaps: t.mipmaps }, 6 === (c += 1) && (1 === t.mipmapCount && (l.minFilter = He), l.format = t.format, l.needsUpdate = !0, a && a(l)) }, t, n) } if (r.setPath(this.path), r.setResponseType("arraybuffer"), Array.isArray(e))
                        for (var c = 0, h = 0, u = e.length; h < u; ++h) i(h);
                    else r.load(e, function(e) { var t = o._parser(e, !0); if (t.isCubemap)
                            for (var i = t.mipmaps.length / t.mipmapCount, n = 0; n < i; n++) { s[n] = { mipmaps: [] }; for (var r = 0; r < t.mipmapCount; r++) s[n].mipmaps.push(t.mipmaps[n * t.mipmapCount + r]), s[n].format = t.format, s[n].width = t.width, s[n].height = t.height } else l.image.width = t.width, l.image.height = t.height, l.mipmaps = t.mipmaps;
                        1 === t.mipmapCount && (l.minFilter = He), l.format = t.format, l.needsUpdate = !0, a && a(l) }, t, n); return l }, setPath: function(e) { return this.path = e, this } }), Object.assign(Fl.prototype, { load: function(e, i, t, n) { var r = this,
                        a = new vi,
                        o = new Il(this.manager); return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(e, function(e) { var t = r._parser(e);
                        t && (void 0 !== t.image ? a.image = t.image : void 0 !== t.data && (a.image.width = t.width, a.image.height = t.height, a.image.data = t.data), a.wrapS = void 0 !== t.wrapS ? t.wrapS : Pe, a.wrapT = void 0 !== t.wrapT ? t.wrapT : Pe, a.magFilter = void 0 !== t.magFilter ? t.magFilter : He, a.minFilter = void 0 !== t.minFilter ? t.minFilter : Ge, a.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (a.format = t.format), void 0 !== t.type && (a.type = t.type), void 0 !== t.mipmaps && (a.mipmaps = t.mipmaps), 1 === t.mipmapCount && (a.minFilter = He), a.needsUpdate = !0, i && i(a, t)) }, t, n), a }, setPath: function(e) { return this.path = e, this } }), Object.assign(zl.prototype, { crossOrigin: "anonymous", load: function(t, e, i, n) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); var r = this,
                        a = Hl.get(t); if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function() { e && e(a), r.manager.itemEnd(t) }, 0), a; var o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), Hl.add(t, this), e && e(this), r.manager.itemEnd(t) }

                    function l(e) { o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1), n && n(e), r.manager.itemError(t), r.manager.itemEnd(t) } return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o }, setCrossOrigin: function(e) { return this.crossOrigin = e, this }, setPath: function(e) { return this.path = e, this } }), Object.assign(kl.prototype, { crossOrigin: "anonymous", load: function(e, i, t, n) { var r = new Dr,
                        a = new zl(this.manager);
                    a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); var o = 0;

                    function s(t) { a.load(e[t], function(e) { r.images[t] = e, 6 === ++o && (r.needsUpdate = !0, i && i(r)) }, void 0, n) } for (var l = 0; l < e.length; ++l) s(l); return r }, setCrossOrigin: function(e) { return this.crossOrigin = e, this }, setPath: function(e) { return this.path = e, this } }), Object.assign(Ul.prototype, { crossOrigin: "anonymous", load: function(i, n, e, t) { var r = new di,
                        a = new zl(this.manager); return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(i, function(e) { r.image = e; var t = 0 < i.search(/\.jpe?g($|\?)/i) || 0 === i.search(/^data\:image\/jpeg/);
                        r.format = t ? qe : Ze, r.needsUpdate = !0, void 0 !== n && n(r) }, e, t), r }, setCrossOrigin: function(e) { return this.crossOrigin = e, this }, setPath: function(e) { return this.path = e, this } }), Object.assign(Vl.prototype, { getPoint: function() { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function(e, t) { var i = this.getUtoTmapping(e); return this.getPoint(i, t) }, getPoints: function(e) { void 0 === e && (e = 5); for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e)); return t }, getSpacedPoints: function(e) { void 0 === e && (e = 5); for (var t = [], i = 0; i <= e; i++) t.push(this.getPointAt(i / e)); return t }, getLength: function() { var e = this.getLengths(); return e[e.length - 1] }, getLengths: function(e) { if (void 0 === e && (e = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1; var t, i, n = [],
                        r = this.getPoint(0),
                        a = 0; for (n.push(0), i = 1; i <= e; i++) a += (t = this.getPoint(i / e)).distanceTo(r), n.push(a), r = t; return this.cacheArcLengths = n }, updateArcLengths: function() { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function(e, t) { var i, n = this.getLengths(),
                        r = 0,
                        a = n.length;
                    i = t || e * n[a - 1]; for (var o, s = 0, l = a - 1; s <= l;)
                        if ((o = n[r = Math.floor(s + (l - s) / 2)] - i) < 0) s = r + 1;
                        else { if (!(0 < o)) { l = r; break }
                            l = r - 1 }
                    if (n[r = l] === i) return r / (a - 1); var c = n[r]; return (r + (i - c) / (n[r + 1] - c)) / (a - 1) }, getTangent: function(e) { var t = e - 1e-4,
                        i = e + 1e-4;
                    t < 0 && (t = 0), 1 < i && (i = 1); var n = this.getPoint(t); return this.getPoint(i).clone().sub(n).normalize() }, getTangentAt: function(e) { var t = this.getUtoTmapping(e); return this.getTangent(t) }, computeFrenetFrames: function(e, t) { var i, n, r, a = new Xt,
                        o = [],
                        s = [],
                        l = [],
                        c = new Xt,
                        h = new jt; for (i = 0; i <= e; i++) n = i / e, o[i] = this.getTangentAt(n), o[i].normalize();
                    s[0] = new Xt, l[0] = new Xt; var u = Number.MAX_VALUE,
                        d = Math.abs(o[0].x),
                        p = Math.abs(o[0].y),
                        f = Math.abs(o[0].z); for (d <= u && (u = d, a.set(1, 0, 0)), p <= u && (u = p, a.set(0, 1, 0)), f <= u && a.set(0, 0, 1), c.crossVectors(o[0], a).normalize(), s[0].crossVectors(o[0], c), l[0].crossVectors(o[0], s[0]), i = 1; i <= e; i++) s[i] = s[i - 1].clone(), l[i] = l[i - 1].clone(), c.crossVectors(o[i - 1], o[i]), c.length() > Number.EPSILON && (c.normalize(), r = Math.acos(Ut.clamp(o[i - 1].dot(o[i]), -1, 1)), s[i].applyMatrix4(h.makeRotationAxis(c, r))), l[i].crossVectors(o[i], s[i]); if (!0 === t)
                        for (r = Math.acos(Ut.clamp(s[0].dot(s[e]), -1, 1)), r /= e, 0 < o[0].dot(c.crossVectors(s[0], s[e])) && (r = -r), i = 1; i <= e; i++) s[i].applyMatrix4(h.makeRotationAxis(o[i], r * i)), l[i].crossVectors(o[i], s[i]); return { tangents: o, normals: s, binormals: l } }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this }, toJSON: function() { var e = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e }, fromJSON: function(e) { return this.arcLengthDivisions = e.arcLengthDivisions, this } }), ((jl.prototype = Object.create(Vl.prototype)).constructor = jl).prototype.isEllipseCurve = !0, jl.prototype.getPoint = function(e, t) { for (var i = t || new Vt, n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; r < 0;) r += n; for (; n < r;) r -= n;
                r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r === n ? r = -n : r -= n); var o = this.aStartAngle + e * r,
                    s = this.aX + this.xRadius * Math.cos(o),
                    l = this.aY + this.yRadius * Math.sin(o); if (0 !== this.aRotation) { var c = Math.cos(this.aRotation),
                        h = Math.sin(this.aRotation),
                        u = s - this.aX,
                        d = l - this.aY;
                    s = u * c - d * h + this.aX, l = u * h + d * c + this.aY } return i.set(s, l) }, jl.prototype.copy = function(e) { return Vl.prototype.copy.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, jl.prototype.toJSON = function() { var e = Vl.prototype.toJSON.call(this); return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e }, jl.prototype.fromJSON = function(e) { return Vl.prototype.fromJSON.call(this, e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this }, ((Wl.prototype = Object.create(jl.prototype)).constructor = Wl).prototype.isArcCurve = !0; var Yl = new Xt,
                ql = new Xl,
                Zl = new Xl,
                Jl = new Xl;

            function Kl(e, t, i, n) { Vl.call(this), this.type = "CatmullRomCurve3", this.points = e || [], this.closed = t || !1, this.curveType = i || "centripetal", this.tension = n || .5 }

            function Ql(e, t, i, n, r) { var a = .5 * (n - t),
                    o = .5 * (r - i),
                    s = e * e; return (2 * i - 2 * n + a + o) * (e * s) + (-3 * i + 3 * n - 2 * a - o) * s + a * e + i }

            function $l(e, t, i, n) { return (o = 1 - e) * o * t + 2 * (1 - (a = e)) * a * i + (r = e) * r * n; var r, a, o }

            function ec(e, t, i, n, r) { return (c = 1 - e) * c * c * t + 3 * (l = 1 - (s = e)) * l * s * i + 3 * (1 - (o = e)) * o * o * n + (a = e) * a * a * r; var a, o, s, l, c }

            function tc(e, t, i, n) { Vl.call(this), this.type = "CubicBezierCurve", this.v0 = e || new Vt, this.v1 = t || new Vt, this.v2 = i || new Vt, this.v3 = n || new Vt }

            function ic(e, t, i, n) { Vl.call(this), this.type = "CubicBezierCurve3", this.v0 = e || new Xt, this.v1 = t || new Xt, this.v2 = i || new Xt, this.v3 = n || new Xt }

            function nc(e, t) { Vl.call(this), this.type = "LineCurve", this.v1 = e || new Vt, this.v2 = t || new Vt }

            function rc(e, t) { Vl.call(this), this.type = "LineCurve3", this.v1 = e || new Xt, this.v2 = t || new Xt }

            function ac(e, t, i) { Vl.call(this), this.type = "QuadraticBezierCurve", this.v0 = e || new Vt, this.v1 = t || new Vt, this.v2 = i || new Vt }

            function oc(e, t, i) { Vl.call(this), this.type = "QuadraticBezierCurve3", this.v0 = e || new Xt, this.v1 = t || new Xt, this.v2 = i || new Xt }

            function sc(e) { Vl.call(this), this.type = "SplineCurve", this.points = e || [] }((Kl.prototype = Object.create(Vl.prototype)).constructor = Kl).prototype.isCatmullRomCurve3 = !0, Kl.prototype.getPoint = function(e, t) { var i, n, r, a, o = t || new Xt,
                    s = this.points,
                    l = s.length,
                    c = (l - (this.closed ? 0 : 1)) * e,
                    h = Math.floor(c),
                    u = c - h; if (this.closed ? h += 0 < h ? 0 : (Math.floor(Math.abs(h) / l) + 1) * l : 0 === u && h === l - 1 && (h = l - 2, u = 1), i = this.closed || 0 < h ? s[(h - 1) % l] : (Yl.subVectors(s[0], s[1]).add(s[0]), Yl), n = s[h % l], r = s[(h + 1) % l], a = this.closed || h + 2 < l ? s[(h + 2) % l] : (Yl.subVectors(s[l - 1], s[l - 2]).add(s[l - 1]), Yl), "centripetal" === this.curveType || "chordal" === this.curveType) { var d = "chordal" === this.curveType ? .5 : .25,
                        p = Math.pow(i.distanceToSquared(n), d),
                        f = Math.pow(n.distanceToSquared(r), d),
                        m = Math.pow(r.distanceToSquared(a), d);
                    f < 1e-4 && (f = 1), p < 1e-4 && (p = f), m < 1e-4 && (m = f), ql.initNonuniformCatmullRom(i.x, n.x, r.x, a.x, p, f, m), Zl.initNonuniformCatmullRom(i.y, n.y, r.y, a.y, p, f, m), Jl.initNonuniformCatmullRom(i.z, n.z, r.z, a.z, p, f, m) } else "catmullrom" === this.curveType && (ql.initCatmullRom(i.x, n.x, r.x, a.x, this.tension), Zl.initCatmullRom(i.y, n.y, r.y, a.y, this.tension), Jl.initCatmullRom(i.z, n.z, r.z, a.z, this.tension)); return o.set(ql.calc(u), Zl.calc(u), Jl.calc(u)), o }, Kl.prototype.copy = function(e) { Vl.prototype.copy.call(this, e), this.points = []; for (var t = 0, i = e.points.length; t < i; t++) { var n = e.points[t];
                    this.points.push(n.clone()) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this }, Kl.prototype.toJSON = function() { var e = Vl.prototype.toJSON.call(this);
                e.points = []; for (var t = 0, i = this.points.length; t < i; t++) { var n = this.points[t];
                    e.points.push(n.toArray()) } return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e }, Kl.prototype.fromJSON = function(e) { Vl.prototype.fromJSON.call(this, e), this.points = []; for (var t = 0, i = e.points.length; t < i; t++) { var n = e.points[t];
                    this.points.push((new Xt).fromArray(n)) } return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this }, ((tc.prototype = Object.create(Vl.prototype)).constructor = tc).prototype.isCubicBezierCurve = !0, tc.prototype.getPoint = function(e, t) { var i = t || new Vt,
                    n = this.v0,
                    r = this.v1,
                    a = this.v2,
                    o = this.v3; return i.set(ec(e, n.x, r.x, a.x, o.x), ec(e, n.y, r.y, a.y, o.y)), i }, tc.prototype.copy = function(e) { return Vl.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, tc.prototype.toJSON = function() { var e = Vl.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, tc.prototype.fromJSON = function(e) { return Vl.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, ((ic.prototype = Object.create(Vl.prototype)).constructor = ic).prototype.isCubicBezierCurve3 = !0, ic.prototype.getPoint = function(e, t) { var i = t || new Xt,
                    n = this.v0,
                    r = this.v1,
                    a = this.v2,
                    o = this.v3; return i.set(ec(e, n.x, r.x, a.x, o.x), ec(e, n.y, r.y, a.y, o.y), ec(e, n.z, r.z, a.z, o.z)), i }, ic.prototype.copy = function(e) { return Vl.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this }, ic.prototype.toJSON = function() { var e = Vl.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e }, ic.prototype.fromJSON = function(e) { return Vl.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this }, ((nc.prototype = Object.create(Vl.prototype)).constructor = nc).prototype.isLineCurve = !0, nc.prototype.getPoint = function(e, t) { var i = t || new Vt; return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i }, nc.prototype.getPointAt = function(e, t) { return this.getPoint(e, t) }, nc.prototype.getTangent = function() { return this.v2.clone().sub(this.v1).normalize() }, nc.prototype.copy = function(e) { return Vl.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, nc.prototype.toJSON = function() { var e = Vl.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, nc.prototype.fromJSON = function(e) { return Vl.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, ((rc.prototype = Object.create(Vl.prototype)).constructor = rc).prototype.isLineCurve3 = !0, rc.prototype.getPoint = function(e, t) { var i = t || new Xt; return 1 === e ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i }, rc.prototype.getPointAt = function(e, t) { return this.getPoint(e, t) }, rc.prototype.copy = function(e) { return Vl.prototype.copy.call(this, e), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, rc.prototype.toJSON = function() { var e = Vl.prototype.toJSON.call(this); return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, rc.prototype.fromJSON = function(e) { return Vl.prototype.fromJSON.call(this, e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, ((ac.prototype = Object.create(Vl.prototype)).constructor = ac).prototype.isQuadraticBezierCurve = !0, ac.prototype.getPoint = function(e, t) { var i = t || new Vt,
                    n = this.v0,
                    r = this.v1,
                    a = this.v2; return i.set($l(e, n.x, r.x, a.x), $l(e, n.y, r.y, a.y)), i }, ac.prototype.copy = function(e) { return Vl.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, ac.prototype.toJSON = function() { var e = Vl.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, ac.prototype.fromJSON = function(e) { return Vl.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, ((oc.prototype = Object.create(Vl.prototype)).constructor = oc).prototype.isQuadraticBezierCurve3 = !0, oc.prototype.getPoint = function(e, t) { var i = t || new Xt,
                    n = this.v0,
                    r = this.v1,
                    a = this.v2; return i.set($l(e, n.x, r.x, a.x), $l(e, n.y, r.y, a.y), $l(e, n.z, r.z, a.z)), i }, oc.prototype.copy = function(e) { return Vl.prototype.copy.call(this, e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this }, oc.prototype.toJSON = function() { var e = Vl.prototype.toJSON.call(this); return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e }, oc.prototype.fromJSON = function(e) { return Vl.prototype.fromJSON.call(this, e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this }, ((sc.prototype = Object.create(Vl.prototype)).constructor = sc).prototype.isSplineCurve = !0, sc.prototype.getPoint = function(e, t) { var i = t || new Vt,
                    n = this.points,
                    r = (n.length - 1) * e,
                    a = Math.floor(r),
                    o = r - a,
                    s = n[0 === a ? a : a - 1],
                    l = n[a],
                    c = n[a > n.length - 2 ? n.length - 1 : a + 1],
                    h = n[a > n.length - 3 ? n.length - 1 : a + 2]; return i.set(Ql(o, s.x, l.x, c.x, h.x), Ql(o, s.y, l.y, c.y, h.y)), i }, sc.prototype.copy = function(e) { Vl.prototype.copy.call(this, e), this.points = []; for (var t = 0, i = e.points.length; t < i; t++) { var n = e.points[t];
                    this.points.push(n.clone()) } return this }, sc.prototype.toJSON = function() { var e = Vl.prototype.toJSON.call(this);
                e.points = []; for (var t = 0, i = this.points.length; t < i; t++) { var n = this.points[t];
                    e.points.push(n.toArray()) } return e }, sc.prototype.fromJSON = function(e) { Vl.prototype.fromJSON.call(this, e), this.points = []; for (var t = 0, i = e.points.length; t < i; t++) { var n = e.points[t];
                    this.points.push((new Vt).fromArray(n)) } return this }; var lc = Object.freeze({ ArcCurve: Wl, CatmullRomCurve3: Kl, CubicBezierCurve: tc, CubicBezierCurve3: ic, EllipseCurve: jl, LineCurve: nc, LineCurve3: rc, QuadraticBezierCurve: ac, QuadraticBezierCurve3: oc, SplineCurve: sc });

            function cc() { Vl.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 }

            function hc(e) { cc.call(this), this.type = "Path", this.currentPoint = new Vt, e && this.setFromPoints(e) }

            function uc(e) { hc.call(this, e), this.uuid = Ut.generateUUID(), this.type = "Shape", this.holes = [] }

            function dc(e, t) { on.call(this), this.type = "Light", this.color = new Li(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0 }

            function pc(e, t, i) { dc.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(on.DefaultUp), this.updateMatrix(), this.groundColor = new Li(t) }

            function fc(e) { this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new Vt(512, 512), this.map = null, this.matrix = new jt }

            function mc() { fc.call(this, new io(50, 1, .5, 500)) }

            function gc(e, t, i, n, r, a) { dc.call(this, e, t), this.type = "SpotLight", this.position.copy(on.DefaultUp), this.updateMatrix(), this.target = new on, Object.defineProperty(this, "power", { get: function() { return this.intensity * Math.PI }, set: function(e) { this.intensity = e / Math.PI } }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new mc }

            function vc(e, t, i, n) { dc.call(this, e, t), this.type = "PointLight", Object.defineProperty(this, "power", { get: function() { return 4 * this.intensity * Math.PI }, set: function(e) { this.intensity = e / (4 * Math.PI) } }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new fc(new io(90, 1, .5, 500)) }

            function Mc(e, t, i, n, r, a) { to.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== e ? e : -1, this.right = void 0 !== t ? t : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix() }

            function yc() { fc.call(this, new Mc(-5, 5, 5, -5, .5, 500)) }

            function bc(e, t) { dc.call(this, e, t), this.type = "DirectionalLight", this.position.copy(on.DefaultUp), this.updateMatrix(), this.target = new on, this.shadow = new yc }

            function _c(e, t) { dc.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0 }

            function xc(e, t, i, n) { dc.call(this, e, t), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10 }

            function Tc(e) { this.manager = void 0 !== e ? e : Gl, this.textures = {} }
            cc.prototype = Object.assign(Object.create(Vl.prototype), { constructor: cc, add: function(e) { this.curves.push(e) }, closePath: function() { var e = this.curves[0].getPoint(0),
                        t = this.curves[this.curves.length - 1].getPoint(1);
                    e.equals(t) || this.curves.push(new nc(t, e)) }, getPoint: function(e) { for (var t = e * this.getLength(), i = this.getCurveLengths(), n = 0; n < i.length;) { if (i[n] >= t) { var r = i[n] - t,
                                a = this.curves[n],
                                o = a.getLength(),
                                s = 0 === o ? 0 : 1 - r / o; return a.getPointAt(s) }
                        n++ } return null }, getLength: function() { var e = this.getCurveLengths(); return e[e.length - 1] }, updateArcLengths: function() { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function() { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t); return this.cacheLengths = e }, getSpacedPoints: function(e) { void 0 === e && (e = 40); for (var t = [], i = 0; i <= e; i++) t.push(this.getPoint(i / e)); return this.autoClose && t.push(t[0]), t }, getPoints: function(e) { e = e || 12; for (var t, i = [], n = 0, r = this.curves; n < r.length; n++)
                        for (var a = r[n], o = a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e, s = a.getPoints(o), l = 0; l < s.length; l++) { var c = s[l];
                            t && t.equals(c) || (i.push(c), t = c) }
                    return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i }, copy: function(e) { Vl.prototype.copy.call(this, e), this.curves = []; for (var t = 0, i = e.curves.length; t < i; t++) { var n = e.curves[t];
                        this.curves.push(n.clone()) } return this.autoClose = e.autoClose, this }, toJSON: function() { var e = Vl.prototype.toJSON.call(this);
                    e.autoClose = this.autoClose, e.curves = []; for (var t = 0, i = this.curves.length; t < i; t++) { var n = this.curves[t];
                        e.curves.push(n.toJSON()) } return e }, fromJSON: function(e) { Vl.prototype.fromJSON.call(this, e), this.autoClose = e.autoClose, this.curves = []; for (var t = 0, i = e.curves.length; t < i; t++) { var n = e.curves[t];
                        this.curves.push((new lc[n.type]).fromJSON(n)) } return this } }), hc.prototype = Object.assign(Object.create(cc.prototype), { constructor: hc, setFromPoints: function(e) { this.moveTo(e[0].x, e[0].y); for (var t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y) }, moveTo: function(e, t) { this.currentPoint.set(e, t) }, lineTo: function(e, t) { var i = new nc(this.currentPoint.clone(), new Vt(e, t));
                    this.curves.push(i), this.currentPoint.set(e, t) }, quadraticCurveTo: function(e, t, i, n) { var r = new ac(this.currentPoint.clone(), new Vt(e, t), new Vt(i, n));
                    this.curves.push(r), this.currentPoint.set(i, n) }, bezierCurveTo: function(e, t, i, n, r, a) { var o = new tc(this.currentPoint.clone(), new Vt(e, t), new Vt(i, n), new Vt(r, a));
                    this.curves.push(o), this.currentPoint.set(r, a) }, splineThru: function(e) { var t = new sc([this.currentPoint.clone()].concat(e));
                    this.curves.push(t), this.currentPoint.copy(e[e.length - 1]) }, arc: function(e, t, i, n, r, a) { var o = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(e + o, t + s, i, n, r, a) }, absarc: function(e, t, i, n, r, a) { this.absellipse(e, t, i, i, n, r, a) }, ellipse: function(e, t, i, n, r, a, o, s) { var l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    this.absellipse(e + l, t + c, i, n, r, a, o, s) }, absellipse: function(e, t, i, n, r, a, o, s) { var l = new jl(e, t, i, n, r, a, o, s); if (0 < this.curves.length) { var c = l.getPoint(0);
                        c.equals(this.currentPoint) || this.lineTo(c.x, c.y) }
                    this.curves.push(l); var h = l.getPoint(1);
                    this.currentPoint.copy(h) }, copy: function(e) { return cc.prototype.copy.call(this, e), this.currentPoint.copy(e.currentPoint), this }, toJSON: function() { var e = cc.prototype.toJSON.call(this); return e.currentPoint = this.currentPoint.toArray(), e }, fromJSON: function(e) { return cc.prototype.fromJSON.call(this, e), this.currentPoint.fromArray(e.currentPoint), this } }), uc.prototype = Object.assign(Object.create(hc.prototype), { constructor: uc, getPointsHoles: function(e) { for (var t = [], i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e); return t }, extractPoints: function(e) { return { shape: this.getPoints(e), holes: this.getPointsHoles(e) } }, copy: function(e) { hc.prototype.copy.call(this, e), this.holes = []; for (var t = 0, i = e.holes.length; t < i; t++) { var n = e.holes[t];
                        this.holes.push(n.clone()) } return this }, toJSON: function() { var e = hc.prototype.toJSON.call(this);
                    e.uuid = this.uuid, e.holes = []; for (var t = 0, i = this.holes.length; t < i; t++) { var n = this.holes[t];
                        e.holes.push(n.toJSON()) } return e }, fromJSON: function(e) { hc.prototype.fromJSON.call(this, e), this.uuid = e.uuid, this.holes = []; for (var t = 0, i = e.holes.length; t < i; t++) { var n = e.holes[t];
                        this.holes.push((new hc).fromJSON(n)) } return this } }), dc.prototype = Object.assign(Object.create(on.prototype), { constructor: dc, isLight: !0, copy: function(e) { return on.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this }, toJSON: function(e) { var t = on.prototype.toJSON.call(this, e); return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } }), pc.prototype = Object.assign(Object.create(dc.prototype), { constructor: pc, isHemisphereLight: !0, copy: function(e) { return dc.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this } }), Object.assign(fc.prototype, { copy: function(e) { return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this }, clone: function() { return (new this.constructor).copy(this) }, toJSON: function() { var e = {}; return 0 !== this.bias && (e.bias = this.bias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e } }), mc.prototype = Object.assign(Object.create(fc.prototype), { constructor: mc, isSpotLightShadow: !0, update: function(e) { var t = this.camera,
                        i = 2 * Ut.RAD2DEG * e.angle,
                        n = this.mapSize.width / this.mapSize.height,
                        r = e.distance || t.far;
                    i === t.fov && n === t.aspect && r === t.far || (t.fov = i, t.aspect = n, t.far = r, t.updateProjectionMatrix()) } }), gc.prototype = Object.assign(Object.create(dc.prototype), { constructor: gc, isSpotLight: !0, copy: function(e) { return dc.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), vc.prototype = Object.assign(Object.create(dc.prototype), { constructor: vc, isPointLight: !0, copy: function(e) { return dc.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this } }), Mc.prototype = Object.assign(Object.create(to.prototype), { constructor: Mc, isOrthographicCamera: !0, copy: function(e, t) { return to.prototype.copy.call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this }, setViewOffset: function(e, t, i, n, r, a) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix() }, clearViewOffset: function() { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function() { var e = (this.right - this.left) / (2 * this.zoom),
                        t = (this.top - this.bottom) / (2 * this.zoom),
                        i = (this.right + this.left) / 2,
                        n = (this.top + this.bottom) / 2,
                        r = i - e,
                        a = i + e,
                        o = n + t,
                        s = n - t; if (null !== this.view && this.view.enabled) { var l = this.zoom / (this.view.width / this.view.fullWidth),
                            c = this.zoom / (this.view.height / this.view.fullHeight),
                            h = (this.right - this.left) / this.view.width,
                            u = (this.top - this.bottom) / this.view.height;
                        a = (r += h * (this.view.offsetX / l)) + h * (this.view.width / l), s = (o -= u * (this.view.offsetY / c)) - u * (this.view.height / c) }
                    this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function(e) { var t = on.prototype.toJSON.call(this, e); return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } }), yc.prototype = Object.assign(Object.create(fc.prototype), { constructor: yc }), bc.prototype = Object.assign(Object.create(dc.prototype), { constructor: bc, isDirectionalLight: !0, copy: function(e) { return dc.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this } }), _c.prototype = Object.assign(Object.create(dc.prototype), { constructor: _c, isAmbientLight: !0 }), xc.prototype = Object.assign(Object.create(dc.prototype), { constructor: xc, isRectAreaLight: !0, copy: function(e) { return dc.prototype.copy.call(this, e), this.width = e.width, this.height = e.height, this }, toJSON: function(e) { var t = dc.prototype.toJSON.call(this, e); return t.object.width = this.width, t.object.height = this.height, t } }), Object.assign(Tc.prototype, { load: function(e, t, i, n) { var r = this,
                        a = new Il(r.manager);
                    a.setPath(r.path), a.load(e, function(e) { t(r.parse(JSON.parse(e))) }, i, n) }, parse: function(e) { var t = this.textures;

                    function i(e) { return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e] } var n = new gl[e.type]; if (void 0 !== e.uuid && (n.uuid = e.uuid), void 0 !== e.name && (n.name = e.name), void 0 !== e.color && n.color.setHex(e.color), void 0 !== e.roughness && (n.roughness = e.roughness), void 0 !== e.metalness && (n.metalness = e.metalness), void 0 !== e.emissive && n.emissive.setHex(e.emissive), void 0 !== e.specular && n.specular.setHex(e.specular), void 0 !== e.shininess && (n.shininess = e.shininess), void 0 !== e.clearCoat && (n.clearCoat = e.clearCoat), void 0 !== e.clearCoatRoughness && (n.clearCoatRoughness = e.clearCoatRoughness), void 0 !== e.vertexColors && (n.vertexColors = e.vertexColors), void 0 !== e.fog && (n.fog = e.fog), void 0 !== e.flatShading && (n.flatShading = e.flatShading), void 0 !== e.blending && (n.blending = e.blending), void 0 !== e.combine && (n.combine = e.combine), void 0 !== e.side && (n.side = e.side), void 0 !== e.opacity && (n.opacity = e.opacity), void 0 !== e.transparent && (n.transparent = e.transparent), void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest), void 0 !== e.depthTest && (n.depthTest = e.depthTest), void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite), void 0 !== e.wireframe && (n.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (n.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.wireframeLinecap && (n.wireframeLinecap = e.wireframeLinecap), void 0 !== e.wireframeLinejoin && (n.wireframeLinejoin = e.wireframeLinejoin), void 0 !== e.rotation && (n.rotation = e.rotation), 1 !== e.linewidth && (n.linewidth = e.linewidth), void 0 !== e.dashSize && (n.dashSize = e.dashSize), void 0 !== e.gapSize && (n.gapSize = e.gapSize), void 0 !== e.scale && (n.scale = e.scale), void 0 !== e.polygonOffset && (n.polygonOffset = e.polygonOffset), void 0 !== e.polygonOffsetFactor && (n.polygonOffsetFactor = e.polygonOffsetFactor), void 0 !== e.polygonOffsetUnits && (n.polygonOffsetUnits = e.polygonOffsetUnits), void 0 !== e.skinning && (n.skinning = e.skinning), void 0 !== e.morphTargets && (n.morphTargets = e.morphTargets), void 0 !== e.dithering && (n.dithering = e.dithering), void 0 !== e.visible && (n.visible = e.visible), void 0 !== e.userData && (n.userData = e.userData), void 0 !== e.uniforms)
                        for (var r in e.uniforms) { var a = e.uniforms[r]; switch (n.uniforms[r] = {}, a.type) {
                                case "t":
                                    n.uniforms[r].value = i(a.value); break;
                                case "c":
                                    n.uniforms[r].value = (new Li).setHex(a.value); break;
                                case "v2":
                                    n.uniforms[r].value = (new Vt).fromArray(a.value); break;
                                case "v3":
                                    n.uniforms[r].value = (new Xt).fromArray(a.value); break;
                                case "v4":
                                    n.uniforms[r].value = (new pi).fromArray(a.value); break;
                                case "m3":
                                    n.uniforms[r].value = (new Yt).fromArray(a.value);
                                case "m4":
                                    n.uniforms[r].value = (new jt).fromArray(a.value); break;
                                default:
                                    n.uniforms[r].value = a.value } }
                    if (void 0 !== e.defines && (n.defines = e.defines), void 0 !== e.vertexShader && (n.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (n.fragmentShader = e.fragmentShader), void 0 !== e.extensions)
                        for (var o in e.extensions) n.extensions[o] = e.extensions[o]; if (void 0 !== e.shading && (n.flatShading = 1 === e.shading), void 0 !== e.size && (n.size = e.size), void 0 !== e.sizeAttenuation && (n.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (n.map = i(e.map)), void 0 !== e.alphaMap && (n.alphaMap = i(e.alphaMap), n.transparent = !0), void 0 !== e.bumpMap && (n.bumpMap = i(e.bumpMap)), void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale), void 0 !== e.normalMap && (n.normalMap = i(e.normalMap)), void 0 !== e.normalMapType && (n.normalMapType = e.normalMapType), void 0 !== e.normalScale) { var s = e.normalScale;!1 === Array.isArray(s) && (s = [s, s]), n.normalScale = (new Vt).fromArray(s) } return void 0 !== e.displacementMap && (n.displacementMap = i(e.displacementMap)), void 0 !== e.displacementScale && (n.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (n.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (n.roughnessMap = i(e.roughnessMap)), void 0 !== e.metalnessMap && (n.metalnessMap = i(e.metalnessMap)), void 0 !== e.emissiveMap && (n.emissiveMap = i(e.emissiveMap)), void 0 !== e.emissiveIntensity && (n.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (n.specularMap = i(e.specularMap)), void 0 !== e.envMap && (n.envMap = i(e.envMap)), void 0 !== e.envMapIntensity && (n.envMapIntensity = e.envMapIntensity), void 0 !== e.reflectivity && (n.reflectivity = e.reflectivity), void 0 !== e.lightMap && (n.lightMap = i(e.lightMap)), void 0 !== e.lightMapIntensity && (n.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (n.aoMap = i(e.aoMap)), void 0 !== e.aoMapIntensity && (n.aoMapIntensity = e.aoMapIntensity), void 0 !== e.gradientMap && (n.gradientMap = i(e.gradientMap)), n }, setPath: function(e) { return this.path = e, this }, setTextures: function(e) { return this.textures = e, this } }); var wc = { decodeText: function(e) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e); for (var t = "", i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]); return decodeURIComponent(escape(t)) }, extractUrlBase: function(e) { var t = e.lastIndexOf("/"); return -1 === t ? "./" : e.substr(0, t + 1) } };

            function Sc(e) { this.manager = void 0 !== e ? e : Gl }
            Object.assign(Sc.prototype, { load: function(e, t, i, n) { var r = this,
                        a = new Il(r.manager);
                    a.setPath(r.path), a.load(e, function(e) { t(r.parse(JSON.parse(e))) }, i, n) }, parse: function(e) { var t = new Fn,
                        i = e.data.index; if (void 0 !== i) { var n = new Ec[i.type](i.array);
                        t.setIndex(new gn(n, 1)) } var r = e.data.attributes; for (var a in r) { var o = r[a],
                            s = new gn(n = new Ec[o.type](o.array), o.itemSize, o.normalized);
                        void 0 !== o.name && (s.name = o.name), t.addAttribute(a, s) } var l = e.data.morphAttributes; if (l)
                        for (var a in l) { for (var c = l[a], h = [], u = 0, d = c.length; u < d; u++) { o = c[u], s = new gn(n = new Ec[o.type](o.array), o.itemSize, o.normalized);
                                void 0 !== o.name && (s.name = o.name), h.push(s) }
                            t.morphAttributes[a] = h }
                    var p = e.data.groups || e.data.drawcalls || e.data.offsets; if (void 0 !== p) { u = 0; for (var f = p.length; u !== f; ++u) { var m = p[u];
                            t.addGroup(m.start, m.count, m.materialIndex) } } var g = e.data.boundingSphere; if (void 0 !== g) { var v = new Xt;
                        void 0 !== g.center && v.fromArray(g.center), t.boundingSphere = new yi(v, g.radius) } return e.name && (t.name = e.name), e.userData && (t.userData = e.userData), t }, setPath: function(e) { return this.path = e, this } }); var Ec = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array };

            function Pc(e) { this.manager = void 0 !== e ? e : Gl, this.resourcePath = "" }
            Object.assign(Pc.prototype, { crossOrigin: "anonymous", load: function(n, r, e, a) { var o = this,
                        t = void 0 === this.path ? wc.extractUrlBase(n) : this.path;
                    this.resourcePath = this.resourcePath || t; var i = new Il(o.manager);
                    i.setPath(this.path), i.load(n, function(e) { var t = null; try { t = JSON.parse(e) } catch (e) { return void 0 !== a && a(e), void console.error("THREE:ObjectLoader: Can't parse " + n + ".", e.message) } var i = t.metadata;
                        void 0 !== i && void 0 !== i.type && "geometry" !== i.type.toLowerCase() ? o.parse(t, r) : console.error("THREE.ObjectLoader: Can't load " + n) }, e, a) }, setPath: function(e) { return this.path = e, this }, setResourcePath: function(e) { return this.resourcePath = e, this }, setCrossOrigin: function(e) { return this.crossOrigin = e, this }, parse: function(e, t) { var i = this.parseShape(e.shapes),
                        n = this.parseGeometries(e.geometries, i),
                        r = this.parseImages(e.images, function() { void 0 !== t && t(s) }),
                        a = this.parseTextures(e.textures, r),
                        o = this.parseMaterials(e.materials, a),
                        s = this.parseObject(e.object, n, o); return e.animations && (s.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(s), s }, parseShape: function(e) { var t = {}; if (void 0 !== e)
                        for (var i = 0, n = e.length; i < n; i++) { var r = (new uc).fromJSON(e[i]);
                            t[r.uuid] = r }
                    return t }, parseGeometries: function(e, t) { var i = {}; if (void 0 !== e)
                        for (var n = new Sc, r = 0, a = e.length; r < a; r++) { var o, s = e[r]; switch (s.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    o = new al[s.type](s.width, s.height, s.widthSegments, s.heightSegments); break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    o = new al[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments); break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    o = new al[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength); break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    o = new al[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    o = new al[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength); break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    o = new al[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength); break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    o = new al[s.type](s.radius, s.detail); break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    o = new al[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength); break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    o = new al[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc); break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    o = new al[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q); break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    o = new al[s.type]((new lc[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed); break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    o = new al[s.type](s.points, s.segments, s.phiStart, s.phiLength); break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    o = new al[s.type](s.vertices, s.indices, s.radius, s.details); break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var l = [], c = 0, h = s.shapes.length; c < h; c++) { var u = t[s.shapes[c]];
                                        l.push(u) }
                                    o = new al[s.type](l, s.curveSegments); break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (l = [], c = 0, h = s.shapes.length; c < h; c++) { u = t[s.shapes[c]];
                                        l.push(u) } var d = s.options.extrudePath;
                                    void 0 !== d && (s.options.extrudePath = (new lc[d.type]).fromJSON(d)), o = new al[s.type](l, s.options); break;
                                case "BufferGeometry":
                                    o = n.parse(s); break;
                                case "Geometry":
                                    if ("THREE" in window && "LegacyJSONLoader" in THREE) o = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry;
                                    else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'); break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"'); continue }
                            o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), !0 === o.isBufferGeometry && void 0 !== s.userData && (o.userData = s.userData), i[s.uuid] = o }
                    return i }, parseMaterials: function(e, t) { var i = {},
                        n = {}; if (void 0 !== e) { var r = new Tc;
                        r.setTextures(t); for (var a = 0, o = e.length; a < o; a++) { var s = e[a]; if ("MultiMaterial" === s.type) { for (var l = [], c = 0; c < s.materials.length; c++) { var h = s.materials[c];
                                    void 0 === i[h.uuid] && (i[h.uuid] = r.parse(h)), l.push(i[h.uuid]) }
                                n[s.uuid] = l } else void 0 === i[s.uuid] && (i[s.uuid] = r.parse(s)), n[s.uuid] = i[s.uuid] } } return n }, parseAnimations: function(e) { for (var t = [], i = 0; i < e.length; i++) { var n = e[i],
                            r = Ll.parse(n);
                        void 0 !== n.uuid && (r.uuid = n.uuid), t.push(r) } return t }, parseImages: function(e, t) { var i = this,
                        n = {};

                    function r(e) { return i.manager.itemStart(e), a.load(e, function() { i.manager.itemEnd(e) }, void 0, function() { i.manager.itemError(e), i.manager.itemEnd(e) }) } if (void 0 !== e && 0 < e.length) { var a = new zl(new Ol(t));
                        a.setCrossOrigin(this.crossOrigin); for (var o = 0, s = e.length; o < s; o++) { var l = e[o],
                                c = l.url; if (Array.isArray(c)) { n[l.uuid] = []; for (var h = 0, u = c.length; h < u; h++) { var d = c[h],
                                        p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(d) ? d : i.resourcePath + d;
                                    n[l.uuid].push(r(p)) } } else { p = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ? l.url : i.resourcePath + l.url;
                                n[l.uuid] = r(p) } } } return n }, parseTextures: function(e, t) {
                    function i(e, t) { return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), t[e]) } var n = {}; if (void 0 !== e)
                        for (var r = 0, a = e.length; r < a; r++) { var o, s = e[r];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (o = Array.isArray(t[s.image]) ? new Dr(t[s.image]) : new di(t[s.image])).needsUpdate = !0, o.uuid = s.uuid, void 0 !== s.name && (o.name = s.name), void 0 !== s.mapping && (o.mapping = i(s.mapping, Oc)), void 0 !== s.offset && o.offset.fromArray(s.offset), void 0 !== s.repeat && o.repeat.fromArray(s.repeat), void 0 !== s.center && o.center.fromArray(s.center), void 0 !== s.rotation && (o.rotation = s.rotation), void 0 !== s.wrap && (o.wrapS = i(s.wrap[0], Gc), o.wrapT = i(s.wrap[1], Gc)), void 0 !== s.format && (o.format = s.format), void 0 !== s.type && (o.type = s.type), void 0 !== s.encoding && (o.encoding = s.encoding), void 0 !== s.minFilter && (o.minFilter = i(s.minFilter, Dc)), void 0 !== s.magFilter && (o.magFilter = i(s.magFilter, Dc)), void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy), void 0 !== s.flipY && (o.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (o.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (o.unpackAlignment = s.unpackAlignment), n[s.uuid] = o }
                    return n }, parseObject: function(e, t, a) { var i;

                    function n(e) { return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), t[e] }

                    function r(e) { if (void 0 !== e) { if (Array.isArray(e)) { for (var t = [], i = 0, n = e.length; i < n; i++) { var r = e[i];
                                    void 0 === a[r] && console.warn("THREE.ObjectLoader: Undefined material", r), t.push(a[r]) } return t } return void 0 === a[e] && console.warn("THREE.ObjectLoader: Undefined material", e), a[e] } } switch (e.type) {
                        case "Scene":
                            i = new Co, void 0 !== e.background && Number.isInteger(e.background) && (i.background = new Li(e.background)), void 0 !== e.fog && ("Fog" === e.fog.type ? i.fog = new Ao(e.fog.color, e.fog.near, e.fog.far) : "FogExp2" === e.fog.type && (i.fog = new Po(e.fog.color, e.fog.density))); break;
                        case "PerspectiveCamera":
                            i = new io(e.fov, e.aspect, e.near, e.far), void 0 !== e.focus && (i.focus = e.focus), void 0 !== e.zoom && (i.zoom = e.zoom), void 0 !== e.filmGauge && (i.filmGauge = e.filmGauge), void 0 !== e.filmOffset && (i.filmOffset = e.filmOffset), void 0 !== e.view && (i.view = Object.assign({}, e.view)); break;
                        case "OrthographicCamera":
                            i = new Mc(e.left, e.right, e.top, e.bottom, e.near, e.far), void 0 !== e.zoom && (i.zoom = e.zoom), void 0 !== e.view && (i.view = Object.assign({}, e.view)); break;
                        case "AmbientLight":
                            i = new _c(e.color, e.intensity); break;
                        case "DirectionalLight":
                            i = new bc(e.color, e.intensity); break;
                        case "PointLight":
                            i = new vc(e.color, e.intensity, e.distance, e.decay); break;
                        case "RectAreaLight":
                            i = new xc(e.color, e.intensity, e.width, e.height); break;
                        case "SpotLight":
                            i = new gc(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay); break;
                        case "HemisphereLight":
                            i = new pc(e.color, e.groundColor, e.intensity); break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var o = n(e.geometry),
                                s = r(e.material);
                            i = o.bones && 0 < o.bones.length ? new Do(o, s) : new Tr(o, s), void 0 !== e.drawMode && i.setDrawMode(e.drawMode); break;
                        case "LOD":
                            i = new Go; break;
                        case "Line":
                            i = new Fo(n(e.geometry), r(e.material), e.mode); break;
                        case "LineLoop":
                            i = new ko(n(e.geometry), r(e.material)); break;
                        case "LineSegments":
                            i = new zo(n(e.geometry), r(e.material)); break;
                        case "PointCloud":
                        case "Points":
                            i = new Vo(n(e.geometry), r(e.material)); break;
                        case "Sprite":
                            i = new Oo(r(e.material)); break;
                        case "Group":
                            i = new eo; break;
                        default:
                            i = new on } if (i.uuid = e.uuid, void 0 !== e.name && (i.name = e.name), void 0 !== e.matrix ? (i.matrix.fromArray(e.matrix), void 0 !== e.matrixAutoUpdate && (i.matrixAutoUpdate = e.matrixAutoUpdate), i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale)) : (void 0 !== e.position && i.position.fromArray(e.position), void 0 !== e.rotation && i.rotation.fromArray(e.rotation), void 0 !== e.quaternion && i.quaternion.fromArray(e.quaternion), void 0 !== e.scale && i.scale.fromArray(e.scale)), void 0 !== e.castShadow && (i.castShadow = e.castShadow), void 0 !== e.receiveShadow && (i.receiveShadow = e.receiveShadow), e.shadow && (void 0 !== e.shadow.bias && (i.shadow.bias = e.shadow.bias), void 0 !== e.shadow.radius && (i.shadow.radius = e.shadow.radius), void 0 !== e.shadow.mapSize && i.shadow.mapSize.fromArray(e.shadow.mapSize), void 0 !== e.shadow.camera && (i.shadow.camera = this.parseObject(e.shadow.camera))), void 0 !== e.visible && (i.visible = e.visible), void 0 !== e.frustumCulled && (i.frustumCulled = e.frustumCulled), void 0 !== e.renderOrder && (i.renderOrder = e.renderOrder), void 0 !== e.userData && (i.userData = e.userData), void 0 !== e.layers && (i.layers.mask = e.layers), void 0 !== e.children)
                        for (var l = e.children, c = 0; c < l.length; c++) i.add(this.parseObject(l[c], t, a)); if ("LOD" === e.type)
                        for (var h = e.levels, u = 0; u < h.length; u++) { var d = h[u],
                                p = i.getObjectByProperty("uuid", d.object);
                            void 0 !== p && i.addLevel(p, d.distance) }
                    return i } }); var Ac, Cc, Lc, Rc, Hc, Oc = { UVMapping: 300, CubeReflectionMapping: ve, CubeRefractionMapping: Me, EquirectangularReflectionMapping: ye, EquirectangularRefractionMapping: be, SphericalReflectionMapping: _e, CubeUVReflectionMapping: we, CubeUVRefractionMapping: Se },
                Gc = { RepeatWrapping: Ee, ClampToEdgeWrapping: Pe, MirroredRepeatWrapping: Ae },
                Dc = { NearestFilter: Ce, NearestMipMapNearestFilter: Le, NearestMipMapLinearFilter: Re, LinearFilter: He, LinearMipMapNearestFilter: Oe, LinearMipMapLinearFilter: Ge };

            function Ic(e) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== e ? e : Gl, this.options = void 0 }

            function Bc() { this.type = "ShapePath", this.color = new Li, this.subPaths = [], this.currentPath = null }

            function Nc(e) { this.type = "Font", this.data = e }

            function Fc(e, t, i, n, r) { var a = r.glyphs[e] || r.glyphs["?"]; if (a) { var o, s, l, c, h, u, d, p, f = new Bc; if (a.o)
                        for (var m = a._cachedOutline || (a._cachedOutline = a.o.split(" ")), g = 0, v = m.length; g < v;) { switch (m[g++]) {
                                case "m":
                                    o = m[g++] * t + i, s = m[g++] * t + n, f.moveTo(o, s); break;
                                case "l":
                                    o = m[g++] * t + i, s = m[g++] * t + n, f.lineTo(o, s); break;
                                case "q":
                                    l = m[g++] * t + i, c = m[g++] * t + n, h = m[g++] * t + i, u = m[g++] * t + n, f.quadraticCurveTo(h, u, l, c); break;
                                case "b":
                                    l = m[g++] * t + i, c = m[g++] * t + n, h = m[g++] * t + i, u = m[g++] * t + n, d = m[g++] * t + i, p = m[g++] * t + n, f.bezierCurveTo(h, u, d, p, l, c) } }
                    return { offsetX: a.ha * t, path: f } } }

            function zc(e) { this.manager = void 0 !== e ? e : Gl }

            function kc() {}
            Ic.prototype = { constructor: Ic, setOptions: function(e) { return this.options = e, this }, load: function(t, i, e, n) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); var r = this,
                        a = Hl.get(t); if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function() { i && i(a), r.manager.itemEnd(t) }, 0), a;
                    fetch(t).then(function(e) { return e.blob() }).then(function(e) { return createImageBitmap(e, r.options) }).then(function(e) { Hl.add(t, e), i && i(e), r.manager.itemEnd(t) }).catch(function(e) { n && n(e), r.manager.itemError(t), r.manager.itemEnd(t) }), r.manager.itemStart(t) }, setCrossOrigin: function() { return this }, setPath: function(e) { return this.path = e, this } }, Object.assign(Bc.prototype, { moveTo: function(e, t) { this.currentPath = new hc, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t) }, lineTo: function(e, t) { this.currentPath.lineTo(e, t) }, quadraticCurveTo: function(e, t, i, n) { this.currentPath.quadraticCurveTo(e, t, i, n) }, bezierCurveTo: function(e, t, i, n, r, a) { this.currentPath.bezierCurveTo(e, t, i, n, r, a) }, splineThru: function(e) { this.currentPath.splineThru(e) }, toShapes: function(e, t) {
                    function i(e) { for (var t = [], i = 0, n = e.length; i < n; i++) { var r = e[i],
                                a = new uc;
                            a.curves = r.curves, t.push(a) } return t }

                    function n(e, t) { for (var i = t.length, n = !1, r = i - 1, a = 0; a < i; r = a++) { var o = t[r],
                                s = t[a],
                                l = s.x - o.x,
                                c = s.y - o.y; if (Math.abs(c) > Number.EPSILON) { if (c < 0 && (o = t[a], l = -l, s = t[r], c = -c), e.y < o.y || e.y > s.y) continue; if (e.y === o.y) { if (e.x === o.x) return !0 } else { var h = c * (e.x - o.x) - l * (e.y - o.y); if (0 === h) return !0; if (h < 0) continue;
                                    n = !n } } else { if (e.y !== o.y) continue; if (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x) return !0 } } return n } var r = Gs.isClockWise,
                        a = this.subPaths; if (0 === a.length) return []; if (!0 === t) return i(a); var o, s, l, c = []; if (1 === a.length) return s = a[0], (l = new uc).curves = s.curves, c.push(l), c; var h = !r(a[0].getPoints());
                    h = e ? !h : h; var u, d, p = [],
                        f = [],
                        m = [],
                        g = 0;
                    f[g] = void 0, m[g] = []; for (var v = 0, M = a.length; v < M; v++) o = r(u = (s = a[v]).getPoints()), (o = e ? !o : o) ? (!h && f[g] && g++, f[g] = { s: new uc, p: u }, f[g].s.curves = s.curves, h && g++, m[g] = []) : m[g].push({ h: s, p: u[0] }); if (!f[0]) return i(a); if (1 < f.length) { for (var y = !1, b = [], _ = 0, x = f.length; _ < x; _++) p[_] = []; for (_ = 0, x = f.length; _ < x; _++)
                            for (var T = m[_], w = 0; w < T.length; w++) { for (var S = T[w], E = !0, P = 0; P < f.length; P++) n(S.p, f[P].p) && (_ !== P && b.push({ froms: _, tos: P, hole: w }), E ? (E = !1, p[P].push(S)) : y = !0);
                                E && p[_].push(S) }
                        0 < b.length && (y || (m = p)) }
                    v = 0; for (var A = f.length; v < A; v++) { l = f[v].s, c.push(l); for (var C = 0, L = (d = m[v]).length; C < L; C++) l.holes.push(d[C].h) } return c } }), Object.assign(Nc.prototype, { isFont: !0, generateShapes: function(e, t) { void 0 === t && (t = 100); for (var i = [], n = function(e, t, i) { for (var n = Array.from ? Array.from(e) : String(e).split(""), r = t / i.resolution, a = (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r, o = [], s = 0, l = 0, c = 0; c < n.length; c++) { var h = n[c]; if ("\n" === h) s = 0, l -= a;
                                else { var u = Fc(h, r, s, l, i);
                                    s += u.offsetX, o.push(u.path) } } return o }(e, t, this.data), r = 0, a = n.length; r < a; r++) Array.prototype.push.apply(i, n[r].toShapes()); return i } }), Object.assign(zc.prototype, { load: function(e, n, t, i) { var r = this,
                        a = new Il(this.manager);
                    a.setPath(this.path), a.load(e, function(t) { var i; try { i = JSON.parse(t) } catch (e) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2)) } var e = r.parse(i);
                        n && n(e) }, t, i) }, parse: function(e) { return new Nc(e) }, setPath: function(e) { return this.path = e, this } }), kc.Handlers = { handlers: [], add: function(e, t) { this.handlers.push(e, t) }, get: function(e) { for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) { var r = t[i],
                            a = t[i + 1]; if (r.test(e)) return a } return null } }, Object.assign(kc.prototype, { crossOrigin: "anonymous", onLoadStart: function() {}, onLoadProgress: function() {}, onLoadComplete: function() {}, initMaterials: function(e, t, i) { for (var n = [], r = 0; r < e.length; ++r) n[r] = this.createMaterial(e[r], t, i); return n }, createMaterial: (Ac = { NoBlending: Z, NormalBlending: J, AdditiveBlending: K, SubtractiveBlending: Q, MultiplyBlending: $, CustomBlending: te }, Cc = new Li, Lc = new Ul, Rc = new Tc, function(e, c, h) { var u = {};

                    function t(e, t, i, n, r) { var a, o = c + e,
                            s = kc.Handlers.get(o);
                        a = null !== s ? s.load(o) : (Lc.setCrossOrigin(h), Lc.load(o)), void 0 !== t && (a.repeat.fromArray(t), 1 !== t[0] && (a.wrapS = Ee), 1 !== t[1] && (a.wrapT = Ee)), void 0 !== i && a.offset.fromArray(i), void 0 !== n && ("repeat" === n[0] && (a.wrapS = Ee), "mirror" === n[0] && (a.wrapS = Ae), "repeat" === n[1] && (a.wrapT = Ee), "mirror" === n[1] && (a.wrapT = Ae)), void 0 !== r && (a.anisotropy = r); var l = Ut.generateUUID(); return u[l] = a, l } var i = { uuid: Ut.generateUUID(), type: "MeshLambertMaterial" }; for (var n in e) { var r = e[n]; switch (n) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                i.name = r; break;
                            case "blending":
                                i.blending = Ac[r]; break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", n, "is no longer supported."); break;
                            case "colorDiffuse":
                                i.color = Cc.fromArray(r).getHex(); break;
                            case "colorSpecular":
                                i.specular = Cc.fromArray(r).getHex(); break;
                            case "colorEmissive":
                                i.emissive = Cc.fromArray(r).getHex(); break;
                            case "specularCoef":
                                i.shininess = r; break;
                            case "shading":
                                "basic" === r.toLowerCase() && (i.type = "MeshBasicMaterial"), "phong" === r.toLowerCase() && (i.type = "MeshPhongMaterial"), "standard" === r.toLowerCase() && (i.type = "MeshStandardMaterial"); break;
                            case "mapDiffuse":
                                i.map = t(r, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy); break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                i.emissiveMap = t(r, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy); break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                i.lightMap = t(r, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy); break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                i.aoMap = t(r, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy); break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                i.bumpMap = t(r, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy); break;
                            case "mapBumpScale":
                                i.bumpScale = r; break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                i.normalMap = t(r, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy); break;
                            case "mapNormalFactor":
                                i.normalScale = r; break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                i.specularMap = t(r, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy); break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                i.metalnessMap = t(r, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy); break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                i.roughnessMap = t(r, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy); break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                i.alphaMap = t(r, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy); break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                i.side = xe; break;
                            case "doubleSided":
                                i.side = ee; break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), i.opacity = r; break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                i[n] = r; break;
                            case "vertexColors":
                                !0 === r && (i.vertexColors = S), "face" === r && (i.vertexColors = 1); break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", n, r) } } return "MeshBasicMaterial" === i.type && delete i.emissive, "MeshPhongMaterial" !== i.type && delete i.specular, i.opacity < 1 && (i.transparent = !0), Rc.setTextures(u), Rc.parse(i) }) }); var Uc, Vc, jc, Wc, Xc, Yc, qc, Zc, Jc, Kc, Qc, $c, eh, th, ih, nh, rh, ah, oh, sh = { getContext: function() { return void 0 === Hc && (Hc = new(window.AudioContext || window.webkitAudioContext)), Hc }, setContext: function(e) { Hc = e } };

            function lh(e) { this.manager = void 0 !== e ? e : Gl }

            function ch() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new io, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new io, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1 }

            function hh(e, t, i, n) { on.call(this), this.type = "CubeCamera"; var a = new io(90, 1, e, t);
                a.up.set(0, -1, 0), a.lookAt(new Xt(1, 0, 0)), this.add(a); var o = new io(90, 1, e, t);
                o.up.set(0, -1, 0), o.lookAt(new Xt(-1, 0, 0)), this.add(o); var s = new io(90, 1, e, t);
                s.up.set(0, 0, 1), s.lookAt(new Xt(0, 1, 0)), this.add(s); var l = new io(90, 1, e, t);
                l.up.set(0, 0, -1), l.lookAt(new Xt(0, -1, 0)), this.add(l); var c = new io(90, 1, e, t);
                c.up.set(0, -1, 0), c.lookAt(new Xt(0, 0, 1)), this.add(c); var h = new io(90, 1, e, t);
                h.up.set(0, -1, 0), h.lookAt(new Xt(0, 0, -1)), this.add(h), n = n || { format: qe, magFilter: He, minFilter: He }, this.renderTarget = new gi(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function(e, t) { null === this.parent && this.updateMatrixWorld(); var i = e.getRenderTarget(),
                        n = this.renderTarget,
                        r = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, a), e.setRenderTarget(n, 1), e.render(t, o), e.setRenderTarget(n, 2), e.render(t, s), e.setRenderTarget(n, 3), e.render(t, l), e.setRenderTarget(n, 4), e.render(t, c), n.texture.generateMipmaps = r, e.setRenderTarget(n, 5), e.render(t, h), e.setRenderTarget(i) }, this.clear = function(e, t, i, n) { for (var r = e.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++) e.setRenderTarget(a, o), e.clear(t, i, n);
                    e.setRenderTarget(r) } }

            function uh(e) { this.autoStart = void 0 === e || e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 }

            function dh() { on.call(this), this.type = "AudioListener", this.context = sh.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0 }

            function ph(e) { on.call(this), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [] }

            function fh(e) { ph.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain) }

            function mh(e, t) { this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser) }

            function gh(e, t, i) { this.binding = e, this.valueSize = i; var n, r = Float64Array; switch (t) {
                    case "quaternion":
                        n = this._slerp; break;
                    case "string":
                    case "bool":
                        r = Array, n = this._select; break;
                    default:
                        n = this._lerp }
                this.buffer = new r(4 * i), this._mixBufferRegion = n, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0 }
            Object.assign(lh.prototype, { load: function(e, i, t, n) { var r = new Il(this.manager);
                    r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(e, function(e) { var t = e.slice(0);
                        sh.getContext().decodeAudioData(t, function(e) { i(e) }) }, t, n) }, setPath: function(e) { return this.path = e, this } }), Object.assign(ch.prototype, { update: (Jc = new jt, Kc = new jt, function(e) { if (Uc !== this || Vc !== e.focus || jc !== e.fov || Wc !== e.aspect * this.aspect || Xc !== e.near || Yc !== e.far || qc !== e.zoom || Zc !== this.eyeSep) { Uc = this, Vc = e.focus, jc = e.fov, Wc = e.aspect * this.aspect, Xc = e.near, Yc = e.far, qc = e.zoom; var t, i, n = e.projectionMatrix.clone(),
                            r = (Zc = this.eyeSep / 2) * Xc / Vc,
                            a = Xc * Math.tan(Ut.DEG2RAD * jc * .5) / qc;
                        Kc.elements[12] = -Zc, Jc.elements[12] = Zc, t = -a * Wc + r, i = a * Wc + r, n.elements[0] = 2 * Xc / (i - t), n.elements[8] = (i + t) / (i - t), this.cameraL.projectionMatrix.copy(n), t = -a * Wc - r, i = a * Wc - r, n.elements[0] = 2 * Xc / (i - t), n.elements[8] = (i + t) / (i - t), this.cameraR.projectionMatrix.copy(n) }
                    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Kc), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Jc) }) }), (hh.prototype = Object.create(on.prototype)).constructor = hh, Object.assign(uh.prototype, { start: function() { this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 }, stop: function() { this.getElapsedTime(), this.running = !1, this.autoStart = !1 }, getElapsedTime: function() { return this.getDelta(), this.elapsedTime }, getDelta: function() { var e = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { var t = ("undefined" == typeof performance ? Date : performance).now();
                        e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e } return e } }), dh.prototype = Object.assign(Object.create(on.prototype), { constructor: dh, getInput: function() { return this.gain }, removeFilter: function() { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }, getFilter: function() { return this.filter }, setFilter: function(e) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }, getMasterVolume: function() { return this.gain.gain.value }, setMasterVolume: function(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this }, updateMatrixWorld: (Qc = new Xt, $c = new Wt, eh = new Xt, th = new Xt, ih = new uh, function(e) { on.prototype.updateMatrixWorld.call(this, e); var t = this.context.listener,
                        i = this.up; if (this.timeDelta = ih.getDelta(), this.matrixWorld.decompose(Qc, $c, eh), th.set(0, 0, -1).applyQuaternion($c), t.positionX) { var n = this.context.currentTime + this.timeDelta;
                        t.positionX.linearRampToValueAtTime(Qc.x, n), t.positionY.linearRampToValueAtTime(Qc.y, n), t.positionZ.linearRampToValueAtTime(Qc.z, n), t.forwardX.linearRampToValueAtTime(th.x, n), t.forwardY.linearRampToValueAtTime(th.y, n), t.forwardZ.linearRampToValueAtTime(th.z, n), t.upX.linearRampToValueAtTime(i.x, n), t.upY.linearRampToValueAtTime(i.y, n), t.upZ.linearRampToValueAtTime(i.z, n) } else t.setPosition(Qc.x, Qc.y, Qc.z), t.setOrientation(th.x, th.y, th.z, i.x, i.y, i.z) }) }), ph.prototype = Object.assign(Object.create(on.prototype), { constructor: ph, getOutput: function() { return this.gain }, setNodeSource: function(e) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this }, setMediaElementSource: function(e) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this }, setBuffer: function(e) { return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this }, play: function() { if (!0 !== this.isPlaying) { if (!1 !== this.hasPlaybackControl) { var e = this.context.createBufferSource(); return e.buffer = this.buffer, e.loop = this.loop, e.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, e.start(this.startTime, this.offset), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() }
                        console.warn("THREE.Audio: this Audio has no playback control.") } else console.warn("THREE.Audio: Audio is already playing.") }, pause: function() { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.") }, stop: function() { if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.") }, connect: function() { if (0 < this.filters.length) { this.source.connect(this.filters[0]); for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
                        this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function() { if (0 < this.filters.length) { this.source.disconnect(this.filters[0]); for (var e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function() { return this.filters }, setFilters: function(e) { return e || (e = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = e, this.connect()) : this.filters = e, this }, setDetune: function(e) { if (this.detune = e, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }, getDetune: function() { return this.detune }, getFilter: function() { return this.getFilters()[0] }, setFilter: function(e) { return this.setFilters(e ? [e] : []) }, setPlaybackRate: function(e) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = e, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.") }, getPlaybackRate: function() { return this.playbackRate }, onEnded: function() { this.isPlaying = !1 }, getLoop: function() { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, setLoop: function(e) { if (!1 !== this.hasPlaybackControl) return this.loop = e, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.") }, getVolume: function() { return this.gain.gain.value }, setVolume: function(e) { return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this } }), fh.prototype = Object.assign(Object.create(ph.prototype), { constructor: fh, getOutput: function() { return this.panner }, getRefDistance: function() { return this.panner.refDistance }, setRefDistance: function(e) { return this.panner.refDistance = e, this }, getRolloffFactor: function() { return this.panner.rolloffFactor }, setRolloffFactor: function(e) { return this.panner.rolloffFactor = e, this }, getDistanceModel: function() { return this.panner.distanceModel }, setDistanceModel: function(e) { return this.panner.distanceModel = e, this }, getMaxDistance: function() { return this.panner.maxDistance }, setMaxDistance: function(e) { return this.panner.maxDistance = e, this }, setDirectionalCone: function(e, t, i) { return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this }, updateMatrixWorld: (nh = new Xt, rh = new Wt, ah = new Xt, oh = new Xt, function(e) { if (on.prototype.updateMatrixWorld.call(this, e), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) { this.matrixWorld.decompose(nh, rh, ah), oh.set(0, 0, 1).applyQuaternion(rh); var t = this.panner; if (t.positionX) { var i = this.context.currentTime + this.listener.timeDelta;
                            t.positionX.linearRampToValueAtTime(nh.x, i), t.positionY.linearRampToValueAtTime(nh.y, i), t.positionZ.linearRampToValueAtTime(nh.z, i), t.orientationX.linearRampToValueAtTime(oh.x, i), t.orientationY.linearRampToValueAtTime(oh.y, i), t.orientationZ.linearRampToValueAtTime(oh.z, i) } else t.setPosition(nh.x, nh.y, nh.z), t.setOrientation(oh.x, oh.y, oh.z) } }) }), Object.assign(mh.prototype, { getFrequencyData: function() { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function() { for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++) e += t[i]; return e / t.length } }), Object.assign(gh.prototype, { accumulate: function(e, t) { var i = this.buffer,
                        n = this.valueSize,
                        r = e * n + n,
                        a = this.cumulativeWeight; if (0 === a) { for (var o = 0; o !== n; ++o) i[r + o] = i[o];
                        a = t } else { var s = t / (a += t);
                        this._mixBufferRegion(i, r, 0, s, n) }
                    this.cumulativeWeight = a }, apply: function(e) { var t = this.valueSize,
                        i = this.buffer,
                        n = e * t + t,
                        r = this.cumulativeWeight,
                        a = this.binding; if (this.cumulativeWeight = 0, r < 1) { var o = 3 * t;
                        this._mixBufferRegion(i, n, o, 1 - r, t) } for (var s = t, l = t + t; s !== l; ++s)
                        if (i[s] !== i[s + t]) { a.setValue(i, n); break } }, saveOriginalState: function() { var e = this.binding,
                        t = this.buffer,
                        i = this.valueSize,
                        n = 3 * i;
                    e.getValue(t, n); for (var r = i, a = n; r !== a; ++r) t[r] = t[n + r % i];
                    this.cumulativeWeight = 0 }, restoreOriginalState: function() { var e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e) }, _select: function(e, t, i, n, r) { if (.5 <= n)
                        for (var a = 0; a !== r; ++a) e[t + a] = e[i + a] }, _slerp: function(e, t, i, n) { Wt.slerpFlat(e, t, e, t, e, i, n) }, _lerp: function(e, t, i, n, r) { for (var a = 1 - n, o = 0; o !== r; ++o) { var s = t + o;
                        e[s] = e[s] * a + e[i + o] * n } } }); var vh, Mh, yh, bh, _h, xh, Th, wh, Sh, Eh, Ph, Ah, Ch, Lh, Rh, Hh, Oh, Gh, Dh, Ih, Bh, Nh, Fh, zh, kh, Uh, Vh, jh, Wh, Xh, Yh, qh, Zh, Jh, Kh = "\\[\\]\\.:\\/";

            function Qh(e, t, i) { var n = i || $h.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, n) }

            function $h(e, t, i) { this.path = t, this.parsedPath = i || $h.parseTrackName(t), this.node = $h.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e }

            function eu() { this.uuid = Ut.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; var e = {};
                this._indicesByUUID = e; for (var t = 0, i = arguments.length; t !== i; ++t) e[arguments[t].uuid] = t;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; var n = this;
                this.stats = { objects: {get total() { return n._objects.length }, get inUse() { return this.total - n.nCachedObjects_ } }, get bindingsPerObject() { return n._bindings.length } } }

            function tu(e, t, i) { this._mixer = e, this._clip = t, this._localRoot = i || null; for (var n = t.tracks, r = n.length, a = new Array(r), o = { endingStart: Pt, endingEnd: Pt }, s = 0; s !== r; ++s) { var l = n[s].createInterpolant(null);
                    (a[s] = l).settings = o }
                this._interpolantSettings = o, this._interpolants = a, this._propertyBindings = new Array(r), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 }

            function iu(e) { this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 }

            function nu(e) { "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."), e = arguments[1]), this.value = e }

            function ru() { Fn.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0 }

            function au(e, t, i) { Lo.call(this, e, t), this.meshPerAttribute = i || 1 }

            function ou(e, t, i, n) { "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), gn.call(this, e, t, i), this.meshPerAttribute = n || 1 }

            function su(e, t, i, n) { this.ray = new br(e, t), this.near = i || 0, this.far = n || 1 / 0, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function() { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) }

            function lu(e, t) { return e.distance - t.distance }

            function cu(e, t, i, n) { if (!1 !== e.visible && (e.raycast(t, i), !0 === n))
                    for (var r = e.children, a = 0, o = r.length; a < o; a++) cu(r[a], t, i, !0) }

            function hu(e, t, i) { return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== i ? i : 0, this }

            function uu(e, t, i) { return this.radius = void 0 !== e ? e : 1, this.theta = void 0 !== t ? t : 0, this.y = void 0 !== i ? i : 0, this }

            function du(e, t) { this.min = void 0 !== e ? e : new Vt(1 / 0, 1 / 0), this.max = void 0 !== t ? t : new Vt(-1 / 0, -1 / 0) }

            function pu(e, t) { this.start = void 0 !== e ? e : new Xt, this.end = void 0 !== t ? t : new Xt }

            function fu(e) { on.call(this), this.material = e, this.render = function() {} }

            function mu(e, t, i, n) { this.object = e, this.size = void 0 !== t ? t : 1; var r = void 0 !== i ? i : 16711680,
                    a = void 0 !== n ? n : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = 3 * s.faces.length : s && s.isBufferGeometry && (o = s.attributes.normal.count); var l = new Fn,
                    c = new wn(2 * o * 3, 3);
                l.addAttribute("position", c), zo.call(this, l, new No({ color: r, linewidth: a })), this.matrixAutoUpdate = !1, this.update() }

            function gu(e, t) { on.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = t; for (var i = new Fn, n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], r = 0, a = 1; r < 32; r++, a++) { var o = r / 32 * Math.PI * 2,
                        s = a / 32 * Math.PI * 2;
                    n.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1) }
                i.addAttribute("position", new wn(n, 3)); var l = new No({ fog: !1 });
                this.cone = new zo(i, l), this.add(this.cone), this.update() }

            function vu(e) { for (var t = function e(t) { var i = [];
                        t && t.isBone && i.push(t); for (var n = 0; n < t.children.length; n++) i.push.apply(i, e(t.children[n])); return i }(e), i = new Fn, n = [], r = [], a = new Li(0, 0, 1), o = new Li(0, 1, 0), s = 0; s < t.length; s++) { var l = t[s];
                    l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b)) }
                i.addAttribute("position", new wn(n, 3)), i.addAttribute("color", new wn(r, 3)); var c = new No({ vertexColors: S, depthTest: !1, depthWrite: !1, transparent: !0 });
                zo.call(this, i, c), this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1 }

            function Mu(e, t, i) { this.light = e, this.light.updateMatrixWorld(), this.color = i; var n = new js(t, 4, 2),
                    r = new xr({ wireframe: !0, fog: !1 });
                Tr.call(this, n, r), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() }

            function yu(e, t) { this.type = "RectAreaLightHelper", this.light = e, this.color = t; var i = new Fn;
                i.addAttribute("position", new wn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), i.computeBoundingSphere(); var n = new No({ fog: !1 });
                Fo.call(this, i, n); var r = new Fn;
                r.addAttribute("position", new wn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), r.computeBoundingSphere(), this.add(new Tr(r, new xr({ side: xe, fog: !1 }))), this.update() }

            function bu(e, t, i) { on.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i; var n = new is(t);
                n.rotateY(.5 * Math.PI), this.material = new xr({ wireframe: !0, fog: !1 }), void 0 === this.color && (this.material.vertexColors = S); var r = n.getAttribute("position"),
                    a = new Float32Array(3 * r.count);
                n.addAttribute("color", new gn(a, 3)), this.add(new Tr(n, this.material)), this.update() }

            function _u(e, t, i, n) { e = e || 10, t = t || 10, i = new Li(void 0 !== i ? i : 4473924), n = new Li(void 0 !== n ? n : 8947848); for (var r = t / 2, a = e / t, o = e / 2, s = [], l = [], c = 0, h = 0, u = -o; c <= t; c++, u += a) { s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o); var d = c === r ? i : n;
                    d.toArray(l, h), h += 3, d.toArray(l, h), h += 3, d.toArray(l, h), h += 3, d.toArray(l, h), h += 3 } var p = new Fn;
                p.addAttribute("position", new wn(s, 3)), p.addAttribute("color", new wn(l, 3)); var f = new No({ vertexColors: S });
                zo.call(this, p, f) }

            function xu(e, t, i, n, r, a) { e = e || 10, t = t || 16, i = i || 8, n = n || 64, r = new Li(void 0 !== r ? r : 4473924), a = new Li(void 0 !== a ? a : 8947848); var o, s, l, c, h, u, d, p = [],
                    f = []; for (c = 0; c <= t; c++) l = c / t * (2 * Math.PI), o = Math.sin(l) * e, s = Math.cos(l) * e, p.push(0, 0, 0), p.push(o, 0, s), d = 1 & c ? r : a, f.push(d.r, d.g, d.b), f.push(d.r, d.g, d.b); for (c = 0; c <= i; c++)
                    for (d = 1 & c ? r : a, u = e - e / i * c, h = 0; h < n; h++) l = h / n * (2 * Math.PI), o = Math.sin(l) * u, s = Math.cos(l) * u, p.push(o, 0, s), f.push(d.r, d.g, d.b), l = (h + 1) / n * (2 * Math.PI), o = Math.sin(l) * u, s = Math.cos(l) * u, p.push(o, 0, s), f.push(d.r, d.g, d.b); var m = new Fn;
                m.addAttribute("position", new wn(p, 3)), m.addAttribute("color", new wn(f, 3)); var g = new No({ vertexColors: S });
                zo.call(this, m, g) }

            function Tu(e, t, i, n) { this.audio = e, this.range = t || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = n || 2; var r = new Fn,
                    a = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle,
                    o = new Float32Array(3 * (3 * a + 3));
                r.addAttribute("position", new gn(o, 3)); var s = new No({ color: 65280 }),
                    l = new No({ color: 16776960 });
                Fo.call(this, r, [l, s]), this.update() }

            function wu(e, t, i, n) { this.object = e, this.size = void 0 !== t ? t : 1; var r = void 0 !== i ? i : 16776960,
                    a = void 0 !== n ? n : 1,
                    o = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? o = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."); var l = new Fn,
                    c = new wn(2 * o * 3, 3);
                l.addAttribute("position", c), zo.call(this, l, new No({ color: r, linewidth: a })), this.matrixAutoUpdate = !1, this.update() }

            function Su(e, t, i) { on.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === t && (t = 1); var n = new Fn;
                n.addAttribute("position", new wn([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)); var r = new No({ fog: !1 });
                this.lightPlane = new Fo(n, r), this.add(this.lightPlane), (n = new Fn).addAttribute("position", new wn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Fo(n, r), this.add(this.targetLine), this.update() }

            function Eu(e) { var t = new Fn,
                    i = new No({ color: 16777215, vertexColors: 1 }),
                    n = [],
                    r = [],
                    a = {},
                    o = new Li(16755200),
                    s = new Li(16711680),
                    l = new Li(43775),
                    c = new Li(16777215),
                    h = new Li(3355443);

                function u(e, t, i) { d(e, i), d(t, i) }

                function d(e, t) { n.push(0, 0, 0), r.push(t.r, t.g, t.b), void 0 === a[e] && (a[e] = []), a[e].push(n.length / 3 - 1) }
                u("n1", "n2", o), u("n2", "n4", o), u("n4", "n3", o), u("n3", "n1", o), u("f1", "f2", o), u("f2", "f4", o), u("f4", "f3", o), u("f3", "f1", o), u("n1", "f1", o), u("n2", "f2", o), u("n3", "f3", o), u("n4", "f4", o), u("p", "n1", s), u("p", "n2", s), u("p", "n3", s), u("p", "n4", s), u("u1", "u2", l), u("u2", "u3", l), u("u3", "u1", l), u("c", "t", c), u("p", "c", h), u("cn1", "cn2", h), u("cn3", "cn4", h), u("cf1", "cf2", h), u("cf3", "cf4", h), t.addAttribute("position", new wn(n, 3)), t.addAttribute("color", new wn(r, 3)), zo.call(this, t, i), this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update() }

            function Pu(e, t) { this.object = e, void 0 === t && (t = 16776960); var i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    n = new Float32Array(24),
                    r = new Fn;
                r.setIndex(new gn(i, 1)), r.addAttribute("position", new gn(n, 3)), zo.call(this, r, new No({ color: t })), this.matrixAutoUpdate = !1, this.update() }

            function Au(e, t) { this.type = "Box3Helper", this.box = e; var i = void 0 !== t ? t : 16776960,
                    n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Fn;
                r.setIndex(new gn(n, 1)), r.addAttribute("position", new wn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), zo.call(this, r, new No({ color: i })), this.geometry.computeBoundingSphere() }

            function Cu(e, t, i) { this.type = "PlaneHelper", this.plane = e, this.size = void 0 === t ? 1 : t; var n = void 0 !== i ? i : 16776960,
                    r = new Fn;
                r.addAttribute("position", new wn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), r.computeBoundingSphere(), Fo.call(this, r, new No({ color: n })); var a = new Fn;
                a.addAttribute("position", new wn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), a.computeBoundingSphere(), this.add(new Tr(a, new xr({ color: n, opacity: .2, transparent: !0, depthWrite: !1 }))) }

            function Lu(e, t, i, n, r, a) { on.call(this), void 0 === e && (e = new Xt(0, 0, 1)), void 0 === t && (t = new Xt(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === r && (r = .2 * i), void 0 === a && (a = .2 * r), void 0 === Yh && ((Yh = new Fn).addAttribute("position", new wn([0, 0, 0, 0, 1, 0], 3)), (qh = new el(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(t), this.line = new Fo(Yh, new No({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Tr(qh, new xr({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, a) }

            function Ru(e) { var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
                    i = new Fn;
                i.addAttribute("position", new wn(t, 3)), i.addAttribute("color", new wn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)); var n = new No({ vertexColors: S });
                zo.call(this, i, n) }
            Object.assign(Qh.prototype, { getValue: function(e, t) { this.bind(); var i = this._targetGroup.nCachedObjects_,
                        n = this._bindings[i];
                    void 0 !== n && n.getValue(e, t) }, setValue: function(e, t) { for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(e, t) }, bind: function() { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind() }, unbind: function() { for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind() } }), Object.assign($h, { Composite: Qh, create: function(e, t, i) { return e && e.isAnimationObjectGroup ? new $h.Composite(e, t, i) : new $h(e, t, i) }, sanitizeNodeName: (Sh = new RegExp("[" + Kh + "]", "g"), function(e) { return e.replace(/\s/g, "_").replace(Sh, "") }), parseTrackName: (vh = "[^" + Kh + "]", Mh = "[^" + Kh.replace("\\.", "") + "]", yh = /((?:WC+[\/:])*)/.source.replace("WC", vh), bh = /(WCOD+)?/.source.replace("WCOD", Mh), _h = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", vh), xh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", vh), Th = new RegExp("^" + yh + bh + _h + xh + "$"), wh = ["material", "materials", "bones"], function(e) { var t = Th.exec(e); if (!t) throw new Error("PropertyBinding: Cannot parse trackName: " + e); var i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] },
                        n = i.nodeName && i.nodeName.lastIndexOf("."); if (void 0 !== n && -1 !== n) { var r = i.nodeName.substring(n + 1); - 1 !== wh.indexOf(r) && (i.nodeName = i.nodeName.substring(0, n), i.objectName = r) } if (null === i.propertyName || 0 === i.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e); return i }), findNode: function(e, r) { if (!r || "" === r || "root" === r || "." === r || -1 === r || r === e.name || r === e.uuid) return e; if (e.skeleton) { var t = e.skeleton.getBoneByName(r); if (void 0 !== t) return t } if (e.children) { var a = function(e) { for (var t = 0; t < e.length; t++) { var i = e[t]; if (i.name === r || i.uuid === r) return i; var n = a(i.children); if (n) return n } return null },
                            i = a(e.children); if (i) return i } return null } }), Object.assign($h.prototype, { _getValue_unavailable: function() {}, _setValue_unavailable: function() {}, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function(e, t) { e[t] = this.node[this.propertyName] }, function(e, t) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) e[t++] = i[n] }, function(e, t) { e[t] = this.resolvedProperty[this.propertyIndex] }, function(e, t) { this.resolvedProperty.toArray(e, t) }], SetterByBindingTypeAndVersioning: [
                    [function(e, t) { this.targetObject[this.propertyName] = e[t] }, function(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0 }, function(e, t) { this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }],
                    [function(e, t) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++] }, function(e, t) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                        this.targetObject.needsUpdate = !0 }, function(e, t) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0 }],
                    [function(e, t) { this.resolvedProperty[this.propertyIndex] = e[t] }, function(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0 }, function(e, t) { this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0 }],
                    [function(e, t) { this.resolvedProperty.fromArray(e, t) }, function(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0 }, function(e, t) { this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0 }]
                ], getValue: function(e, t) { this.bind(), this.getValue(e, t) }, setValue: function(e, t) { this.bind(), this.setValue(e, t) }, bind: function() { var e = this.node,
                        t = this.parsedPath,
                        i = t.objectName,
                        n = t.propertyName,
                        r = t.propertyIndex; if (e || (e = $h.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, e) { if (i) { var a = t.objectIndex; switch (i) {
                                case "materials":
                                    if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    e = e.material.materials; break;
                                case "bones":
                                    if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    e = e.skeleton.bones; for (var o = 0; o < e.length; o++)
                                        if (e[o].name === a) { a = o; break }
                                    break;
                                default:
                                    if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    e = e[i] } if (void 0 !== a) { if (void 0 === e[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                                e = e[a] } } var s = e[n]; if (void 0 !== s) { var l = this.Versioning.None;
                            void 0 !== (this.targetObject = e).needsUpdate ? l = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (l = this.Versioning.MatrixWorldNeedsUpdate); var c = this.BindingType.Direct; if (void 0 !== r) { if ("morphTargetInfluences" === n) { if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (e.geometry.isBufferGeometry) { if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++)
                                            if (e.geometry.morphAttributes.position[o].name === r) { r = o; break } } else { if (!e.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this); for (o = 0; o < this.node.geometry.morphTargets.length; o++)
                                            if (e.geometry.morphTargets[o].name === r) { r = o; break } } }
                                c = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r } else void 0 !== s.fromArray && void 0 !== s.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (c = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = n;
                            this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l] } else { var h = t.nodeName;
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + n + " but it wasn't found.", e) } } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.") }, unbind: function() { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign($h.prototype, { _getValue_unbound: $h.prototype.getValue, _setValue_unbound: $h.prototype.setValue }), Object.assign(eu.prototype, { isAnimationObjectGroup: !0, add: function() { for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, l = void 0, c = 0, h = arguments.length; c !== h; ++c) { var u = arguments[c],
                            d = u.uuid,
                            p = n[d]; if (void 0 === p) { p = t++, n[d] = p, e.push(u); for (var f = 0, m = s; f !== m; ++f) o[f].push(new $h(u, r[f], a[f])) } else if (p < i) { l = e[p]; var g = --i,
                                v = e[g];
                            e[n[v.uuid] = p] = v, e[n[d] = g] = u; for (f = 0, m = s; f !== m; ++f) { var M = o[f],
                                    y = M[g],
                                    b = M[p];
                                M[p] = y, void 0 === b && (b = new $h(u, r[f], a[f])), M[g] = b } } else e[p] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") }
                    this.nCachedObjects_ = i }, remove: function() { for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, a = 0, o = arguments.length; a !== o; ++a) { var s = arguments[a],
                            l = s.uuid,
                            c = i[l]; if (void 0 !== c && t <= c) { var h = t++,
                                u = e[h];
                            e[i[u.uuid] = c] = u, e[i[l] = h] = s; for (var d = 0, p = r; d !== p; ++d) { var f = n[d],
                                    m = f[h],
                                    g = f[c];
                                f[c] = m, f[h] = g } } }
                    this.nCachedObjects_ = t }, uncache: function() { for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) { var l = arguments[o].uuid,
                            c = n[l]; if (void 0 !== c)
                            if (delete n[l], c < i) { var h = --i,
                                    u = e[h],
                                    d = e[v = --t];
                                e[n[u.uuid] = c] = u, e[n[d.uuid] = h] = d, e.pop(); for (var p = 0, f = a; p !== f; ++p) { var m = (M = r[p])[h],
                                        g = M[v];
                                    M[c] = m, M[h] = g, M.pop() } } else { var v;
                                e[n[(d = e[v = --t]).uuid] = c] = d, e.pop(); for (p = 0, f = a; p !== f; ++p) { var M;
                                    (M = r[p])[c] = M[v], M.pop() } } }
                    this.nCachedObjects_ = i }, subscribe_: function(e, t) { var i = this._bindingsIndicesByPath,
                        n = i[e],
                        r = this._bindings; if (void 0 !== n) return r[n]; var a = this._paths,
                        o = this._parsedPaths,
                        s = this._objects,
                        l = s.length,
                        c = this.nCachedObjects_,
                        h = new Array(l);
                    n = r.length, i[e] = n, a.push(e), o.push(t), r.push(h); for (var u = c, d = s.length; u !== d; ++u) { var p = s[u];
                        h[u] = new $h(p, e, t) } return h }, unsubscribe_: function(e) { var t = this._bindingsIndicesByPath,
                        i = t[e]; if (void 0 !== i) { var n = this._paths,
                            r = this._parsedPaths,
                            a = this._bindings,
                            o = a.length - 1,
                            s = a[o];
                        a[t[e[o]] = i] = s, a.pop(), r[i] = r[o], r.pop(), n[i] = n[o], n.pop() } } }), Object.assign(tu.prototype, { play: function() { return this._mixer._activateAction(this), this }, stop: function() { return this._mixer._deactivateAction(this), this.reset() }, reset: function() { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function() { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function() { return this._mixer._isActiveAction(this) }, startAt: function(e) { return this._startTime = e, this }, setLoop: function(e, t) { return this.loop = e, this.repetitions = t, this }, setEffectiveWeight: function(e) { return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading() }, getEffectiveWeight: function() { return this._effectiveWeight }, fadeIn: function(e) { return this._scheduleFading(e, 0, 1) }, fadeOut: function(e) { return this._scheduleFading(e, 1, 0) }, crossFadeFrom: function(e, t, i) { if (e.fadeOut(t), this.fadeIn(t), i) { var n = this._clip.duration,
                            r = e._clip.duration,
                            a = r / n,
                            o = n / r;
                        e.warp(1, a, t), this.warp(o, 1, t) } return this }, crossFadeTo: function(e, t, i) { return e.crossFadeFrom(this, t, i) }, stopFading: function() { var e = this._weightInterpolant; return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this }, setEffectiveTimeScale: function(e) { return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping() }, getEffectiveTimeScale: function() { return this._effectiveTimeScale }, setDuration: function(e) { return this.timeScale = this._clip.duration / e, this.stopWarping() }, syncWith: function(e) { return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping() }, halt: function(e) { return this.warp(this._effectiveTimeScale, 0, e) }, warp: function(e, t, i) { var n = this._mixer,
                        r = n.time,
                        a = this._timeScaleInterpolant,
                        o = this.timeScale;
                    null === a && (a = n._lendControlInterpolant(), this._timeScaleInterpolant = a); var s = a.parameterPositions,
                        l = a.sampleValues; return s[0] = r, s[1] = r + i, l[0] = e / o, l[1] = t / o, this }, stopWarping: function() { var e = this._timeScaleInterpolant; return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this }, getMixer: function() { return this._mixer }, getClip: function() { return this._clip }, getRoot: function() { return this._localRoot || this._mixer._root }, _update: function(e, t, i, n) { if (this.enabled) { var r = this._startTime; if (null !== r) { var a = (e - r) * i; if (a < 0 || 0 === i) return;
                            this._startTime = null, t = i * a }
                        t *= this._updateTimeScale(e); var o = this._updateTime(t),
                            s = this._updateWeight(e); if (0 < s)
                            for (var l = this._interpolants, c = this._propertyBindings, h = 0, u = l.length; h !== u; ++h) l[h].evaluate(o), c[h].accumulate(n, s) } else this._updateWeight(e) }, _updateWeight: function(e) { var t = 0; if (this.enabled) { t = this.weight; var i = this._weightInterpolant; if (null !== i) { var n = i.evaluate(e)[0];
                            t *= n, e > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)) } } return this._effectiveWeight = t }, _updateTimeScale: function(e) { var t = 0; if (!this.paused) { t = this.timeScale; var i = this._timeScaleInterpolant; if (null !== i) t *= i.evaluate(e)[0], e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t) } return this._effectiveTimeScale = t }, _updateTime: function(e) { var t = this.time + e,
                        i = this._clip.duration,
                        n = this.loop,
                        r = this._loopCount,
                        a = 2202 === n; if (0 === e) return -1 === r ? t : a && 1 == (1 & r) ? i - t : t; if (2200 === n) {-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        e: { if (i <= t) t = i;
                            else { if (!(t < 0)) break e;
                                t = 0 }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 }) } } else { if (-1 === r && (0 <= e ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), i <= t || t < 0) { var o = Math.floor(t / i);
                            t -= i * o, r += Math.abs(o); var s = this.repetitions - r; if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = 0 < e ? i : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < e ? 1 : -1 });
                            else { if (1 === s) { var l = e < 0;
                                    this._setEndings(l, !l, a) } else this._setEndings(!1, !1, a);
                                this._loopCount = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: o }) } } if (a && 1 == (1 & r)) return i - (this.time = t) } return this.time = t }, _setEndings: function(e, t, i) { var n = this._interpolantSettings;
                    n.endingEnd = i ? n.endingStart = At : (n.endingStart = e ? this.zeroSlopeAtStart ? At : Pt : Ct, t ? this.zeroSlopeAtEnd ? At : Pt : Ct) }, _scheduleFading: function(e, t, i) { var n = this._mixer,
                        r = n.time,
                        a = this._weightInterpolant;
                    null === a && (a = n._lendControlInterpolant(), this._weightInterpolant = a); var o = a.parameterPositions,
                        s = a.sampleValues; return o[0] = r, s[0] = t, o[1] = r + e, s[1] = i, this } }), iu.prototype = Object.assign(Object.create(t.prototype), { constructor: iu, _bindAction: function(e, t) { var i = e._localRoot || this._root,
                        n = e._clip.tracks,
                        r = n.length,
                        a = e._propertyBindings,
                        o = e._interpolants,
                        s = i.uuid,
                        l = this._bindingsByRootAndName,
                        c = l[s];
                    void 0 === c && (c = {}, l[s] = c); for (var h = 0; h !== r; ++h) { var u = n[h],
                            d = u.name,
                            p = c[d]; if (void 0 !== p) a[h] = p;
                        else { if (void 0 !== (p = a[h])) { null === p._cacheIndex && (++p.referenceCount, this._addInactiveBinding(p, s, d)); continue } var f = t && t._propertyBindings[h].binding.parsedPath;++(p = new gh($h.create(i, d, f), u.ValueTypeName, u.getValueSize())).referenceCount, this._addInactiveBinding(p, s, d), a[h] = p }
                        o[h].resultBuffer = p.buffer } }, _activateAction: function(e) { if (!this._isActiveAction(e)) { if (null === e._cacheIndex) { var t = (e._localRoot || this._root).uuid,
                                i = e._clip.uuid,
                                n = this._actionsByClip[i];
                            this._bindAction(e, n && n.knownActions[0]), this._addInactiveAction(e, i, t) } for (var r = e._propertyBindings, a = 0, o = r.length; a !== o; ++a) { var s = r[a];
                            0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState()) }
                        this._lendAction(e) } }, _deactivateAction: function(e) { if (this._isActiveAction(e)) { for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) { var r = t[i];
                            0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r)) }
                        this._takeBackAction(e) } }, _initMemoryManager: function() { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; var e = this;
                    this.stats = { actions: {get total() { return e._actions.length }, get inUse() { return e._nActiveActions } }, bindings: {get total() { return e._bindings.length }, get inUse() { return e._nActiveBindings } }, controlInterpolants: {get total() { return e._controlInterpolants.length }, get inUse() { return e._nActiveControlInterpolants } } } }, _isActiveAction: function(e) { var t = e._cacheIndex; return null !== t && t < this._nActiveActions }, _addInactiveAction: function(e, t, i) { var n = this._actions,
                        r = this._actionsByClip,
                        a = r[t]; if (void 0 === a) a = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, r[t] = a;
                    else { var o = a.knownActions;
                        e._byClipCacheIndex = o.length, o.push(e) }
                    e._cacheIndex = n.length, n.push(e), a.actionByRoot[i] = e }, _removeInactiveAction: function(e) { var t = this._actions,
                        i = t[t.length - 1],
                        n = e._cacheIndex;
                    t[i._cacheIndex = n] = i, t.pop(), e._cacheIndex = null; var r = e._clip.uuid,
                        a = this._actionsByClip,
                        o = a[r],
                        s = o.knownActions,
                        l = s[s.length - 1],
                        c = e._byClipCacheIndex;
                    s[l._byClipCacheIndex = c] = l, s.pop(), e._byClipCacheIndex = null, delete o.actionByRoot[(e._localRoot || this._root).uuid], 0 === s.length && delete a[r], this._removeInactiveBindingsForAction(e) }, _removeInactiveBindingsForAction: function(e) { for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) { var r = t[i];
                        0 == --r.referenceCount && this._removeInactiveBinding(r) } }, _lendAction: function(e) { var t = this._actions,
                        i = e._cacheIndex,
                        n = this._nActiveActions++,
                        r = t[n];
                    t[e._cacheIndex = n] = e, t[r._cacheIndex = i] = r }, _takeBackAction: function(e) { var t = this._actions,
                        i = e._cacheIndex,
                        n = --this._nActiveActions,
                        r = t[n];
                    t[e._cacheIndex = n] = e, t[r._cacheIndex = i] = r }, _addInactiveBinding: function(e, t, i) { var n = this._bindingsByRootAndName,
                        r = n[t],
                        a = this._bindings;
                    void 0 === r && (r = {}, n[t] = r), (r[i] = e)._cacheIndex = a.length, a.push(e) }, _removeInactiveBinding: function(e) { var t = this._bindings,
                        i = e.binding,
                        n = i.rootNode.uuid,
                        r = i.path,
                        a = this._bindingsByRootAndName,
                        o = a[n],
                        s = t[t.length - 1],
                        l = e._cacheIndex;
                    t[s._cacheIndex = l] = s, t.pop(), delete o[r];
                    e: { for (var c in o) break e;delete a[n] } }, _lendBinding: function(e) { var t = this._bindings,
                        i = e._cacheIndex,
                        n = this._nActiveBindings++,
                        r = t[n];
                    t[e._cacheIndex = n] = e, t[r._cacheIndex = i] = r }, _takeBackBinding: function(e) { var t = this._bindings,
                        i = e._cacheIndex,
                        n = --this._nActiveBindings,
                        r = t[n];
                    t[e._cacheIndex = n] = e, t[r._cacheIndex = i] = r }, _lendControlInterpolant: function() { var e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        i = e[t]; return void 0 === i && (e[(i = new bl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = t] = i), i }, _takeBackControlInterpolant: function(e) { var t = this._controlInterpolants,
                        i = e.__cacheIndex,
                        n = --this._nActiveControlInterpolants,
                        r = t[n];
                    t[e.__cacheIndex = n] = e, t[r.__cacheIndex = i] = r }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function(e, t) { var i = t || this._root,
                        n = i.uuid,
                        r = "string" == typeof e ? Ll.findByName(i, e) : e,
                        a = null !== r ? r.uuid : e,
                        o = this._actionsByClip[a],
                        s = null; if (void 0 !== o) { var l = o.actionByRoot[n]; if (void 0 !== l) return l;
                        s = o.knownActions[0], null === r && (r = s._clip) } if (null === r) return null; var c = new tu(this, r, t); return this._bindAction(c, s), this._addInactiveAction(c, a, n), c }, existingAction: function(e, t) { var i = t || this._root,
                        n = i.uuid,
                        r = "string" == typeof e ? Ll.findByName(i, e) : e,
                        a = r ? r.uuid : e,
                        o = this._actionsByClip[a]; return void 0 !== o && o.actionByRoot[n] || null }, stopAllAction: function() { var e = this._actions,
                        t = this._nActiveActions,
                        i = this._bindings,
                        n = this._nActiveBindings;
                    this._nActiveActions = 0; for (var r = this._nActiveBindings = 0; r !== t; ++r) e[r].reset(); for (r = 0; r !== n; ++r) i[r].useCount = 0; return this }, update: function(e) { e *= this.timeScale; for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) { t[o]._update(n, e, r, a) } var s = this._bindings,
                        l = this._nActiveBindings; for (o = 0; o !== l; ++o) s[o].apply(a); return this }, getRoot: function() { return this._root }, uncacheClip: function(e) { var t = this._actions,
                        i = e.uuid,
                        n = this._actionsByClip,
                        r = n[i]; if (void 0 !== r) { for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) { var l = a[o];
                            this._deactivateAction(l); var c = l._cacheIndex,
                                h = t[t.length - 1];
                            l._cacheIndex = null, l._byClipCacheIndex = null, t[h._cacheIndex = c] = h, t.pop(), this._removeInactiveBindingsForAction(l) }
                        delete n[i] } }, uncacheRoot: function(e) { var t = e.uuid,
                        i = this._actionsByClip; for (var n in i) { var r = i[n].actionByRoot[t];
                        void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r)) } var a = this._bindingsByRootAndName[t]; if (void 0 !== a)
                        for (var o in a) { var s = a[o];
                            s.restoreOriginalState(), this._removeInactiveBinding(s) } }, uncacheAction: function(e, t) { var i = this.existingAction(e, t);
                    null !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } }), nu.prototype.clone = function() { return new nu(void 0 === this.value.clone ? this.value : this.value.clone()) }, ru.prototype = Object.assign(Object.create(Fn.prototype), { constructor: ru, isInstancedBufferGeometry: !0, copy: function(e) { return Fn.prototype.copy.call(this, e), this.maxInstancedCount = e.maxInstancedCount, this }, clone: function() { return (new this.constructor).copy(this) } }), au.prototype = Object.assign(Object.create(Lo.prototype), { constructor: au, isInstancedInterleavedBuffer: !0, copy: function(e) { return Lo.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this } }), ou.prototype = Object.assign(Object.create(gn.prototype), { constructor: ou, isInstancedBufferAttribute: !0, copy: function(e) { return gn.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this } }), Object.assign(su.prototype, { linePrecision: 1, set: function(e, t) { this.ray.set(e, t) }, setFromCamera: function(e, t) { t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function(e, t, i) { var n = i || []; return cu(e, this, n, t), n.sort(lu), n }, intersectObjects: function(e, t, i) { var n = i || []; if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n; for (var r = 0, a = e.length; r < a; r++) cu(e[r], this, n, t); return n.sort(lu), n } }), Object.assign(hu.prototype, { set: function(e, t, i) { return this.radius = e, this.phi = t, this.theta = i, this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this }, makeSafe: function() { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this }, setFromVector3: function(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) }, setFromCartesianCoords: function(e, t, i) { return this.radius = Math.sqrt(e * e + t * t + i * i), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(Ut.clamp(t / this.radius, -1, 1))), this } }), Object.assign(uu.prototype, { set: function(e, t, i) { return this.radius = e, this.theta = t, this.y = i, this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this }, setFromVector3: function(e) { return this.setFromCartesianCoords(e.x, e.y, e.z) }, setFromCartesianCoords: function(e, t, i) { return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this } }), Object.assign(du.prototype, { set: function(e, t) { return this.min.copy(e), this.max.copy(t), this }, setFromPoints: function(e) { this.makeEmpty(); for (var t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]); return this }, setFromCenterAndSize: (Ph = new Vt, function(e, t) { var i = Ph.copy(t).multiplyScalar(.5); return this.min.copy(e).sub(i), this.max.copy(e).add(i), this }), clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.min.copy(e.min), this.max.copy(e.max), this }, makeEmpty: function() { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function() { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function(e) { return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"), e = new Vt), this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function(e) { return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"), e = new Vt), this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min) }, expandByPoint: function(e) { return this.min.min(e), this.max.max(e), this }, expandByVector: function(e) { return this.min.sub(e), this.max.add(e), this }, expandByScalar: function(e) { return this.min.addScalar(-e), this.max.addScalar(e), this }, containsPoint: function(e) { return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y) }, containsBox: function(e) { return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y }, getParameter: function(e, t) { return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"), t = new Vt), t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function(e) { return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y) }, clampPoint: function(e, t) { return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"), t = new Vt), t.copy(e).clamp(this.min, this.max) }, distanceToPoint: (Eh = new Vt, function(e) { return Eh.copy(e).clamp(this.min, this.max).sub(e).length() }), intersect: function(e) { return this.min.max(e.min), this.max.min(e.max), this }, union: function(e) { return this.min.min(e.min), this.max.max(e.max), this }, translate: function(e) { return this.min.add(e), this.max.add(e), this }, equals: function(e) { return e.min.equals(this.min) && e.max.equals(this.max) } }), Object.assign(pu.prototype, { set: function(e, t) { return this.start.copy(e), this.end.copy(t), this }, clone: function() { return (new this.constructor).copy(this) }, copy: function(e) { return this.start.copy(e.start), this.end.copy(e.end), this }, getCenter: function(e) { return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"), e = new Xt), e.addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function(e) { return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"), e = new Xt), e.subVectors(this.end, this.start) }, distanceSq: function() { return this.start.distanceToSquared(this.end) }, distance: function() { return this.start.distanceTo(this.end) }, at: function(e, t) { return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"), t = new Xt), this.delta(t).multiplyScalar(e).add(this.start) }, closestPointToPointParameter: (Ah = new Xt, Ch = new Xt, function(e, t) { Ah.subVectors(e, this.start), Ch.subVectors(this.end, this.start); var i = Ch.dot(Ch),
                        n = Ch.dot(Ah) / i; return t && (n = Ut.clamp(n, 0, 1)), n }), closestPointToPoint: function(e, t, i) { var n = this.closestPointToPointParameter(e, t); return void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new Xt), this.delta(i).multiplyScalar(n).add(this.start) }, applyMatrix4: function(e) { return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this }, equals: function(e) { return e.start.equals(this.start) && e.end.equals(this.end) } }), ((fu.prototype = Object.create(on.prototype)).constructor = fu).prototype.isImmediateRenderObject = !0, ((mu.prototype = Object.create(zo.prototype)).constructor = mu).prototype.update = (Lh = new Xt, Rh = new Xt, Hh = new Yt, function() { var e = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), Hh.getNormalMatrix(this.object.matrixWorld); var t = this.object.matrixWorld,
                    i = this.geometry.attributes.position,
                    n = this.object.geometry; if (n && n.isGeometry)
                    for (var r = n.vertices, a = n.faces, o = 0, s = 0, l = a.length; s < l; s++)
                        for (var c = a[s], h = 0, u = c.vertexNormals.length; h < u; h++) { var d = r[c[e[h]]],
                                p = c.vertexNormals[h];
                            Lh.copy(d).applyMatrix4(t), Rh.copy(p).applyMatrix3(Hh).normalize().multiplyScalar(this.size).add(Lh), i.setXYZ(o, Lh.x, Lh.y, Lh.z), o += 1, i.setXYZ(o, Rh.x, Rh.y, Rh.z), o += 1 } else if (n && n.isBufferGeometry) { var f = n.attributes.position,
                                m = n.attributes.normal; for (h = o = 0, u = f.count; h < u; h++) Lh.set(f.getX(h), f.getY(h), f.getZ(h)).applyMatrix4(t), Rh.set(m.getX(h), m.getY(h), m.getZ(h)), Rh.applyMatrix3(Hh).normalize().multiplyScalar(this.size).add(Lh), i.setXYZ(o, Lh.x, Lh.y, Lh.z), o += 1, i.setXYZ(o, Rh.x, Rh.y, Rh.z), o += 1 }
                i.needsUpdate = !0 }), ((gu.prototype = Object.create(on.prototype)).constructor = gu).prototype.dispose = function() { this.cone.geometry.dispose(), this.cone.material.dispose() }, gu.prototype.update = (Oh = new Xt, function() { this.light.updateMatrixWorld(); var e = this.light.distance ? this.light.distance : 1e3,
                    t = e * Math.tan(this.light.angle);
                this.cone.scale.set(t, t, e), Oh.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(Oh), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) }), ((vu.prototype = Object.create(zo.prototype)).constructor = vu).prototype.updateMatrixWorld = (Gh = new Xt, Dh = new jt, Ih = new jt, function(e) { var t = this.bones,
                    i = this.geometry,
                    n = i.getAttribute("position");
                Ih.getInverse(this.root.matrixWorld); for (var r = 0, a = 0; r < t.length; r++) { var o = t[r];
                    o.parent && o.parent.isBone && (Dh.multiplyMatrices(Ih, o.matrixWorld), Gh.setFromMatrixPosition(Dh), n.setXYZ(a, Gh.x, Gh.y, Gh.z), Dh.multiplyMatrices(Ih, o.parent.matrixWorld), Gh.setFromMatrixPosition(Dh), n.setXYZ(a + 1, Gh.x, Gh.y, Gh.z), a += 2) }
                i.getAttribute("position").needsUpdate = !0, on.prototype.updateMatrixWorld.call(this, e) }), ((Mu.prototype = Object.create(Tr.prototype)).constructor = Mu).prototype.dispose = function() { this.geometry.dispose(), this.material.dispose() }, Mu.prototype.update = function() { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }, ((yu.prototype = Object.create(Fo.prototype)).constructor = yu).prototype.update = function() { if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
                else { this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity); var e = this.material.color,
                        t = Math.max(e.r, e.g, e.b);
                    1 < t && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color) } }, yu.prototype.dispose = function() { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() }, ((bu.prototype = Object.create(on.prototype)).constructor = bu).prototype.dispose = function() { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, bu.prototype.update = (Bh = new Xt, Nh = new Li, Fh = new Li, function() { var e = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color);
                else { var t = e.geometry.getAttribute("color");
                    Nh.copy(this.light.color), Fh.copy(this.light.groundColor); for (var i = 0, n = t.count; i < n; i++) { var r = i < n / 2 ? Nh : Fh;
                        t.setXYZ(i, r.r, r.g, r.b) }
                    t.needsUpdate = !0 }
                e.lookAt(Bh.setFromMatrixPosition(this.light.matrixWorld).negate()) }), (_u.prototype = Object.create(zo.prototype)).constructor = _u, (xu.prototype = Object.create(zo.prototype)).constructor = xu, ((Tu.prototype = Object.create(Fo.prototype)).constructor = Tu).prototype.update = function() { var a, o, e = this.audio,
                    s = this.range,
                    t = this.divisionsInnerAngle,
                    i = this.divisionsOuterAngle,
                    n = Ut.degToRad(e.panner.coneInnerAngle),
                    r = Ut.degToRad(e.panner.coneOuterAngle),
                    l = n / 2,
                    c = r / 2,
                    h = 0,
                    u = 0,
                    d = this.geometry,
                    p = d.attributes.position;

                function f(e, t, i, n) { var r = (t - e) / i; for (p.setXYZ(h, 0, 0, 0), u++, a = e; a < t; a += r) o = h + u, p.setXYZ(o, Math.sin(a) * s, 0, Math.cos(a) * s), p.setXYZ(o + 1, Math.sin(Math.min(a + r, t)) * s, 0, Math.cos(Math.min(a + r, t)) * s), p.setXYZ(o + 2, 0, 0, 0), u += 3;
                    d.addGroup(h, u, n), h += u, u = 0 }
                d.clearGroups(), f(-c, -l, i, 0), f(-l, l, t, 1), f(l, c, i, 0), p.needsUpdate = !0, n === r && (this.material[0].visible = !1) }, Tu.prototype.dispose = function() { this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose() }, ((wu.prototype = Object.create(zo.prototype)).constructor = wu).prototype.update = (zh = new Xt, kh = new Xt, Uh = new Yt, function() { this.object.updateMatrixWorld(!0), Uh.getNormalMatrix(this.object.matrixWorld); for (var e = this.object.matrixWorld, t = this.geometry.attributes.position, i = this.object.geometry, n = i.vertices, r = i.faces, a = 0, o = 0, s = r.length; o < s; o++) { var l = r[o],
                        c = l.normal;
                    zh.copy(n[l.a]).add(n[l.b]).add(n[l.c]).divideScalar(3).applyMatrix4(e), kh.copy(c).applyMatrix3(Uh).normalize().multiplyScalar(this.size).add(zh), t.setXYZ(a, zh.x, zh.y, zh.z), a += 1, t.setXYZ(a, kh.x, kh.y, kh.z), a += 1 }
                t.needsUpdate = !0 }), ((Su.prototype = Object.create(on.prototype)).constructor = Su).prototype.dispose = function() { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, Su.prototype.update = (Vh = new Xt, jh = new Xt, Wh = new Xt, function() { Vh.setFromMatrixPosition(this.light.matrixWorld), jh.setFromMatrixPosition(this.light.target.matrixWorld), Wh.subVectors(jh, Vh), this.lightPlane.lookAt(jh), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(jh), this.targetLine.scale.z = Wh.length() }), ((Eu.prototype = Object.create(zo.prototype)).constructor = Eu).prototype.update = function() { var l, c, h = new Xt,
                    u = new to;

                function e(e, t, i, n) { h.set(t, i, n).unproject(u); var r = c[e]; if (void 0 !== r)
                        for (var a = l.getAttribute("position"), o = 0, s = r.length; o < s; o++) a.setXYZ(r[o], h.x, h.y, h.z) } return function() { l = this.geometry, c = this.pointMap;
                    u.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -1, -1, -1), e("n2", 1, -1, -1), e("n3", -1, 1, -1), e("n4", 1, 1, -1), e("f1", -1, -1, 1), e("f2", 1, -1, 1), e("f3", -1, 1, 1), e("f4", 1, 1, 1), e("u1", .7, 1.1, -1), e("u2", -.7, 1.1, -1), e("u3", 0, 2, -1), e("cf1", -1, 0, 1), e("cf2", 1, 0, 1), e("cf3", 0, -1, 1), e("cf4", 0, 1, 1), e("cn1", -1, 0, -1), e("cn2", 1, 0, -1), e("cn3", 0, -1, -1), e("cn4", 0, 1, -1), l.getAttribute("position").needsUpdate = !0 } }(), ((Pu.prototype = Object.create(zo.prototype)).constructor = Pu).prototype.update = (Xh = new Mi, function(e) { if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && Xh.setFromObject(this.object), !Xh.isEmpty()) { var t = Xh.min,
                        i = Xh.max,
                        n = this.geometry.attributes.position,
                        r = n.array;
                    r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = t.x, r[4] = i.y, r[5] = i.z, r[6] = t.x, r[7] = t.y, r[8] = i.z, r[9] = i.x, r[10] = t.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = t.z, r[15] = t.x, r[16] = i.y, r[17] = t.z, r[18] = t.x, r[19] = t.y, r[20] = t.z, r[21] = i.x, r[22] = t.y, r[23] = t.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere() } }), Pu.prototype.setFromObject = function(e) { return this.object = e, this.update(), this }, Pu.prototype.copy = function(e) { return zo.prototype.copy.call(this, e), this.object = e.object, this }, Pu.prototype.clone = function() { return (new this.constructor).copy(this) }, ((Au.prototype = Object.create(zo.prototype)).constructor = Au).prototype.updateMatrixWorld = function(e) { var t = this.box;
                t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), on.prototype.updateMatrixWorld.call(this, e)) }, ((Cu.prototype = Object.create(Fo.prototype)).constructor = Cu).prototype.updateMatrixWorld = function(e) { var t = -this.plane.constant;
                Math.abs(t) < 1e-8 && (t = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, t), this.children[0].material.side = t < 0 ? xe : D, this.lookAt(this.plane.normal), on.prototype.updateMatrixWorld.call(this, e) }, ((Lu.prototype = Object.create(on.prototype)).constructor = Lu).prototype.setDirection = (Jh = new Xt, function(e) { .99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Jh.set(e.z, 0, -e.x).normalize(), Zh = Math.acos(e.y), this.quaternion.setFromAxisAngle(Jh, Zh)) }), Lu.prototype.setLength = function(e, t, i) { void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix() }, Lu.prototype.setColor = function(e) { this.line.material.color.copy(e), this.cone.material.color.copy(e) }, Lu.prototype.copy = function(e) { return on.prototype.copy.call(this, e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this }, Lu.prototype.clone = function() { return (new this.constructor).copy(this) }, (Ru.prototype = Object.create(zo.prototype)).constructor = Ru; var Hu;

            function Ou(e) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Kl.call(this, e), this.type = "catmullrom", this.closed = !0 }

            function Gu(e) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Kl.call(this, e), this.type = "catmullrom" }

            function Du(e) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Kl.call(this, e), this.type = "catmullrom" }
            Vl.create = function(e, t) { return console.log("THREE.Curve.create() has been deprecated"), e.prototype = Object.create(Vl.prototype), (e.prototype.constructor = e).prototype.getPoint = t, e }, Object.assign(cc.prototype, { createPointsGeometry: function(e) { console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var t = this.getPoints(e); return this.createGeometry(t) }, createSpacedPointsGeometry: function(e) { console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); var t = this.getSpacedPoints(e); return this.createGeometry(t) }, createGeometry: function(e) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var t = new mn, i = 0, n = e.length; i < n; i++) { var r = e[i];
                        t.vertices.push(new Xt(r.x, r.y, r.z || 0)) } return t } }), Object.assign(hc.prototype, { fromPoints: function(e) { console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(e) } }), Ou.prototype = Object.create(Kl.prototype), Gu.prototype = Object.create(Kl.prototype), Du.prototype = Object.create(Kl.prototype), Object.assign(Du.prototype, { initFromArray: function() { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function() { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function() { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), _u.prototype.setColors = function() { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, vu.prototype.update = function() { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(kc.prototype, { extractUrlBase: function(e) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), wc.extractUrlBase(e) } }), Object.assign(Pc.prototype, { setTexturePath: function(e) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(e) } }), Object.assign(du.prototype, { center: function(e) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function() { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function(e) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, size: function(e) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(e) } }), Object.assign(Mi.prototype, { center: function(e) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, empty: function() { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function(e) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionSphere: function(e) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) }, size: function(e) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(e) } }), pu.prototype.center = function(e) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(e) }, Object.assign(Ut, { random16: function() { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function(e) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Ut.floorPowerOfTwo(e) }, nextPowerOfTwo: function(e) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Ut.ceilPowerOfTwo(e) } }), Object.assign(Yt.prototype, { flattenToArrayOffset: function(e, t) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, multiplyVector3: function(e) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this) }, multiplyVector3Array: function() { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBuffer: function(e) { return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e) }, applyToVector3Array: function() { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(jt.prototype, { extractPosition: function(e) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e) }, flattenToArrayOffset: function(e, t) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(e, t) }, getPosition: function() { return void 0 === Hu && (Hu = new Xt), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), Hu.setFromMatrixColumn(this, 3) }, setRotationFromQuaternion: function(e) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e) }, multiplyToArray: function() { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function(e) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector4: function(e) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, multiplyVector3Array: function() { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function(e) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this) }, crossVector: function(e) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this) }, translate: function() { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function() { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function() { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function() { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function() { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBuffer: function(e) { return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(e) }, applyToVector3Array: function() { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function(e, t, i, n, r, a) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(e, t, n, i, r, a) } }), bi.prototype.isIntersectionLine = function(e) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e) }, Wt.prototype.multiplyVector3 = function(e) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this) }, Object.assign(br.prototype, { isIntersectionBox: function(e) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e) }, isIntersectionPlane: function(e) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e) }, isIntersectionSphere: function(e) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e) } }), Object.assign(_r.prototype, { area: function() { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function(e, t) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(e, t) }, midpoint: function(e) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(e) }, normal: function(e) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(e) }, plane: function(e) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(e) } }), Object.assign(_r, { barycoordFromPoint: function(e, t, i, n, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), _r.getBarycoord(e, t, i, n, r) }, normal: function(e, t, i, n) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), _r.getNormal(e, t, i, n) } }), Object.assign(uc.prototype, { extractAllPoints: function(e) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(e) }, extrude: function(e) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Bs(this, e) }, makeGeometry: function(e) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Zs(this, e) } }), Object.assign(Vt.prototype, { fromAttribute: function(e, t, i) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, distanceToManhattan: function(e) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function() { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(Xt.prototype, { setEulerFromRotationMatrix: function() { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function() { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function(e) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e) }, getScaleFromMatrix: function(e) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e) }, getColumnFromMatrix: function(e, t) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, e) }, applyProjection: function(e) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(e) }, fromAttribute: function(e, t, i) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, distanceToManhattan: function(e) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(e) }, lengthManhattan: function() { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(pi.prototype, { fromAttribute: function(e, t, i) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(e, t, i) }, lengthManhattan: function() { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(mn.prototype, { computeTangents: function() { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function() { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") } }), Object.assign(on.prototype, { getChildByName: function(e) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e) }, renderDepth: function() { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function(e, t) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e) }, getWorldRotation: function() { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") } }), Object.defineProperties(on.prototype, { eulerOrder: { get: function() { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function(e) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e } }, useQuaternion: { get: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function() { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.defineProperties(Go.prototype, { objects: { get: function() { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(Io.prototype, "useVertexTexture", { get: function() { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function() { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), Do.prototype.initBones = function() { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Vl.prototype, "__arcLengthDivisions", { get: function() { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function(e) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = e } }), io.prototype.setLens = function(e, t) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== t && (this.filmGauge = t), this.setFocalLength(e) }, Object.defineProperties(dc.prototype, { onlyShadow: { set: function() { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function(e) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e } }, shadowCameraLeft: { set: function(e) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e } }, shadowCameraRight: { set: function(e) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e } }, shadowCameraTop: { set: function(e) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e } }, shadowCameraBottom: { set: function(e) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e } }, shadowCameraNear: { set: function(e) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e } }, shadowCameraFar: { set: function(e) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e } }, shadowCameraVisible: { set: function() { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function(e) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e } }, shadowDarkness: { set: function() { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function(e) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e } }, shadowMapHeight: { set: function(e) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e } } }), Object.defineProperties(gn.prototype, { length: { get: function() { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, copyIndicesArray: function() { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") } }), Object.assign(Fn.prototype, { addIndex: function(e) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e) }, addDrawCall: function(e, t, i) { void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t) }, clearDrawCalls: function() { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function() { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function() { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") } }), Object.defineProperties(Fn.prototype, { drawcalls: { get: function() { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function() { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.assign(Ns.prototype, { getArrays: function() { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function() { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function() { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.defineProperties(nu.prototype, { dynamic: { set: function() { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function() { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(Wn.prototype, { wrapAround: { get: function() { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function() { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function() { console.warn("THREE.Material: .overdraw has been removed.") }, set: function() { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function() { return console.warn("THREE.Material: .wrapRGB has been removed."), new Li } }, shading: { get: function() { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function(e) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === e } } }), Object.defineProperties(hl.prototype, { metal: { get: function() { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function() { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(yr.prototype, { derivatives: { get: function() { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function(e) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e } } }), Object.assign(Eo.prototype, { clearTarget: function(e, t, i, n) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(e), this.clear(t, i, n) }, animate: function(e) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(e) }, getCurrentRenderTarget: function() { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function() { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function() { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function() { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function() { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function() { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function() { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function() { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function() { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function(e) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e) }, initMaterial: function() { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function() { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function() { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function() { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function() { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") } }), Object.defineProperties(Eo.prototype, { shadowMapEnabled: { get: function() { return this.shadowMap.enabled }, set: function(e) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e } }, shadowMapType: { get: function() { return this.shadowMap.type }, set: function(e) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e } }, shadowMapCullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(Ja.prototype, { cullFace: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function() { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(gi.prototype, { activeCubeFace: { set: function() { console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().") } }, activeMipMapLevel: { set: function() { console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().") } } }), Object.defineProperties(fi.prototype, { wrapS: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e } }, wrapT: { get: function() { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e } }, magFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e } }, minFilter: { get: function() { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e } }, anisotropy: { get: function() { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e } }, offset: { get: function() { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e } }, repeat: { get: function() { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e } }, format: { get: function() { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e } }, type: { get: function() { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e } }, generateMipmaps: { get: function() { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function(e) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e } } }), Object.defineProperties(wo.prototype, { standing: { set: function() { console.warn("THREE.WebVRManager: .standing has been removed.") } }, userHeight: { set: function() { console.warn("THREE.WebVRManager: .userHeight has been removed.") } } }), ph.prototype.load = function(e) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var t = this; return (new lh).load(e, function(e) { t.setBuffer(e) }), this }, mh.prototype.getData = function() { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, hh.prototype.updateCubeMap = function(e, t) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(e, t) }; var Iu = { merge: function(e, t, i) { var n;
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(), n = t.matrix, t = t.geometry), e.merge(t, n, i) }, center: function(e) { return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center() } };
            hi.crossOrigin = void 0, hi.loadTexture = function(e, t, i, n) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var r = new Ul;
                r.setCrossOrigin(this.crossOrigin); var a = r.load(e, i, void 0, n); return t && (a.mapping = t), a }, hi.loadTextureCube = function(e, t, i, n) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var r = new kl;
                r.setCrossOrigin(this.crossOrigin); var a = r.load(e, i, void 0, n); return t && (a.mapping = t), a }, hi.loadCompressedTexture = function() { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, hi.loadCompressedTextureCube = function() { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }; var Bu = { createMultiMaterialObject: function() { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, detach: function() { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, attach: function() { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") } };
            e.WebGLMultisampleRenderTarget = mi, e.WebGLRenderTargetCube = gi, e.WebGLRenderTarget = fi, e.WebGLRenderer = Eo, e.ShaderLib = Gi, e.UniformsLib = Oi, e.UniformsUtils = Ai, e.ShaderChunk = xi, e.FogExp2 = Po, e.Fog = Ao, e.Scene = Co, e.Sprite = Oo, e.LOD = Go, e.SkinnedMesh = Do, e.Skeleton = Io, e.Bone = Bo, e.Mesh = Tr, e.LineSegments = zo, e.LineLoop = ko, e.Line = Fo, e.Points = Vo, e.Group = eo, e.VideoTexture = jo, e.DataTexture = vi, e.DataTexture3D = Ir, e.CompressedTexture = Wo, e.CubeTexture = Dr, e.CanvasTexture = Xo, e.DepthTexture = Yo, e.Texture = di, e.AnimationLoader = Bl, e.CompressedTextureLoader = Nl, e.DataTextureLoader = Fl, e.CubeTextureLoader = kl, e.TextureLoader = Ul, e.ObjectLoader = Pc, e.MaterialLoader = Tc, e.BufferGeometryLoader = Sc, e.DefaultLoadingManager = Gl, e.LoadingManager = Ol, e.ImageLoader = zl, e.ImageBitmapLoader = Ic, e.FontLoader = zc, e.FileLoader = Il, e.Loader = kc, e.LoaderUtils = wc, e.Cache = Hl, e.AudioLoader = lh, e.SpotLightShadow = mc, e.SpotLight = gc, e.PointLight = vc, e.RectAreaLight = xc, e.HemisphereLight = pc, e.DirectionalLightShadow = yc, e.DirectionalLight = bc, e.AmbientLight = _c, e.LightShadow = fc, e.Light = dc, e.StereoCamera = ch, e.PerspectiveCamera = io, e.OrthographicCamera = Mc, e.CubeCamera = hh, e.ArrayCamera = no, e.Camera = to, e.AudioListener = dh, e.PositionalAudio = fh, e.AudioContext = sh, e.AudioAnalyser = mh, e.Audio = ph, e.VectorKeyframeTrack = Cl, e.StringKeyframeTrack = Al, e.QuaternionKeyframeTrack = Pl, e.NumberKeyframeTrack = Sl, e.ColorKeyframeTrack = wl, e.BooleanKeyframeTrack = Tl, e.PropertyMixer = gh, e.PropertyBinding = $h, e.KeyframeTrack = xl, e.AnimationUtils = vl, e.AnimationObjectGroup = eu, e.AnimationMixer = iu, e.AnimationClip = Ll, e.Uniform = nu, e.InstancedBufferGeometry = ru, e.BufferGeometry = Fn, e.Geometry = mn, e.InterleavedBufferAttribute = Ro, e.InstancedInterleavedBuffer = au, e.InterleavedBuffer = Lo, e.InstancedBufferAttribute = ou, e.Face3 = Bi, e.Object3D = on, e.Raycaster = su, e.Layers = Fi, e.EventDispatcher = t, e.Clock = uh, e.QuaternionLinearInterpolant = El, e.LinearInterpolant = bl, e.DiscreteInterpolant = _l, e.CubicInterpolant = yl, e.Interpolant = Ml, e.Triangle = _r, e.Math = Ut, e.Spherical = hu, e.Cylindrical = uu, e.Plane = bi, e.Frustum = _i, e.Sphere = yi, e.Ray = br, e.Matrix4 = jt, e.Matrix3 = Yt, e.Box3 = Mi, e.Box2 = du, e.Line3 = pu, e.Euler = Ni, e.Vector4 = pi, e.Vector3 = Xt, e.Vector2 = Vt, e.Quaternion = Wt, e.Color = Li, e.ImmediateRenderObject = fu, e.VertexNormalsHelper = mu, e.SpotLightHelper = gu, e.SkeletonHelper = vu, e.PointLightHelper = Mu, e.RectAreaLightHelper = yu, e.HemisphereLightHelper = bu, e.GridHelper = _u, e.PolarGridHelper = xu, e.PositionalAudioHelper = Tu, e.FaceNormalsHelper = wu, e.DirectionalLightHelper = Su, e.CameraHelper = Eu, e.BoxHelper = Pu, e.Box3Helper = Au, e.PlaneHelper = Cu, e.ArrowHelper = Lu, e.AxesHelper = Ru, e.Shape = uc, e.Path = hc, e.ShapePath = Bc, e.Font = Nc, e.CurvePath = cc, e.Curve = Vl, e.ImageUtils = hi, e.ShapeUtils = Gs, e.WebGLUtils = $a, e.WireframeGeometry = qo, e.ParametricGeometry = Zo, e.ParametricBufferGeometry = Jo, e.TetrahedronGeometry = $o, e.TetrahedronBufferGeometry = es, e.OctahedronGeometry = ts, e.OctahedronBufferGeometry = is, e.IcosahedronGeometry = ns, e.IcosahedronBufferGeometry = rs, e.DodecahedronGeometry = as, e.DodecahedronBufferGeometry = os, e.PolyhedronGeometry = Ko, e.PolyhedronBufferGeometry = Qo, e.TubeGeometry = ss, e.TubeBufferGeometry = ls, e.TorusKnotGeometry = cs, e.TorusKnotBufferGeometry = hs, e.TorusGeometry = us, e.TorusBufferGeometry = ds, e.TextGeometry = ks, e.TextBufferGeometry = Us, e.SphereGeometry = Vs, e.SphereBufferGeometry = js, e.RingGeometry = Ws, e.RingBufferGeometry = Xs, e.PlaneGeometry = Un, e.PlaneBufferGeometry = Vn, e.LatheGeometry = Ys, e.LatheBufferGeometry = qs, e.ShapeGeometry = Zs, e.ShapeBufferGeometry = Js, e.ExtrudeGeometry = Bs, e.ExtrudeBufferGeometry = Ns, e.EdgesGeometry = Qs, e.ConeGeometry = tl, e.ConeBufferGeometry = il, e.CylinderGeometry = $s, e.CylinderBufferGeometry = el, e.CircleGeometry = nl, e.CircleBufferGeometry = rl, e.BoxGeometry = zn, e.CubeGeometry = zn, e.BoxBufferGeometry = kn, e.ShadowMaterial = ol, e.SpriteMaterial = Ho, e.RawShaderMaterial = sl, e.ShaderMaterial = yr, e.PointsMaterial = Uo, e.MeshPhysicalMaterial = cl, e.MeshStandardMaterial = ll, e.MeshPhongMaterial = hl, e.MeshToonMaterial = ul, e.MeshNormalMaterial = dl, e.MeshLambertMaterial = pl, e.MeshDepthMaterial = qa, e.MeshDistanceMaterial = Za, e.MeshBasicMaterial = xr, e.MeshMatcapMaterial = fl, e.LineDashedMaterial = ml, e.LineBasicMaterial = No, e.Material = Wn, e.Float64BufferAttribute = Sn, e.Float32BufferAttribute = wn, e.Uint32BufferAttribute = Tn, e.Int32BufferAttribute = xn, e.Uint16BufferAttribute = _n, e.Int16BufferAttribute = bn, e.Uint8ClampedBufferAttribute = yn, e.Uint8BufferAttribute = Mn, e.Int8BufferAttribute = vn, e.BufferAttribute = gn, e.ArcCurve = Wl, e.CatmullRomCurve3 = Kl, e.CubicBezierCurve = tc, e.CubicBezierCurve3 = ic, e.EllipseCurve = jl, e.LineCurve = nc, e.LineCurve3 = rc, e.QuadraticBezierCurve = ac, e.QuadraticBezierCurve3 = oc, e.SplineCurve = sc, e.REVISION = "102", e.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, e.CullFaceNone = X, e.CullFaceBack = Y, e.CullFaceFront = q, e.CullFaceFrontBack = 3, e.FrontFaceDirectionCW = 0, e.FrontFaceDirectionCCW = 1, e.BasicShadowMap = 0, e.PCFShadowMap = F, e.PCFSoftShadowMap = z, e.FrontSide = D, e.BackSide = xe, e.DoubleSide = ee, e.FlatShading = 1, e.SmoothShading = 2, e.NoColors = w, e.FaceColors = 1, e.VertexColors = S, e.NoBlending = Z, e.NormalBlending = J, e.AdditiveBlending = K, e.SubtractiveBlending = Q, e.MultiplyBlending = $, e.CustomBlending = te, e.AddEquation = ie, e.SubtractEquation = E, e.ReverseSubtractEquation = P, e.MinEquation = A, e.MaxEquation = C, e.ZeroFactor = L, e.OneFactor = R, e.SrcColorFactor = H, e.OneMinusSrcColorFactor = O, e.SrcAlphaFactor = G, e.OneMinusSrcAlphaFactor = I, e.DstAlphaFactor = B, e.OneMinusDstAlphaFactor = N, e.DstColorFactor = k, e.OneMinusDstColorFactor = U, e.SrcAlphaSaturateFactor = V, e.NeverDepth = ne, e.AlwaysDepth = re, e.LessDepth = ae, e.LessEqualDepth = oe, e.EqualDepth = se, e.GreaterEqualDepth = le, e.GreaterDepth = ce, e.NotEqualDepth = he, e.MultiplyOperation = j, e.MixOperation = W, e.AddOperation = ue, e.NoToneMapping = de, e.LinearToneMapping = Te, e.ReinhardToneMapping = pe, e.Uncharted2ToneMapping = fe, e.CineonToneMapping = me, e.ACESFilmicToneMapping = ge, e.UVMapping = 300, e.CubeReflectionMapping = ve, e.CubeRefractionMapping = Me, e.EquirectangularReflectionMapping = ye, e.EquirectangularRefractionMapping = be, e.SphericalReflectionMapping = _e, e.CubeUVReflectionMapping = we, e.CubeUVRefractionMapping = Se, e.RepeatWrapping = Ee, e.ClampToEdgeWrapping = Pe, e.MirroredRepeatWrapping = Ae, e.NearestFilter = Ce, e.NearestMipMapNearestFilter = Le, e.NearestMipMapLinearFilter = Re, e.LinearFilter = He, e.LinearMipMapNearestFilter = Oe, e.LinearMipMapLinearFilter = Ge, e.UnsignedByteType = De, e.ByteType = Ie, e.ShortType = Be, e.UnsignedShortType = Ne, e.IntType = Fe, e.UnsignedIntType = ze, e.FloatType = ke, e.HalfFloatType = Ue, e.UnsignedShort4444Type = Ve, e.UnsignedShort5551Type = je, e.UnsignedShort565Type = We, e.UnsignedInt248Type = Xe, e.AlphaFormat = Ye, e.RGBFormat = qe, e.RGBAFormat = Ze, e.LuminanceFormat = Je, e.LuminanceAlphaFormat = Ke, e.RGBEFormat = Qe, e.DepthFormat = $e, e.DepthStencilFormat = et, e.RedFormat = tt, e.RGB_S3TC_DXT1_Format = it, e.RGBA_S3TC_DXT1_Format = nt, e.RGBA_S3TC_DXT3_Format = rt, e.RGBA_S3TC_DXT5_Format = at, e.RGB_PVRTC_4BPPV1_Format = ot, e.RGB_PVRTC_2BPPV1_Format = st, e.RGBA_PVRTC_4BPPV1_Format = lt, e.RGBA_PVRTC_2BPPV1_Format = ct, e.RGB_ETC1_Format = ht, e.RGBA_ASTC_4x4_Format = ut, e.RGBA_ASTC_5x4_Format = dt, e.RGBA_ASTC_5x5_Format = pt, e.RGBA_ASTC_6x5_Format = ft, e.RGBA_ASTC_6x6_Format = mt, e.RGBA_ASTC_8x5_Format = gt, e.RGBA_ASTC_8x6_Format = vt, e.RGBA_ASTC_8x8_Format = Mt, e.RGBA_ASTC_10x5_Format = yt, e.RGBA_ASTC_10x6_Format = bt, e.RGBA_ASTC_10x8_Format = _t, e.RGBA_ASTC_10x10_Format = xt, e.RGBA_ASTC_12x10_Format = Tt, e.RGBA_ASTC_12x12_Format = wt, e.LoopOnce = 2200, e.LoopRepeat = 2201, e.LoopPingPong = 2202, e.InterpolateDiscrete = St, e.InterpolateLinear = Et, e.InterpolateSmooth = 2302, e.ZeroCurvatureEnding = Pt, e.ZeroSlopeEnding = At, e.WrapAroundEnding = Ct, e.TrianglesDrawMode = Lt, e.TriangleStripDrawMode = 1, e.TriangleFanDrawMode = 2, e.LinearEncoding = Rt, e.sRGBEncoding = Ht, e.GammaEncoding = Ot, e.RGBEEncoding = Gt, e.LogLuvEncoding = 3003, e.RGBM7Encoding = Dt, e.RGBM16Encoding = It, e.RGBDEncoding = Bt, e.BasicDepthPacking = Nt, e.RGBADepthPacking = Ft, e.TangentSpaceNormalMap = zt, e.ObjectSpaceNormalMap = kt, e.Face4 = function(e, t, i, n, r, a, o) { return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new Bi(e, t, i, r, a, o) }, e.LineStrip = 0, e.LinePieces = 1, e.MeshFaceMaterial = function(e) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), e }, e.MultiMaterial = function(e) { return void 0 === e && (e = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), e.isMultiMaterial = !0, (e.materials = e).clone = function() { return e.slice() }, e }, e.PointCloud = function(e, t) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Vo(e, t) }, e.Particle = function(e) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Oo(e) }, e.ParticleSystem = function(e, t) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Vo(e, t) }, e.PointCloudMaterial = function(e) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new Uo(e) }, e.ParticleBasicMaterial = function(e) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new Uo(e) }, e.ParticleSystemMaterial = function(e) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new Uo(e) }, e.Vertex = function(e, t, i) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new Xt(e, t, i) }, e.DynamicBufferAttribute = function(e, t) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new gn(e, t).setDynamic(!0) }, e.Int8Attribute = function(e, t) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new vn(e, t) }, e.Uint8Attribute = function(e, t) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Mn(e, t) }, e.Uint8ClampedAttribute = function(e, t) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new yn(e, t) }, e.Int16Attribute = function(e, t) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new bn(e, t) }, e.Uint16Attribute = function(e, t) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new _n(e, t) }, e.Int32Attribute = function(e, t) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new xn(e, t) }, e.Uint32Attribute = function(e, t) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Tn(e, t) }, e.Float32Attribute = function(e, t) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new wn(e, t) }, e.Float64Attribute = function(e, t) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Sn(e, t) }, e.ClosedSplineCurve3 = Ou, e.SplineCurve3 = Gu, e.Spline = Du, e.AxisHelper = function(e) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Ru(e) }, e.BoundingBoxHelper = function(e, t) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new Pu(e, t) }, e.EdgesHelper = function(e, t) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new zo(new Qs(e.geometry), new No({ color: void 0 !== t ? t : 16777215 })) }, e.WireframeHelper = function(e, t) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new zo(new qo(e.geometry), new No({ color: void 0 !== t ? t : 16777215 })) }, e.XHRLoader = function(e) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Il(e) }, e.BinaryTextureLoader = function(e) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Fl(e) }, e.GeometryUtils = Iu, e.Projector = function() { console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e, t) { console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t) }, this.unprojectVector = function(e, t) { console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t) }, this.pickingRay = function() { console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().") } }, e.CanvasRenderer = function() { console.error("THREE.CanvasRenderer has been removed") }, e.JSONLoader = function() { console.error("THREE.JSONLoader has been removed.") }, e.SceneUtils = Bu, e.LensFlare = function() { console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js") }, Object.defineProperty(e, "__esModule", { value: !0 }) }, "object" == typeof i && void 0 !== t ? r(i) : "function" == typeof define && define.amd ? define(["exports"], r) : r((n = n || self).THREE = {}) }, {}] }, {}, [9]);